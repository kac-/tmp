diff --git a/core/src/main/java/com/google/bitcoin/core/AbstractWalletEventListener.java b/core/src/main/java/com/google/bitcoin/core/AbstractWalletEventListener.java
index 60cf24a..acccf17 100644
--- a/core/src/main/java/com/google/bitcoin/core/AbstractWalletEventListener.java
+++ b/core/src/main/java/com/google/bitcoin/core/AbstractWalletEventListener.java
@@ -17,6 +17,7 @@
 package com.google.bitcoin.core;
 
 import com.google.bitcoin.script.Script;
+import com.google.bitcoin.wallet.AbstractKeyChainEventListener;
 
 import java.math.BigInteger;
 import java.util.List;
@@ -24,7 +25,7 @@ import java.util.List;
 /**
  * Convenience implementation of {@link WalletEventListener}.
  */
-public abstract class AbstractWalletEventListener implements WalletEventListener {
+public abstract class AbstractWalletEventListener extends AbstractKeyChainEventListener implements WalletEventListener {
     @Override
     public void onCoinsReceived(Wallet wallet, Transaction tx, BigInteger prevBalance, BigInteger newBalance) {
         onChange();
@@ -46,7 +47,7 @@ public abstract class AbstractWalletEventListener implements WalletEventListener
     }
 
     @Override
-    public void onKeysAdded(Wallet wallet, List<ECKey> keys) {
+    public void onKeysAdded(List<ECKey> keys) {
         onChange();
     }
 
diff --git a/core/src/main/java/com/google/bitcoin/core/BitcoinSerializer.java b/core/src/main/java/com/google/bitcoin/core/BitcoinSerializer.java
index f3575fb..dfe1d6c 100644
--- a/core/src/main/java/com/google/bitcoin/core/BitcoinSerializer.java
+++ b/core/src/main/java/com/google/bitcoin/core/BitcoinSerializer.java
@@ -188,7 +188,7 @@ public class BitcoinSerializer {
         try {
             return makeMessage(header.command, header.size, payloadBytes, hash, header.checksum);
         } catch (Exception e) {
-            throw new ProtocolException("Error deserializing message " + Utils.bytesToHexString(payloadBytes) + "\n", e);
+            throw new ProtocolException("Error deserializing message " + Utils.bytesToHexString(header.header)+ "\n" + Utils.bytesToHexString(payloadBytes) + "\n", e);
         }
     }
 
@@ -232,6 +232,8 @@ public class BitcoinSerializer {
             return new NotFoundMessage(params, payloadBytes);
         } else if (command.equals("mempool")) {
             return new MemoryPoolMessage();
+        } else if (command.equals("checkpoint")) {//Peercoin
+            return new CheckpointMessage(params, payloadBytes);
         } else if (command.equals("reject")) {
             return new RejectMessage(params, payloadBytes);
         } else {
diff --git a/core/src/main/java/com/google/bitcoin/core/Block.java b/core/src/main/java/com/google/bitcoin/core/Block.java
index 2b3db5f..1be2c17 100644
--- a/core/src/main/java/com/google/bitcoin/core/Block.java
+++ b/core/src/main/java/com/google/bitcoin/core/Block.java
@@ -53,6 +53,7 @@ public class Block extends Message {
     private static final long serialVersionUID = 2738848929966035281L;
 
     /** How many bytes are required to represent a block header WITHOUT the trailing 00 length byte. */
+    public static final int BLOCK_SIG_SIZE = 70;
     public static final int HEADER_SIZE = 80;
 
     static final long ALLOWED_TIME_DRIFT = 2 * 60 * 60; // Same value as official client.
@@ -84,6 +85,8 @@ public class Block extends Message {
     /** If null, it means this object holds only the headers. */
     List<Transaction> transactions;
 
+    private byte[] blockSig;//Peercoin
+
     /** Stores the hash of the block. If null, getHash() will recalculate it. */
     private transient Sha256Hash hash;
 
@@ -219,6 +222,7 @@ public class Block extends Message {
             cursor += tx.getMessageSize();
             optimalEncodingMessageSize += tx.getOptimalEncodingMessageSize();
         }
+        //TODO blockSig = readByteArray();//Peercoin
         // No need to set length here. If length was not provided then it should be set at the end of parseLight().
         // If this is a genuine lazy parse then length must have been provided to the constructor.
         transactionsParsed = true;
@@ -964,7 +968,7 @@ public class Block extends Message {
         // counter in the scriptSig so every transaction has a different hash.
         coinbase.addInput(new TransactionInput(params, coinbase, new byte[]{(byte) txCounter, (byte) (txCounter++ >> 8)}));
         coinbase.addOutput(new TransactionOutput(params, coinbase, value,
-                ScriptBuilder.createOutputScript(new ECKey(null, pubKeyTo)).getProgram()));
+                ScriptBuilder.createOutputScript(ECKey.fromPublicOnly(pubKeyTo)).getProgram()));
         transactions.add(coinbase);
         coinbase.setParent(this);
         coinbase.length = coinbase.bitcoinSerialize().length;
@@ -973,12 +977,15 @@ public class Block extends Message {
 
     static final byte[] EMPTY_BYTES = new byte[32];
 
+    // It's pretty weak to have this around at runtime: fix later.
+    private static final byte[] pubkeyForTesting = new ECKey().getPubKey();
+
     /**
      * Returns a solved block that builds on top of this one. This exists for unit tests.
      */
     @VisibleForTesting
     public Block createNextBlock(Address to, long time) {
-        return createNextBlock(to, null, time, EMPTY_BYTES, Utils.toNanoCoins(50, 0));
+        return createNextBlock(to, null, time, pubkeyForTesting, Utils.toNanoCoins(50, 0));
     }
 
     /**
@@ -1029,12 +1036,12 @@ public class Block extends Message {
 
     @VisibleForTesting
     public Block createNextBlock(@Nullable Address to, TransactionOutPoint prevOut) {
-        return createNextBlock(to, prevOut, Utils.currentTimeSeconds(), EMPTY_BYTES, Utils.toNanoCoins(50, 0));
+        return createNextBlock(to, prevOut, Utils.currentTimeSeconds(), pubkeyForTesting, Utils.toNanoCoins(50, 0));
     }
 
     @VisibleForTesting
     public Block createNextBlock(@Nullable Address to, BigInteger value) {
-        return createNextBlock(to, null, Utils.currentTimeSeconds(), EMPTY_BYTES, value);
+        return createNextBlock(to, null, Utils.currentTimeSeconds(), pubkeyForTesting, value);
     }
 
     @VisibleForTesting
diff --git a/core/src/main/java/com/google/bitcoin/core/CheckpointMessage.java b/core/src/main/java/com/google/bitcoin/core/CheckpointMessage.java
new file mode 100644
index 0000000..ce44581
--- /dev/null
+++ b/core/src/main/java/com/google/bitcoin/core/CheckpointMessage.java
@@ -0,0 +1,18 @@
+package com.google.bitcoin.core;
+
+public class CheckpointMessage extends Message {
+	public CheckpointMessage(NetworkParameters params, byte[] msg) throws ProtocolException {
+		super(params, msg, 0);
+	}
+	@Override
+	void parse() throws ProtocolException {
+		length = bytes.length;
+	}
+
+	@Override
+	protected void parseLite() throws ProtocolException {
+		// TODO Auto-generated method stub
+
+	}
+
+}
diff --git a/core/src/main/java/com/google/bitcoin/core/DumpedPrivateKey.java b/core/src/main/java/com/google/bitcoin/core/DumpedPrivateKey.java
index 047a1c9..6d57347 100644
--- a/core/src/main/java/com/google/bitcoin/core/DumpedPrivateKey.java
+++ b/core/src/main/java/com/google/bitcoin/core/DumpedPrivateKey.java
@@ -19,7 +19,6 @@ package com.google.bitcoin.core;
 import com.google.common.base.Objects;
 import com.google.common.base.Preconditions;
 
-import java.math.BigInteger;
 import java.util.Arrays;
 
 /**
@@ -75,7 +74,8 @@ public class DumpedPrivateKey extends VersionedChecksummedBytes {
      * Returns an ECKey created from this encoded private key.
      */
     public ECKey getKey() {
-        return new ECKey(new BigInteger(1, bytes), null, compressed);
+        final ECKey key = ECKey.fromPrivate(bytes);
+        return compressed ? key : key.decompress();
     }
 
     @Override
diff --git a/core/src/main/java/com/google/bitcoin/core/ECKey.java b/core/src/main/java/com/google/bitcoin/core/ECKey.java
index f8d837d..36e20bf 100644
--- a/core/src/main/java/com/google/bitcoin/core/ECKey.java
+++ b/core/src/main/java/com/google/bitcoin/core/ECKey.java
@@ -16,13 +16,11 @@
 
 package com.google.bitcoin.core;
 
-import com.google.bitcoin.crypto.EncryptedPrivateKey;
-import com.google.bitcoin.crypto.KeyCrypter;
-import com.google.bitcoin.crypto.KeyCrypterException;
-import com.google.bitcoin.crypto.TransactionSignature;
+import com.google.bitcoin.crypto.*;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
 import org.bitcoin.NativeSecp256k1;
+import org.bitcoinj.wallet.Protos;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.spongycastle.asn1.*;
@@ -51,26 +49,41 @@ import java.security.SignatureException;
 import java.util.Arrays;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 
-// TODO: This class is quite a mess by now. Once users are migrated away from Java serialization for the wallets,
-// refactor this to have better internal layout and a more consistent API.
+// TODO: Move this class to tracking compression state itself.
+// The Bouncy Castle guys are deprecating their own tracking of the compression state.
 
 /**
  * <p>Represents an elliptic curve public and (optionally) private key, usable for digital signatures but not encryption.
- * Creating a new ECKey with the empty constructor will generate a new random keypair. Other constructors can be used
+ * Creating a new ECKey with the empty constructor will generate a new random keypair. Other static methods can be used
  * when you already have the public or private parts. If you create a key with only the public part, you can check
  * signatures but not create them.</p>
  *
- * <p>ECKey also provides access to Bitcoin-Qt compatible text message signing, as accessible via the UI or JSON-RPC.
+ * <p>ECKey also provides access to Bitcoin Core compatible text message signing, as accessible via the UI or JSON-RPC.
  * This is slightly different to signing raw bytes - if you want to sign your own data and it won't be exposed as
  * text to people, you don't want to use this. If in doubt, ask on the mailing list.</p>
  *
  * <p>The ECDSA algorithm supports <i>key recovery</i> in which a signature plus a couple of discriminator bits can
  * be reversed to find the public key used to calculate it. This can be convenient when you have a message and a
  * signature and want to find out who signed it, rather than requiring the user to provide the expected identity.</p>
+ *
+ * <p>This class supports a variety of serialization forms. The methods that accept/return byte arrays serialize
+ * private keys as raw byte arrays and public keys using the SEC standard byte encoding for public keys. Signatures
+ * are encoded using ASN.1/DER inside the Bitcoin protocol.</p>
+ *
+ * <p>A key can be <i>compressed</i> or <i>uncompressed</i>. This refers to whether the public key is represented
+ * when encoded into bytes as an (x, y) coordinate on the elliptic curve, or whether it's represented as just an X
+ * co-ordinate and an extra byte that carries a sign bit. With the latter form the Y coordinate can be calculated
+ * dynamically, however, <b>because the binary serialization is different the address of a key changes if its
+ * compression status is changed</b>. If you deviate from the defaults it's important to understand this: money sent
+ * to a compressed version of the key will have a different address to the same key in uncompressed form. Whether
+ * a public key is compressed or not is recorded in the SEC binary serialisation format, and preserved in a flag in
+ * this class so round-tripping preserves state. Unless you're working with old software or doing unusual things, you
+ * can usually ignore the compressed/uncompressed distinction.</p>
  */
-public class ECKey implements Serializable {
+public class ECKey implements EncryptableItem, Serializable {
     private static final Logger log = LoggerFactory.getLogger(ECKey.class);
 
     /** The parameters of the secp256k1 curve that Bitcoin uses. */
@@ -95,31 +108,32 @@ public class ECKey implements Serializable {
 
     // The two parts of the key. If "priv" is set, "pub" can always be calculated. If "pub" is set but not "priv", we
     // can only verify signatures not make them.
-    // TODO: Redesign this class to use consistent internals and more efficient serialization.
-    private BigInteger priv;
-    private byte[] pub;
+    protected final BigInteger priv;  // A field element.
+    protected final ECPoint pub;
+
     // Creation time of the key in seconds since the epoch, or zero if the key was deserialized from a version that did
     // not have this field.
-    private long creationTimeSeconds;
-
-    /**
-     * Instance of the KeyCrypter interface to use for encrypting and decrypting the key.
-     */
-    transient private KeyCrypter keyCrypter;
+    protected long creationTimeSeconds;
 
-    /**
-     * The encrypted private key information.
-     */
-    private EncryptedPrivateKey encryptedPrivateKey;
+    protected KeyCrypter keyCrypter;
+    protected EncryptedData encryptedPrivateKey;
 
-    // Transient because it's calculated on demand.
-    transient private byte[] pubKeyHash;
+    // Transient because it's calculated on demand/cached.
+    private transient byte[] pubKeyHash;
 
     /**
      * Generates an entirely new keypair. Point compression is used so the resulting public key will be 33 bytes
      * (32 for the co-ordinate and 1 byte to represent the y bit).
      */
     public ECKey() {
+        this(secureRandom);
+    }
+
+    /**
+     * Generates an entirely new keypair with the given {@link SecureRandom} object. Point compression is used so the
+     * resulting public key will be 33 bytes (32 for the co-ordinate and 1 byte to represent the y bit).
+     */
+    public ECKey(SecureRandom secureRandom) {
         ECKeyPairGenerator generator = new ECKeyPairGenerator();
         ECKeyGenerationParameters keygenParams = new ECKeyGenerationParameters(CURVE, secureRandom);
         generator.init(keygenParams);
@@ -127,11 +141,31 @@ public class ECKey implements Serializable {
         ECPrivateKeyParameters privParams = (ECPrivateKeyParameters) keypair.getPrivate();
         ECPublicKeyParameters pubParams = (ECPublicKeyParameters) keypair.getPublic();
         priv = privParams.getD();
-        pub = pubParams.getQ().getEncoded(true);
-
+        pub = CURVE.getCurve().decodePoint(pubParams.getQ().getEncoded(true));
         creationTimeSeconds = Utils.currentTimeSeconds();
     }
 
+    protected ECKey(@Nullable BigInteger priv, ECPoint pub) {
+        this.priv = priv;
+        this.pub = checkNotNull(pub);
+    }
+
+    /**
+     * Utility for compressing an elliptic curve point. Returns the same point if it's already compressed.
+     * See the ECKey class docs for a discussion of point compression.
+     */
+    public static ECPoint compressPoint(ECPoint uncompressed) {
+        return CURVE.getCurve().decodePoint(uncompressed.getEncoded(true));
+    }
+
+    /**
+     * Utility for decompressing an elliptic curve point. Returns the same point if it's already compressed.
+     * See the ECKey class docs for a discussion of point compression.
+     */
+    public static ECPoint decompressPoint(ECPoint compressed) {
+        return CURVE.getCurve().decodePoint(compressed.getEncoded(false));
+    }
+
     /**
      * Construct an ECKey from an ASN.1 encoded private key. These are produced by OpenSSL and stored by the Bitcoin
      * reference implementation in its wallet. Note that this is slow because it requires an EC point multiply.
@@ -140,14 +174,67 @@ public class ECKey implements Serializable {
         return extractKeyFromASN1(asn1privkey);
     }
 
-    /** Creates an ECKey given the private key only.  The public key is calculated from it (this is slow) */
-    public ECKey(BigInteger privKey) {
-        this(privKey, (byte[])null);
+    /**
+     * Creates an ECKey given the private key only.  The public key is calculated from it (this is slow). Note that
+     * the resulting public key is compressed.
+     */
+    public static ECKey fromPrivate(BigInteger privKey) {
+        return new ECKey(privKey, compressPoint(CURVE.getG().multiply(privKey)));
+    }
+
+    /**
+     * Creates an ECKey given the private key only.  The public key is calculated from it (this is slow). The resulting
+     * public key is compressed.
+     */
+    public static ECKey fromPrivate(byte[] privKeyBytes) {
+        return fromPrivate(new BigInteger(1, privKeyBytes));
+    }
+
+    /**
+     * Creates an ECKey that simply trusts the caller to ensure that point is really the result of multiplying the
+     * generator point by the private key. This is used to speed things up when you know you have the right values
+     * already. The compression state of pub will be preserved.
+     */
+    public static ECKey fromPrivateAndPrecalculatedPublic(BigInteger priv, ECPoint pub) {
+        return new ECKey(priv, pub);
+    }
+
+    /**
+     * Creates an ECKey that simply trusts the caller to ensure that point is really the result of multiplying the
+     * generator point by the private key. This is used to speed things up when you know you have the right values
+     * already. The compression state of the point will be preserved.
+     */
+    public static ECKey fromPrivateAndPrecalculatedPublic(byte[] priv, byte[] pub) {
+        checkNotNull(priv);
+        checkNotNull(pub);
+        return new ECKey(new BigInteger(1, priv), CURVE.getCurve().decodePoint(pub));
+    }
+
+    /**
+     * Creates an ECKey that cannot be used for signing, only verifying signatures, from the given point. The
+     * compression state of pub will be preserved.
+     */
+    public static ECKey fromPublicOnly(ECPoint pub) {
+        return new ECKey(null, pub);
+    }
+
+    /**
+     * Creates an ECKey that cannot be used for signing, only verifying signatures, from the given encoded point.
+     * The compression state of pub will be preserved.
+     */
+    public static ECKey fromPublicOnly(byte[] pub) {
+        return new ECKey(null, CURVE.getCurve().decodePoint(pub));
     }
 
-    /** A constructor variant with BigInteger pubkey. See {@link ECKey#ECKey(BigInteger, byte[])}. */
-    public ECKey(BigInteger privKey, BigInteger pubKey) {
-        this(privKey, Utils.bigIntegerToBytes(pubKey, 65));
+    /**
+     * Returns a copy of this key, but with the public point represented in uncompressed form. Normally you would
+     * never need this: it's for specialised scenarios or when backwards compatibility in encoded form is necessary.
+     */
+    public ECKey decompress() {
+        if (!pub.isCompressed())
+            return this;
+        else
+            return new ECKey(priv, decompressPoint(pub));
     }
 
     /**
@@ -155,6 +242,7 @@ public class ECKey implements Serializable {
      * is more convenient if you are importing a key from elsewhere. The public key will be automatically derived
      * from the private key.
      */
+    @Deprecated
     public ECKey(@Nullable byte[] privKeyBytes, @Nullable byte[] pubKey) {
         this(privKeyBytes == null ? null : new BigInteger(1, privKeyBytes), pubKey);
     }
@@ -166,33 +254,49 @@ public class ECKey implements Serializable {
      * @param pubKey The keys public key
      * @param keyCrypter The KeyCrypter that will be used, with an AES key, to encrypt and decrypt the private key
      */
-    public ECKey(@Nullable EncryptedPrivateKey encryptedPrivateKey, @Nullable byte[] pubKey, KeyCrypter keyCrypter) {
+    @Deprecated
+    public ECKey(EncryptedData encryptedPrivateKey, byte[] pubKey, KeyCrypter keyCrypter) {
         this((byte[])null, pubKey);
 
-        this.keyCrypter = Preconditions.checkNotNull(keyCrypter);
+        this.keyCrypter = checkNotNull(keyCrypter);
         this.encryptedPrivateKey = encryptedPrivateKey;
     }
 
     /**
-     * Creates an ECKey given either the private key only, the public key only, or both. If only the private key 
+     * Constructs a key that has an encrypted private component. The given object wraps encrypted bytes and an
+     * initialization vector. Note that the key will not be decrypted during this call: the returned ECKey is
+     * unusable for signing unless a decryption key is supplied.
+     */
+    public static ECKey fromEncrypted(EncryptedData encryptedPrivateKey, KeyCrypter crypter, byte[] pubKey) {
+        ECKey key = fromPublicOnly(pubKey);
+        key.encryptedPrivateKey = checkNotNull(encryptedPrivateKey);
+        key.keyCrypter = checkNotNull(crypter);
+        return key;
+    }
+
+    /**
+     * Creates an ECKey given either the private key only, the public key only, or both. If only the private key
      * is supplied, the public key will be calculated from it (this is slow). If both are supplied, it's assumed
      * the public key already correctly matches the public key. If only the public key is supplied, this ECKey cannot
      * be used for signing.
      * @param compressed If set to true and pubKey is null, the derived public key will be in compressed form.
      */
+    @Deprecated
     public ECKey(@Nullable BigInteger privKey, @Nullable byte[] pubKey, boolean compressed) {
         if (privKey == null && pubKey == null)
             throw new IllegalArgumentException("ECKey requires at least private or public key");
         this.priv = privKey;
-        this.pub = null;
         if (pubKey == null) {
             // Derive public from private.
-            this.pub = publicKeyFromPrivate(privKey, compressed);
+            ECPoint point = CURVE.getG().multiply(privKey);
+            if (compressed)
+                point = compressPoint(point);
+            this.pub = point;
         } else {
             // We expect the pubkey to be in regular encoded form, just as a BigInteger. Therefore the first byte is
             // a special marker byte.
             // TODO: This is probably not a useful API and may be confusing.
-            this.pub = pubKey;
+            this.pub = CURVE.getCurve().decodePoint(pubKey);
         }
     }
 
@@ -202,24 +306,36 @@ public class ECKey implements Serializable {
      * the public key already correctly matches the public key. If only the public key is supplied, this ECKey cannot
      * be used for signing.
      */
+    @Deprecated
     private ECKey(@Nullable BigInteger privKey, @Nullable byte[] pubKey) {
         this(privKey, pubKey, false);
     }
 
+    /**
+     * Returns true if this key doesn't have unencrypted access to private key bytes. This may be because it was never
+     * given any private key bytes to begin with (a watching key), or because the key is encrypted. You can use
+     * {@link #isEncrypted()} to tell the cases apart.
+     */
     public boolean isPubKeyOnly() {
         return priv == null;
     }
 
+    /**
+     * Returns true if this key has unencrypted access to private key bytes. Does the opposite of
+     * {@link #isPubKeyOnly()}.
+     */
     public boolean hasPrivKey() {
         return priv != null;
     }
 
     /**
-     * Output this ECKey as an ASN.1 encoded private key, as understood by OpenSSL or used by the BitCoin reference
+     * Output this ECKey as an ASN.1 encoded private key, as understood by OpenSSL or used by the Bitcoin reference
      * implementation in its wallet storage format.
+     * @throws com.google.bitcoin.core.ECKey.MissingPrivateKeyException if the private key is missing or encrypted.
      */
     public byte[] toASN1() {
         try {
+            byte[] privKeyBytes = getPrivKeyBytes();
             ByteArrayOutputStream baos = new ByteArrayOutputStream(400);
 
             // ASN1_SEQUENCE(EC_PRIVATEKEY) = {
@@ -230,7 +346,7 @@ public class ECKey implements Serializable {
             // } ASN1_SEQUENCE_END(EC_PRIVATEKEY)
             DERSequenceGenerator seq = new DERSequenceGenerator(baos);
             seq.addObject(new ASN1Integer(1)); // version
-            seq.addObject(new DEROctetString(priv.toByteArray()));
+            seq.addObject(new DEROctetString(privKeyBytes));
             seq.addObject(new DERTaggedObject(0, SECNamedCurves.getByName("secp256k1").toASN1Primitive()));
             seq.addObject(new DERTaggedObject(1, new DERBitString(getPubKey())));
             seq.close();
@@ -252,7 +368,7 @@ public class ECKey implements Serializable {
     /** Gets the hash160 form of the public key (as seen in addresses). */
     public byte[] getPubKeyHash() {
         if (pubKeyHash == null)
-            pubKeyHash = Utils.sha256hash160(this.pub);
+            pubKeyHash = Utils.sha256hash160(this.pub.getEncoded());
         return pubKeyHash;
     }
 
@@ -261,19 +377,36 @@ public class ECKey implements Serializable {
      * as the pubKeyHash/address.
      */
     public byte[] getPubKey() {
+        return pub.getEncoded();
+    }
+
+    /** Gets the public key in the form of an elliptic curve point object from Bouncy Castle. */
+    public ECPoint getPubKeyPoint() {
         return pub;
     }
 
     /**
+     * Gets the private key in the form of an integer field element. The public key is derived by performing EC
+     * point addition this number of times (i.e. point multiplying).
+     *
+     * @throws java.lang.IllegalStateException if the private key bytes are not available.
+     */
+    public BigInteger getPrivKey() {
+        if (priv == null)
+            throw new MissingPrivateKeyException();
+        return priv;
+    }
+
+    /**
      * Returns whether this key is using the compressed form or not. Compressed pubkeys are only 33 bytes, not 64.
      */
     public boolean isCompressed() {
-        return pub.length == 33;
+        return pub.isCompressed();
     }
 
     public String toString() {
         StringBuilder b = new StringBuilder();
-        b.append("pub:").append(Utils.bytesToHexString(pub));
+        b.append("pub:").append(Utils.bytesToHexString(pub.getEncoded()));
         if (creationTimeSeconds != 0) {
             b.append(" timestamp:").append(creationTimeSeconds);
         }
@@ -301,21 +434,7 @@ public class ECKey implements Serializable {
      * the RIPEMD-160 hash of the public key and is not the public key itself (which is too large to be convenient).
      */
     public Address toAddress(NetworkParameters params) {
-        byte[] hash160 = Utils.sha256hash160(pub);
-        return new Address(params, hash160);
-    }
-
-    /**
-     * Clears all the ECKey private key contents from memory.
-     * WARNING - this method irreversibly deletes the private key information.
-     * It turns the ECKEy into a watch only key.
-     */
-    public void clearPrivateKey() {
-       priv = BigInteger.ZERO;
-
-       if (encryptedPrivateKey != null) {
-           encryptedPrivateKey.clear();
-       }
+        return new Address(params, getPubKeyHash());
     }
 
     /**
@@ -421,8 +540,8 @@ public class ECKey implements Serializable {
 
     /**
      * Signs the given hash and returns the R and S components as BigIntegers. In the Bitcoin protocol, they are
-     * usually encoded using DER format, so you want {@link com.google.bitcoin.core.ECKey.ECDSASignature#toASN1()}
-     * instead. However sometimes the independent components can be useful, for instance, if you're doing to do
+     * usually encoded using ASN.1 format, so you want {@link com.google.bitcoin.core.ECKey.ECDSASignature#toASN1()}
+     * instead. However sometimes the independent components can be useful, for instance, if you're going to do
      * further EC maths on them.
      * @throws KeyCrypterException if this ECKey doesn't have a private part.
      */
@@ -448,35 +567,23 @@ public class ECKey implements Serializable {
      * @throws KeyCrypterException if this ECKey doesn't have a private part.
      */
     public ECDSASignature sign(Sha256Hash input, @Nullable KeyParameter aesKey) throws KeyCrypterException {
-        if (FAKE_SIGNATURES)
-            return TransactionSignature.dummy();
-
-        // The private key bytes to use for signing.
-        BigInteger privateKeyForSigning;
-
-        if (isEncrypted()) {
-            // The private key needs decrypting before use.
-            if (aesKey == null) {
-                throw new KeyCrypterException("This ECKey is encrypted but no decryption key has been supplied.");
-            }
-
-            if (keyCrypter == null) {
-                throw new KeyCrypterException("There is no KeyCrypter to decrypt the private key for signing.");
-            }
-
-            privateKeyForSigning = new BigInteger(1, keyCrypter.decrypt(encryptedPrivateKey, aesKey));
-            // Check encryption was correct.
-            if (!Arrays.equals(pub, publicKeyFromPrivate(privateKeyForSigning, isCompressed())))
-                throw new KeyCrypterException("Could not decrypt bytes");
+        KeyCrypter crypter = getKeyCrypter();
+        if (crypter != null) {
+            if (aesKey == null)
+                throw new KeyIsEncryptedException();
+            return decrypt(crypter, aesKey).sign(input);
         } else {
             // No decryption of private key required.
-            if (priv == null) {
-                throw new KeyCrypterException("This ECKey does not have the private key necessary for signing.");
-            } else {
-                privateKeyForSigning = priv;
-            }
+            if (priv == null)
+                throw new MissingPrivateKeyException();
         }
+        return doSign(input, priv);
+    }
 
+    protected ECDSASignature doSign(Sha256Hash input, BigInteger privateKeyForSigning) {
+        if (FAKE_SIGNATURES)
+            return TransactionSignature.dummy();
+        checkNotNull(privateKeyForSigning);
         ECDSASigner signer = new ECDSASigner(new HMacDSAKCalculator(new SHA256Digest()));
         ECPrivateKeyParameters privKey = new ECPrivateKeyParameters(privateKeyForSigning, CURVE);
         signer.init(true, privKey);
@@ -546,13 +653,6 @@ public class ECKey implements Serializable {
     }
 
     /**
-     * Returns true if this pubkey is canonical, i.e. the correct length taking into account compression.
-     */
-    public boolean isPubKeyCanonical() {
-        return isPubKeyCanonical(pub);
-    }
-
-    /**
      * Returns true if the given pubkey is canonical, i.e. the correct length taking into account compression.
      */
     public static boolean isPubKeyCanonical(byte[] pubkey) {
@@ -626,7 +726,7 @@ public class ECKey implements Serializable {
      */
     public String signMessage(String message, @Nullable KeyParameter aesKey) throws KeyCrypterException {
         if (priv == null)
-            throw new IllegalStateException("This ECKey does not have the private key necessary for signing.");
+            throw new MissingPrivateKeyException();
         byte[] data = Utils.formatMessageForSigning(message);
         Sha256Hash hash = Sha256Hash.createDouble(data);
         ECDSASignature sig = sign(hash, aesKey);
@@ -634,7 +734,7 @@ public class ECKey implements Serializable {
         int recId = -1;
         for (int i = 0; i < 4; i++) {
             ECKey k = ECKey.recoverFromSignature(i, sig, hash, isCompressed());
-            if (k != null && Arrays.equals(k.pub, pub)) {
+            if (k != null && k.pub.equals(pub)) {
                 recId = i;
                 break;
             }
@@ -701,7 +801,7 @@ public class ECKey implements Serializable {
      */
     public void verifyMessage(String message, String signatureBase64) throws SignatureException {
         ECKey key = ECKey.signedMessageToKey(message, signatureBase64);
-        if (!Arrays.equals(key.getPubKey(), pub))
+        if (!key.pub.equals(pub))
             throw new SignatureException("Signature did not match for message");
     }
 
@@ -773,7 +873,7 @@ public class ECKey implements Serializable {
         BigInteger srInv = rInv.multiply(sig.s).mod(n);
         BigInteger eInvrInv = rInv.multiply(eInv).mod(n);
         ECPoint.Fp q = (ECPoint.Fp) ECAlgorithms.sumOfTwoMultiplies(CURVE.getG(), eInvrInv, R, srInv);
-        return new ECKey((byte[])null, q.getEncoded(compressed));
+        return ECKey.fromPublicOnly(q.getEncoded(true));
     }
 
     /** Decompress a compressed public key (x co-ord and low-bit of y-coord). */
@@ -785,11 +885,11 @@ public class ECKey implements Serializable {
     }
 
     /**
-     * Returns a 32 byte array containing the private key, or null if the key is encrypted or public only
+     * Returns a 32 byte array containing the private key.
+     * @throws com.google.bitcoin.core.ECKey.MissingPrivateKeyException if the private key bytes are missing/encrypted.
      */
-    @Nullable
     public byte[] getPrivKeyBytes() {
-        return Utils.bigIntegerToBytes(priv, 32);
+        return Utils.bigIntegerToBytes(getPrivKey(), 32);
     }
 
     /**
@@ -801,15 +901,14 @@ public class ECKey implements Serializable {
      * @throws IllegalStateException if the private key is not available.
      */
     public DumpedPrivateKey getPrivateKeyEncoded(NetworkParameters params) {
-        final byte[] privKeyBytes = getPrivKeyBytes();
-        checkState(privKeyBytes != null, "Private key is not available");
-        return new DumpedPrivateKey(params, privKeyBytes, isCompressed());
+        return new DumpedPrivateKey(params, getPrivKeyBytes(), isCompressed());
     }
 
     /**
      * Returns the creation time of this key or zero if the key was deserialized from a version that did not store
      * that data.
      */
+    @Override
     public long getCreationTimeSeconds() {
         return creationTimeSeconds;
     }
@@ -827,35 +926,39 @@ public class ECKey implements Serializable {
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
+        if (o == null || !(o instanceof ECKey)) return false;
 
         ECKey ecKey = (ECKey) o;
 
-        return Arrays.equals(pub, ecKey.pub);
+        if (creationTimeSeconds != ecKey.creationTimeSeconds) return false;
+        if (keyCrypter != null ? !keyCrypter.equals(ecKey.keyCrypter) : ecKey.keyCrypter != null) return false;
+        if (priv != null && !priv.equals(ecKey.priv)) return false;
+        if (pub != null && !pub.equals(ecKey.pub)) return false;
+
+        return true;
     }
 
     @Override
     public int hashCode() {
         // Public keys are random already so we can just use a part of them as the hashcode. Read from the start to
         // avoid picking up the type code (compressed vs uncompressed) which is tacked on the end.
-        return (pub[0] & 0xFF) | ((pub[1] & 0xFF) << 8) | ((pub[2] & 0xFF) << 16) | ((pub[3] & 0xFF) << 24);
+        byte[] bits = getPubKey();
+        return (bits[0] & 0xFF) | ((bits[1] & 0xFF) << 8) | ((bits[2] & 0xFF) << 16) | ((bits[3] & 0xFF) << 24);
     }
 
     /**
      * Create an encrypted private key with the keyCrypter and the AES key supplied.
      * This method returns a new encrypted key and leaves the original unchanged.
-     * To be secure you need to clear the original, unencrypted private key bytes.
      *
      * @param keyCrypter The keyCrypter that specifies exactly how the encrypted bytes are created.
      * @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached as it is slow to create).
      * @return encryptedKey
      */
     public ECKey encrypt(KeyCrypter keyCrypter, KeyParameter aesKey) throws KeyCrypterException {
-        Preconditions.checkNotNull(keyCrypter);
+        checkNotNull(keyCrypter);
         final byte[] privKeyBytes = getPrivKeyBytes();
-        checkState(privKeyBytes != null, "Private key is not available");
-        EncryptedPrivateKey encryptedPrivateKey = keyCrypter.encrypt(privKeyBytes, aesKey);
-        ECKey result = new ECKey(encryptedPrivateKey, getPubKey(), keyCrypter);
+        EncryptedData encryptedPrivateKey = keyCrypter.encrypt(privKeyBytes, aesKey);
+        ECKey result = ECKey.fromEncrypted(encryptedPrivateKey, keyCrypter, getPubKey());
         result.setCreationTimeSeconds(creationTimeSeconds);
         return result;
     }
@@ -870,13 +973,15 @@ public class ECKey implements Serializable {
      * @return unencryptedKey
      */
     public ECKey decrypt(KeyCrypter keyCrypter, KeyParameter aesKey) throws KeyCrypterException {
-        Preconditions.checkNotNull(keyCrypter);
+        checkNotNull(keyCrypter);
         // Check that the keyCrypter matches the one used to encrypt the keys, if set.
-        if (this.keyCrypter != null && !this.keyCrypter.equals(keyCrypter)) {
+        if (this.keyCrypter != null && !this.keyCrypter.equals(keyCrypter))
             throw new KeyCrypterException("The keyCrypter being used to decrypt the key is different to the one that was used to encrypt it");
-        }
+        checkState(encryptedPrivateKey != null, "This key is not encrypted");
         byte[] unencryptedPrivateKey = keyCrypter.decrypt(encryptedPrivateKey, aesKey);
-        ECKey key = new ECKey(new BigInteger(1, unencryptedPrivateKey), null, isCompressed());
+        ECKey key = ECKey.fromPrivate(unencryptedPrivateKey);
+        if (!isCompressed())
+            key = key.decompress();
         if (!Arrays.equals(key.getPubKey(), getPubKey()))
             throw new KeyCrypterException("Provided AES key is wrong");
         key.setCreationTimeSeconds(creationTimeSeconds);
@@ -884,49 +989,30 @@ public class ECKey implements Serializable {
     }
 
     /**
-     * Check that it is possible to decrypt the key with the keyCrypter and that the original key is returned.
+     * <p>Check that it is possible to decrypt the key with the keyCrypter and that the original key is returned.</p>
+     *
+     * <p>Because it is a critical failure if the private keys cannot be decrypted successfully (resulting of loss of all
+     * bitcoins controlled by the private key) you can use this method to check when you *encrypt* a wallet that
+     * it can definitely be decrypted successfully.</p>
      *
-     * Because it is a critical failure if the private keys cannot be decrypted successfully (resulting of loss of all bitcoins controlled
-     * by the private key) you can use this method to check when you *encrypt* a wallet that it can definitely be decrypted successfully.
-     * See {@link Wallet#encrypt(KeyCrypter keyCrypter, KeyParameter aesKey)} for example usage.
+     * <p>See {@link Wallet#encrypt(KeyCrypter keyCrypter, KeyParameter aesKey)} for example usage.</p>
      *
      * @return true if the encrypted key can be decrypted back to the original key successfully.
      */
     public static boolean encryptionIsReversible(ECKey originalKey, ECKey encryptedKey, KeyCrypter keyCrypter, KeyParameter aesKey) {
-        String genericErrorText = "The check that encryption could be reversed failed for key " + originalKey.toString() + ". ";
         try {
             ECKey rebornUnencryptedKey = encryptedKey.decrypt(keyCrypter, aesKey);
-            if (rebornUnencryptedKey == null) {
-                log.error(genericErrorText + "The test decrypted key was missing.");
-                return false;
-            }
-
             byte[] originalPrivateKeyBytes = originalKey.getPrivKeyBytes();
-            if (originalPrivateKeyBytes != null) {
-                if (rebornUnencryptedKey.getPrivKeyBytes() == null) {
-                    log.error(genericErrorText + "The test decrypted key was missing.");
-                    return false;
-                } else {
-                    if (originalPrivateKeyBytes.length != rebornUnencryptedKey.getPrivKeyBytes().length) {
-                        log.error(genericErrorText + "The test decrypted private key was a different length to the original.");
-                        return false;
-                    } else {
-                        for (int i = 0; i < originalPrivateKeyBytes.length; i++) {
-                            if (originalPrivateKeyBytes[i] != rebornUnencryptedKey.getPrivKeyBytes()[i]) {
-                                log.error(genericErrorText + "Byte " + i + " of the private key did not match the original.");
-                                return false;
-                            }
-                        }
-                    }
-                }
+            byte[] rebornKeyBytes = rebornUnencryptedKey.getPrivKeyBytes();
+            if (!Arrays.equals(originalPrivateKeyBytes, rebornKeyBytes)) {
+                log.error("The check that encryption could be reversed failed for {}", originalKey);
+                return false;
             }
+            return true;
         } catch (KeyCrypterException kce) {
             log.error(kce.getMessage());
             return false;
         }
-
-        // Key can successfully be decrypted.
-        return true;
     }
 
     /**
@@ -934,26 +1020,55 @@ public class ECKey implements Serializable {
      * A private key is deemed to be encrypted when there is both a KeyCrypter and the encryptedPrivateKey is non-zero.
      */
     public boolean isEncrypted() {
-         return keyCrypter != null && encryptedPrivateKey != null && encryptedPrivateKey.getEncryptedBytes() != null &&  encryptedPrivateKey.getEncryptedBytes().length > 0;
+        return keyCrypter != null && encryptedPrivateKey != null && encryptedPrivateKey.encryptedBytes.length > 0;
+    }
+
+    @Nullable
+    @Override
+    public Protos.Wallet.EncryptionType getEncryptionType() {
+        return keyCrypter != null ? keyCrypter.getUnderstoodEncryptionType() : Protos.Wallet.EncryptionType.UNENCRYPTED;
     }
 
     /**
-     * @return The encryptedPrivateKey (containing the encrypted private key bytes and initialisation vector) for this ECKey,
-     *         or null if the ECKey is not encrypted.
+     * A wrapper for {@link #getPrivKeyBytes()} that returns null if the private key bytes are missing or would have
+     * to be derived (for the HD key case).
      */
+    @Override
     @Nullable
-    public EncryptedPrivateKey getEncryptedPrivateKey() {
-        if (encryptedPrivateKey == null) {
+    public byte[] getSecretBytes() {
+        if (hasPrivKey())
+            return getPrivKeyBytes();
+        else
             return null;
-        } else {
-            return encryptedPrivateKey.clone();
-        }
+    }
+
+    /** An alias for {@link #getEncryptedPrivateKey()} */
+    @Nullable
+    @Override
+    public EncryptedData getEncryptedData() {
+        return getEncryptedPrivateKey();
     }
 
     /**
-     * @return The KeyCrypter that was used to encrypt to encrypt this ECKey. You need this to decrypt the ECKey.
+     * Returns the the encrypted private key bytes and initialisation vector for this ECKey, or null if the ECKey
+     * is not encrypted.
      */
+    @Nullable
+    public EncryptedData getEncryptedPrivateKey() {
+        return encryptedPrivateKey;
+    }
+
+    /**
+     * Returns the KeyCrypter that was used to encrypt to encrypt this ECKey. You need this to decrypt the ECKey.
+     */
+    @Nullable
     public KeyCrypter getKeyCrypter() {
         return keyCrypter;
     }
+
+    public static class MissingPrivateKeyException extends RuntimeException {
+    }
+
+    public static class KeyIsEncryptedException extends MissingPrivateKeyException {
+    }
 }
diff --git a/core/src/main/java/com/google/bitcoin/core/FilteredBlock.java b/core/src/main/java/com/google/bitcoin/core/FilteredBlock.java
index 55d7bfd..23c9859 100644
--- a/core/src/main/java/com/google/bitcoin/core/FilteredBlock.java
+++ b/core/src/main/java/com/google/bitcoin/core/FilteredBlock.java
@@ -26,7 +26,7 @@ import java.util.*;
  */
 public class FilteredBlock extends Message {
     /** The protocol version at which Bloom filtering started to be supported. */
-    public static final int MIN_PROTOCOL_VERSION = 70000;
+    public static final int MIN_PROTOCOL_VERSION = 60000;
     private Block header;
 
     // The PartialMerkleTree of transactions
diff --git a/core/src/main/java/com/google/bitcoin/core/HeadersMessage.java b/core/src/main/java/com/google/bitcoin/core/HeadersMessage.java
index dd0650e..dd0db02 100644
--- a/core/src/main/java/com/google/bitcoin/core/HeadersMessage.java
+++ b/core/src/main/java/com/google/bitcoin/core/HeadersMessage.java
@@ -83,8 +83,8 @@ public class HeadersMessage extends Message {
         for (int i = 0; i < numHeaders; ++i) {
             // Read 80 bytes of the header and one more byte for the transaction list, which is always a 00 because the
             // transaction list is empty.
-            byte[] blockHeader = readBytes(81);
-            if (blockHeader[80] != 0)
+            byte[] blockHeader = readBytes(82);
+            if (blockHeader[80] != 0 || blockHeader[81] != 0)
                 throw new ProtocolException("Block header does not end with a null byte");
             Block newBlockHeader = new Block(this.params, blockHeader, true, true, 81);
             blockHeaders.add(newBlockHeader);
diff --git a/core/src/main/java/com/google/bitcoin/core/NetworkParameters.java b/core/src/main/java/com/google/bitcoin/core/NetworkParameters.java
index d684ea5..3403fc4 100644
--- a/core/src/main/java/com/google/bitcoin/core/NetworkParameters.java
+++ b/core/src/main/java/com/google/bitcoin/core/NetworkParameters.java
@@ -43,7 +43,7 @@ public abstract class NetworkParameters implements Serializable {
     /**
      * The protocol version this library implements.
      */
-    public static final int PROTOCOL_VERSION = 70001;
+    public static final int PROTOCOL_VERSION = 60004;
 
     /**
      * The alert signing key originally owned by Satoshi, and now passed on to Gavin along with a few others.
diff --git a/core/src/main/java/com/google/bitcoin/core/Peer.java b/core/src/main/java/com/google/bitcoin/core/Peer.java
index da4a18f..926aecc 100644
--- a/core/src/main/java/com/google/bitcoin/core/Peer.java
+++ b/core/src/main/java/com/google/bitcoin/core/Peer.java
@@ -355,6 +355,8 @@ public class Peer extends PeerSocketHandler {
                 sendMessage(new Pong(((Ping) m).getNonce()));
         } else if (m instanceof Pong) {
             processPong((Pong)m);
+        } else if (m instanceof CheckpointMessage) {//Peercoin
+
         } else {
             log.warn("Received unhandled message: {}", m);
         }
diff --git a/core/src/main/java/com/google/bitcoin/core/PeerGroup.java b/core/src/main/java/com/google/bitcoin/core/PeerGroup.java
index 9ac0251..6a07298 100644
--- a/core/src/main/java/com/google/bitcoin/core/PeerGroup.java
+++ b/core/src/main/java/com/google/bitcoin/core/PeerGroup.java
@@ -160,7 +160,7 @@ public class PeerGroup extends AbstractExecutionThreadService implements Transac
             queueRecalc(true);
         }
 
-        @Override public void onKeysAdded(Wallet wallet, List<ECKey> keys) {
+        @Override public void onKeysAdded(List<ECKey> keys) {
             queueRecalc(true);
         }
 
@@ -251,6 +251,8 @@ public class PeerGroup extends AbstractExecutionThreadService implements Transac
     public static final int DEFAULT_CONNECT_TIMEOUT_MILLIS = 5000;
     private volatile int vConnectTimeoutMillis = DEFAULT_CONNECT_TIMEOUT_MILLIS;
 
+    private boolean reusePeerAfterFailure = true;
+    
     /**
      * Creates a PeerGroup with the given parameters. No chain is provided so this node will report its chain height
      * as zero to other peers. This constructor is useful if you just want to explore the network but aren't interested
@@ -819,7 +821,11 @@ public class PeerGroup extends AbstractExecutionThreadService implements Transac
                 bloomFilter = filter;
 
                 switch (mode) {
-                    case SEND_IF_CHANGED: send = changed; break;
+                    case SEND_IF_CHANGED:
+                        send = changed;
+                        if (!send)
+                            log.info(" ... however filter did not change.");  // Optimisation opportunity!
+                        break;
                     case DONT_SEND: send = false; break;
                     case FORCE_SEND: send = true; break;
                 }
@@ -1186,7 +1192,8 @@ public class PeerGroup extends AbstractExecutionThreadService implements Transac
             //TODO: if network failure is suspected, do not backoff peer
             backoffMap.get(address).trackFailure();
             // Put back on inactive list
-            inactives.offer(address);
+            if(reusePeerAfterFailure)
+            	inactives.offer(address);
 
             if (numPeers < getMaxConnections()) {
                 triggerConnections();
@@ -1516,4 +1523,12 @@ public class PeerGroup extends AbstractExecutionThreadService implements Transac
             lock.unlock();
         }
     }
+    
+    public boolean isReusePeerAfterFailure() {
+		return reusePeerAfterFailure;
+	}
+    
+    public void setReusePeerAfterFailure(boolean reusePeerAfterFailure) {
+		this.reusePeerAfterFailure = reusePeerAfterFailure;
+	}
 }
diff --git a/core/src/main/java/com/google/bitcoin/core/Transaction.java b/core/src/main/java/com/google/bitcoin/core/Transaction.java
index fe863cc..60d99fc 100644
--- a/core/src/main/java/com/google/bitcoin/core/Transaction.java
+++ b/core/src/main/java/com/google/bitcoin/core/Transaction.java
@@ -24,11 +24,13 @@ import com.google.bitcoin.script.ScriptOpCodes;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.primitives.Ints;
 import com.google.common.primitives.Longs;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.spongycastle.crypto.params.KeyParameter;
 
 import javax.annotation.Nullable;
+
 import java.io.*;
 import java.math.BigInteger;
 import java.text.ParseException;
@@ -94,11 +96,12 @@ public class Transaction extends ChildMessage implements Serializable {
     public static final BigInteger MIN_NONDUST_OUTPUT = BigInteger.valueOf(5460);
 
     // These are serialized in both bitcoin and java serialization.
-    private long version;
-    private ArrayList<TransactionInput> inputs;
-    private ArrayList<TransactionOutput> outputs;
+    protected long version;
+    protected long time;//Peercoin
+    protected ArrayList<TransactionInput> inputs;
+    protected ArrayList<TransactionOutput> outputs;
 
-    private long lockTime;
+    protected long lockTime;
 
     // This is either the time the transaction was broadcast as measured from the local clock, or the time from the
     // block in which it was included. Note that this can be changed by re-orgs so the wallet may update this field.
@@ -522,7 +525,8 @@ public class Transaction extends ChildMessage implements Serializable {
         cursor = offset;
 
         version = readUint32();
-        optimalEncodingMessageSize = 4;
+        time = readUint32();//Peercoin
+        optimalEncodingMessageSize = 8;//Peercoin
 
         // First come the inputs.
         long numInputs = readVarInt();
@@ -656,7 +660,7 @@ public class Transaction extends ChildMessage implements Serializable {
                 s.append(scriptPubKey);
                 s.append(" ");
                 s.append(bitcoinValueToFriendlyString(out.getValue()));
-                s.append(" BTC");
+                s.append(" PPC");
                 if (!out.isAvailableForSpending()) {
                     s.append(" Spent");
                 }
@@ -854,13 +858,16 @@ public class Transaction extends ChildMessage implements Serializable {
             // The anyoneCanPay feature isn't used at the moment.
             boolean anyoneCanPay = false;
             byte[] connectedPubKeyScript = input.getOutpoint().getConnectedPubKeyScript();
-            if (key.hasPrivKey() || key.isEncrypted()) {
+            try {
                 signatures[i] = calculateSignature(i, key, aesKey, connectedPubKeyScript, hashType, anyoneCanPay);
-            } else {
+            } catch (ECKey.KeyIsEncryptedException e) {
+                throw e;
+            } catch (ECKey.MissingPrivateKeyException e) {
                 // Create a dummy signature to ensure the transaction is of the correct size when we try to ensure
                 // the right fee-per-kb is attached. If the wallet doesn't have the privkey, the user is assumed to
                 // be doing something special and that they will replace the dummy signature with a real one later.
                 signatures[i] = TransactionSignature.dummy();
+                log.info("Used dummy signature for input {} due to failure during signing (most likely missing privkey)", i);
             }
         }
 
@@ -1076,6 +1083,7 @@ public class Transaction extends ChildMessage implements Serializable {
     @Override
     protected void bitcoinSerializeToStream(OutputStream stream) throws IOException {
         uint32ToByteStreamLE(version, stream);
+		uint32ToByteStreamLE(time, stream);// Peercion
         stream.write(new VarInt(inputs.size()).encode());
         for (TransactionInput in : inputs)
             in.bitcoinSerialize(stream);
@@ -1292,4 +1300,13 @@ public class Transaction extends ChildMessage implements Serializable {
     public void setPurpose(Purpose purpose) {
         this.purpose = purpose;
     }
+    
+    // Peercoin
+    public void setTime(long time) {
+		this.time = time;
+	}
+    
+    public long getTime() {
+		return time;
+	}
 }
diff --git a/core/src/main/java/com/google/bitcoin/core/Utils.java b/core/src/main/java/com/google/bitcoin/core/Utils.java
index b796b61..3a247ba 100644
--- a/core/src/main/java/com/google/bitcoin/core/Utils.java
+++ b/core/src/main/java/com/google/bitcoin/core/Utils.java
@@ -66,7 +66,7 @@ public class Utils {
      * The term nanocoin is very misleading, though, because there are only 100 million
      * of them in a coin (whereas one would expect 1 billion.
      */
-    public static final BigInteger COIN = new BigInteger("100000000", 10);
+    public static final BigInteger COIN = new BigInteger("1000000", 10);
 
     /**
      * How many "nanocoins" there are in 0.01 BitCoins.
@@ -75,7 +75,7 @@ public class Utils {
      * The term nanocoin is very misleading, though, because there are only 100 million
      * of them in a coin (whereas one would expect 1 billion).
      */
-    public static final BigInteger CENT = new BigInteger("1000000", 10);
+    public static final BigInteger CENT = new BigInteger("10000", 10);
     private static BlockingQueue<Boolean> mockSleepQueue;
 
     /**
@@ -120,7 +120,7 @@ public class Utils {
      * @throws ArithmeticException if you try to specify fractional nanocoins, or nanocoins out of range.
      */
     public static BigInteger toNanoCoins(String coins) {
-        BigInteger bigint = new BigDecimal(coins).movePointRight(8).toBigIntegerExact();
+        BigInteger bigint = new BigDecimal(coins).movePointRight(6).toBigIntegerExact();
         if (bigint.signum() < 0)
             throw new ArithmeticException("Negative coins specified");
         if (bigint.compareTo(NetworkParameters.MAX_MONEY) > 0)
@@ -335,7 +335,7 @@ public class Utils {
         boolean negative = value.signum() < 0;
         if (negative)
             value = value.negate();
-        BigDecimal bd = new BigDecimal(value, 8);
+        BigDecimal bd = new BigDecimal(value, 6);
         String formatted = bd.toPlainString();   // Don't use scientific notation.
         int decimalPoint = formatted.indexOf(".");
         // Drop unnecessary zeros from the end.
@@ -476,8 +476,8 @@ public class Utils {
     /**
      * Sets the mock clock to the given time (in seconds).
      */
-    public static void setMockClock(long mockClock) {
-        mockTime = new Date(mockClock * 1000);
+    public static void setMockClock(long mockClockSeconds) {
+        mockTime = new Date(mockClockSeconds * 1000);
     }
 
     /**
diff --git a/core/src/main/java/com/google/bitcoin/core/Wallet.java b/core/src/main/java/com/google/bitcoin/core/Wallet.java
index 489eb59..55bf1e3 100644
--- a/core/src/main/java/com/google/bitcoin/core/Wallet.java
+++ b/core/src/main/java/com/google/bitcoin/core/Wallet.java
@@ -18,6 +18,7 @@
 package com.google.bitcoin.core;
 
 import com.google.bitcoin.core.TransactionConfidence.ConfidenceType;
+import com.google.bitcoin.crypto.DeterministicKey;
 import com.google.bitcoin.crypto.KeyCrypter;
 import com.google.bitcoin.crypto.KeyCrypterException;
 import com.google.bitcoin.crypto.KeyCrypterScrypt;
@@ -32,17 +33,15 @@ import com.google.bitcoin.wallet.*;
 import com.google.bitcoin.wallet.WalletTransaction.Pool;
 import com.google.common.collect.*;
 import com.google.common.primitives.Ints;
-import com.google.common.util.concurrent.FutureCallback;
-import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.SettableFuture;
+import org.bitcoinj.wallet.Protos;
 import org.bitcoinj.wallet.Protos.Wallet.EncryptionType;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.spongycastle.crypto.params.KeyParameter;
 import org.spongycastle.util.encoders.Hex;
 
-import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import javax.annotation.concurrent.GuardedBy;
 import java.io.*;
@@ -69,7 +68,6 @@ import static com.google.common.base.Preconditions.*;
 //   process and sort every single transaction.
 // - Decompose the class where possible: break logic out into classes that can be customized/replaced by the user.
 //     - [Auto]saving to a backing store
-//     - Key management
 //     - just generally make Wallet smaller and easier to work with
 // - Make clearing of transactions able to only rewind the wallet a certain distance instead of all blocks.
 // - Make it scale:
@@ -131,8 +129,9 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
     // All transactions together.
     final Map<Sha256Hash, Transaction> transactions;
 
-    // A list of public/private EC keys owned by this user. Access it using addKey[s], hasKey[s] and findPubKeyFromHash.
-    private ArrayList<ECKey> keychain;
+    // The key chain group is not thread safe, and generally the whole hierarchy of objects should not be mutated
+    // outside the wallet lock. So don't expose this object directly via any accessors!
+    @GuardedBy("lock") protected KeyChainGroup keychain;
 
     // A list of scripts watched by this wallet.
     private Set<Script> watchedScripts;
@@ -172,8 +171,6 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
 
     private transient CoinSelector coinSelector = new DefaultCoinSelector();
 
-    // The keyCrypter for the wallet. This specifies the algorithm used for encrypting and decrypting the private keys.
-    private KeyCrypter keyCrypter;
     // The wallet version. This is an int that can be used to track breaking changes in the wallet format.
     // You can also use it to detect wallets that come from the future (ie they contain features you
     // do not know how to deal with).
@@ -192,8 +189,22 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
      * see loadFromFile.
      */
     public Wallet(NetworkParameters params) {
+        this(params, new KeyChainGroup());
+    }
+
+    public static Wallet fromSeed(NetworkParameters params, DeterministicSeed seed) {
+        return new Wallet(params, new KeyChainGroup(seed));
+    }
+
+    public static Wallet fromWatchingKey(NetworkParameters params, DeterministicKey watchKey) {
+        return new Wallet(params, new KeyChainGroup(watchKey));
+    }
+
+    // TODO: When this class moves to the Wallet package, along with the protobuf serializer, then hide this.
+    /** For internal use only. */
+    public Wallet(NetworkParameters params, KeyChainGroup keyChainGroup) {
         this.params = checkNotNull(params);
-        keychain = new ArrayList<ECKey>();
+        this.keychain = checkNotNull(keyChainGroup);
         watchedScripts = Sets.newHashSet();
         unspent = new HashMap<Sha256Hash, Transaction>();
         spent = new HashMap<Sha256Hash, Transaction>();
@@ -207,14 +218,6 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
         createTransientState();
     }
 
-    /**
-     * Create a wallet with a keyCrypter to use in encrypting and decrypting keys.
-     */
-    public Wallet(NetworkParameters params, KeyCrypter keyCrypter) {
-        this(params);
-        this.keyCrypter = checkNotNull(keyCrypter);
-    }
-
     private void createTransientState() {
         ignoreNextNewBlock = new HashSet<Sha256Hash>();
         txConfidenceListener = new TransactionConfidence.Listener() {
@@ -245,19 +248,67 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
         return params;
     }
 
+
+
+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //
+    // Key management
+    //
+
+    /**
+     * Returns a key that hasn't been seen in a transaction yet, and which is suitable for displaying in a wallet
+     * user interface as "a convenient key to receive funds on" when the purpose parameter is
+     * {@link com.google.bitcoin.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS}. The returned key is stable until
+     * it's actually seen in a pending or confirmed transaction, at which point this method will start returning
+     * a different key (for each purpose independently).
+     */
+    public DeterministicKey currentKey(KeyChain.KeyPurpose purpose) {
+        lock.lock();
+        try {
+            return keychain.currentKey(purpose);
+        } finally {
+            lock.unlock();
+        }
+    }
+
     /**
-     * Returns a snapshot of the keychain. This view is not live.
+     * An alias for calling {@link #currentKey(com.google.bitcoin.wallet.KeyChain.KeyPurpose)} with
+     * {@link com.google.bitcoin.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
      */
-    public List<ECKey> getKeys() {
+    public DeterministicKey currentReceiveKey() {
+        return currentKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
+    }
+
+    /**
+     * Returns a key that has not been returned by this method before (fresh). You can think of this as being
+     * a newly created key, although the notion of "create" is not really valid for a
+     * {@link com.google.bitcoin.wallet.DeterministicKeyChain}. When the parameter is
+     * {@link com.google.bitcoin.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for being put
+     * into a receive coins wizard type UI. You should use this when the user is definitely going to hand this key out
+     * to someone who wishes to send money.
+     */
+    public DeterministicKey freshKey(KeyChain.KeyPurpose purpose) {
         lock.lock();
         try {
-            return new ArrayList<ECKey>(keychain);
+            DeterministicKey key = keychain.freshKey(purpose);
+            // Do we really need an immediate hard save? Arguably all this is doing is saving the 'current' key
+            // and that's not quite so important, so we could coalesce for more performance.
+            saveNow();
+            return key;
         } finally {
             lock.unlock();
         }
     }
 
     /**
+     * An alias for calling {@link #freshKey(com.google.bitcoin.wallet.KeyChain.KeyPurpose)} with
+     * {@link com.google.bitcoin.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
+     */
+    public DeterministicKey freshReceiveKey() {
+        return freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
+    }
+
+    /**
      * Returns a snapshot of the watched scripts. This view is not live.
      */
     public List<Script> getWatchedScripts() {
@@ -270,26 +321,303 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
     }
 
     /**
-     * Removes the given key from the keychain. Be very careful with this - losing a private key <b>destroys the
+     * Removes the given key from the basicKeyChain. Be very careful with this - losing a private key <b>destroys the
      * money associated with it</b>.
      * @return Whether the key was removed or not.
      */
     public boolean removeKey(ECKey key) {
         lock.lock();
         try {
-            return keychain.remove(key);
+            return keychain.removeImportedKey(key);
         } finally {
             lock.unlock();
         }
     }
-    
+
     /**
-     * Returns the number of keys in the keychain.
+     * Returns the number of keys in the key chain, including lookahead keys.
      */
     public int getKeychainSize() {
         lock.lock();
         try {
-            return keychain.size();
+            return keychain.numKeys();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Returns a list of the non-deterministic keys that have been imported into the wallet, or the empty list if none.
+     */
+    public List<ECKey> getImportedKeys() {
+        lock.lock();
+        try {
+            return keychain.getImportedKeys();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /** Returns the address used for change outputs. Note: this will probably go away in future. */
+    public Address getChangeAddress() {
+        return currentKey(KeyChain.KeyPurpose.CHANGE).toAddress(params);
+    }
+
+    /**
+     * <p>Deprecated alias for {@link #importKey(ECKey)}.</p>
+     *
+     * <p><b>Replace with either {@link #freshReceiveKey()} if your call is addKey(new ECKey()), or with {@link #importKey(ECKey)}
+     * which does the same thing this method used to, but with a better name.</b></p>
+     */
+    @Deprecated
+    public boolean addKey(ECKey key) {
+        return importKey(key);
+    }
+
+    /**
+     * <p>Imports the given ECKey to the wallet.</p>
+     *
+     * <p>If the wallet is configured to auto save to a file, triggers a save immediately. Runs the onKeysAdded event
+     * handler. If the key already exists in the wallet, does nothing and returns false.</p>
+     */
+    public boolean importKey(ECKey key) {
+        return importKeys(Lists.newArrayList(key)) == 1;
+    }
+
+    /** Replace with {@link #importKeys(java.util.List)}, which does the same thing but with a better name. */
+    @Deprecated
+    public int addKeys(List<ECKey> keys) {
+        return importKeys(keys);
+    }
+
+    /**
+     * Imports the given keys to the wallet.
+     * If {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, com.google.bitcoin.wallet.WalletFiles.Listener)}
+     * has been called, triggers an auto save bypassing the normal coalescing delay and event handlers.
+     * Returns the number of keys added, after duplicates are ignored. The onKeyAdded event will be called for each key
+     * in the list that was not already present.
+     */
+    public int importKeys(final List<ECKey> keys) {
+        lock.lock();
+        try {
+            int result = keychain.importKeys(keys);
+            saveNow();
+            return result;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /** Takes a list of keys and a password, then encrypts and imports them in one step using the current keycrypter. */
+    public int importKeysAndEncrypt(final List<ECKey> keys, CharSequence password) {
+        lock.lock();
+        try {
+            checkNotNull(getKeyCrypter(), "Wallet is not encrypted");
+            return importKeysAndEncrypt(keys, getKeyCrypter().deriveKey(password));
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /** Takes a list of keys and an AES key, then encrypts and imports them in one step using the current keycrypter. */
+    public int importKeysAndEncrypt(final List<ECKey> keys, KeyParameter aesKey) {
+        lock.lock();
+        try {
+            return keychain.importKeysAndEncrypt(keys, aesKey);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /** See {@link com.google.bitcoin.wallet.DeterministicKeyChain#setLookaheadSize(int)} for more info on this. */
+    public void setKeychainLookaheadSize(int lookaheadSize) {
+        lock.lock();
+        try {
+            keychain.setLookaheadSize(lookaheadSize);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /** See {@link com.google.bitcoin.wallet.DeterministicKeyChain#setLookaheadSize(int)} for more info on this. */
+    public int getKeychainLookaheadSize() {
+        return keychain.getLookaheadSize();
+    }
+
+    /**
+     * Returns a public-only DeterministicKey that can be used to set up a watching wallet: that is, a wallet that
+     * can import transactions from the block chain just as the normal wallet can, but which cannot spend. Watching
+     * wallets are very useful for things like web servers that accept payments.
+     */
+    public DeterministicKey getWatchingKey() {
+        lock.lock();
+        try {
+            return keychain.getActiveKeyChain().getWatchingKey();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Return true if we are watching this address.
+     */
+    public boolean isAddressWatched(Address address) {
+        Script script = ScriptBuilder.createOutputScript(address);
+        return isWatchedScript(script);
+    }
+
+    /**
+     * Same as {@link #addWatchedAddress(Address, long)} with the current time as the creation time.
+     */
+    public boolean addWatchedAddress(final Address address) {
+        long now = Utils.currentTimeMillis() / 1000;
+        return addWatchedAddresses(Lists.newArrayList(address), now) == 1;
+    }
+
+    /**
+     * Adds the given address to the wallet to be watched. Outputs can be retrieved by {@link #getWatchedOutputs(boolean)}.
+     *
+     * @param creationTime creation time in seconds since the epoch, for scanning the blockchain
+     * @return whether the address was added successfully (not already present)
+     */
+    public boolean addWatchedAddress(final Address address, long creationTime) {
+        return addWatchedAddresses(Lists.newArrayList(address), creationTime) == 1;
+    }
+
+    /**
+     * Adds the given address to the wallet to be watched. Outputs can be retrieved
+     * by {@link #getWatchedOutputs(boolean)}.
+     *
+     * @return how many addresses were added successfully
+     */
+    public int addWatchedAddresses(final List<Address> addresses, long creationTime) {
+        List<Script> scripts = Lists.newArrayList();
+
+        for (Address address : addresses) {
+            Script script = ScriptBuilder.createOutputScript(address);
+            script.setCreationTimeSeconds(creationTime);
+            scripts.add(script);
+        }
+
+        return addWatchedScripts(scripts);
+    }
+
+    /**
+     * Adds the given output scripts to the wallet to be watched. Outputs can be retrieved
+     * by {@link #getWatchedOutputs(boolean)}.
+     *
+     * @return how many scripts were added successfully
+     */
+    public int addWatchedScripts(final List<Script> scripts) {
+        lock.lock();
+        try {
+            int added = 0;
+            for (final Script script : scripts) {
+                if (watchedScripts.contains(script)) continue;
+
+                watchedScripts.add(script);
+                added++;
+            }
+
+            queueOnScriptsAdded(scripts);
+            saveNow();
+            return added;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Locates a keypair from the basicKeyChain given the hash of the public key. This is needed when finding out which
+     * key we need to use to redeem a transaction output.
+     *
+     * @return ECKey object or null if no such key was found.
+     */
+    @Nullable
+    public ECKey findKeyFromPubHash(byte[] pubkeyHash) {
+        lock.lock();
+        try {
+            return keychain.findKeyFromPubHash(pubkeyHash);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /** Returns true if the given key is in the wallet, false otherwise. Currently an O(N) operation. */
+    public boolean hasKey(ECKey key) {
+        lock.lock();
+        try {
+            return keychain.hasKey(key);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Returns true if this wallet contains a public key which hashes to the given hash.
+     */
+    public boolean isPubKeyHashMine(byte[] pubkeyHash) {
+        return findKeyFromPubHash(pubkeyHash) != null;
+    }
+
+    /** Returns true if this wallet is watching transactions for outputs with the script. */
+    public boolean isWatchedScript(Script script) {
+        lock.lock();
+        try {
+            return watchedScripts.contains(script);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Locates a keypair from the basicKeyChain given the raw public key bytes.
+     * @return ECKey or null if no such key was found.
+     */
+    @Nullable
+    public ECKey findKeyFromPubKey(byte[] pubkey) {
+        lock.lock();
+        try {
+            return keychain.findKeyFromPubKey(pubkey);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Returns true if this wallet contains a keypair with the given public key.
+     */
+    public boolean isPubKeyMine(byte[] pubkey) {
+        return findKeyFromPubKey(pubkey) != null;
+    }
+
+    /**
+     * Returns the immutable seed for the current active HD chain.
+     * @throws com.google.bitcoin.core.ECKey.MissingPrivateKeyException if the seed is unavailable (watching wallet)
+     */
+    public DeterministicSeed getKeyChainSeed() {
+        lock.lock();
+        try {
+            DeterministicSeed seed = keychain.getActiveKeyChain().getSeed();
+            if (seed == null)
+                throw new ECKey.MissingPrivateKeyException();
+            return seed;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //
+    // Serialization support
+    //
+
+    // TODO: Make this package private once the classes finish moving around.
+    /** Internal use only. */
+    public List<Protos.Key> serializeKeychainToProtobuf() {
+        lock.lock();
+        try {
+            return keychain.serializeToProtobuf();
         } finally {
             lock.unlock();
         }
@@ -1220,7 +1548,13 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
      * like receiving money. The listener is executed by the given executor.
      */
     public void addEventListener(WalletEventListener listener, Executor executor) {
-        eventListeners.add(new ListenerRegistration<WalletEventListener>(listener, executor));
+        lock.lock();
+        try {
+            eventListeners.add(new ListenerRegistration<WalletEventListener>(listener, executor));
+            keychain.addEventListener(listener, executor);
+        } finally {
+            lock.unlock();
+        }
     }
 
     /**
@@ -1228,7 +1562,13 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
      * was never added.
      */
     public boolean removeEventListener(WalletEventListener listener) {
-        return ListenerRegistration.removeFromList(listener, eventListeners);
+        lock.lock();
+        try {
+            keychain.removeEventListener(listener);
+            return ListenerRegistration.removeFromList(listener, eventListeners);
+        } finally {
+            lock.unlock();
+        }
     }
 
     /**
@@ -1906,8 +2246,6 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
             //
             // Note that this code is poorly optimized: the spend candidates only alter when transactions in the wallet
             // change - it could be pre-calculated and held in RAM, and this is probably an optimization worth doing.
-            // Note that output.isMine(this) needs to test the keychain which is currently an array, so it's
-            // O(candidate outputs ^ keychain.size())! There's lots of low hanging fruit here.
             LinkedList<TransactionOutput> candidates = calculateAllSpendCandidates(true);
             CoinSelection bestCoinSelection;
             TransactionOutput bestChangeOutput = null;
@@ -2043,203 +2381,6 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
         }
     }
 
-    /** Returns the address used for change outputs. Note: this will probably go away in future. */
-    public Address getChangeAddress() {
-        lock.lock();
-        try {
-            // For now let's just pick the first key in our keychain. In future we might want to do something else to
-            // give the user better privacy here, eg in incognito mode.
-            checkState(keychain.size() > 0, "Can't send value without an address to use for receiving change");
-            ECKey first = keychain.get(0);
-            return first.toAddress(params);
-        } finally {
-            lock.unlock();
-        }
-    }
-
-    /**
-     * Adds the given ECKey to the wallet. There is currently no way to delete keys (that would result in coin loss).
-     * If {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, com.google.bitcoin.wallet.WalletFiles.Listener)}
-     * has been called, triggers an auto save bypassing the normal coalescing delay and event handlers.
-     * If the key already exists in the wallet, does nothing and returns false.
-     */
-    public boolean addKey(final ECKey key) {
-        return addKeys(Lists.newArrayList(key)) == 1;
-    }
-
-    /**
-     * Adds the given keys to the wallet. There is currently no way to delete keys (that would result in coin loss).
-     * If {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, com.google.bitcoin.wallet.WalletFiles.Listener)}
-     * has been called, triggers an auto save bypassing the normal coalescing delay and event handlers.
-     * Returns the number of keys added, after duplicates are ignored. The onKeyAdded event will be called for each key
-     * in the list that was not already present.
-     */
-    public int addKeys(final List<ECKey> keys) {
-        lock.lock();
-        try {
-            int added = 0;
-            // TODO: Consider making keys a sorted list or hashset so membership testing is faster.
-            for (final ECKey key : keys) {
-                if (keychain.contains(key)) continue;
-
-                // If the key has a keyCrypter that does not match the Wallet's then a KeyCrypterException is thrown.
-                // This is done because only one keyCrypter is persisted per Wallet and hence all the keys must be homogenous.
-                if (isEncrypted() && (!key.isEncrypted() || !keyCrypter.equals(key.getKeyCrypter()))) {
-                    throw new KeyCrypterException("Cannot add key " + key.toString() + " because the keyCrypter does not match the wallets. Keys must be homogenous.");
-                } else if (key.isEncrypted() && !isEncrypted()) {
-                    throw new KeyCrypterException("Cannot add key because it's encrypted and this wallet is not.");
-                }
-                keychain.add(key);
-                added++;
-            }
-            queueOnKeysAdded(keys);
-            // Force an auto-save immediately rather than queueing one, as keys are too important to risk losing.
-            saveNow();
-            return added;
-        } finally {
-            lock.unlock();
-        }
-    }
-
-    /**
-     * Return true if we are watching this address.
-     */
-    public boolean isAddressWatched(Address address) {
-        Script script = ScriptBuilder.createOutputScript(address);
-        return isWatchedScript(script);
-    }
-
-    /**
-     * Same as {@link #addWatchedAddress(Address, long)} with the current time as the creation time.
-     */
-    public boolean addWatchedAddress(final Address address) {
-        long now = Utils.currentTimeSeconds();
-        return addWatchedAddresses(Lists.newArrayList(address), now) == 1;
-    }
-
-    /**
-     * Adds the given address to the wallet to be watched. Outputs can be retrieved by {@link #getWatchedOutputs(boolean)}.
-     *
-     * @param creationTime creation time in seconds since the epoch, for scanning the blockchain
-     * @return whether the address was added successfully (not already present)
-     */
-    public boolean addWatchedAddress(final Address address, long creationTime) {
-        return addWatchedAddresses(Lists.newArrayList(address), creationTime) == 1;
-    }
-
-    /**
-     * Adds the given address to the wallet to be watched. Outputs can be retrieved
-     * by {@link #getWatchedOutputs(boolean)}.
-     *
-     * @return how many addresses were added successfully
-     */
-    public int addWatchedAddresses(final List<Address> addresses, long creationTime) {
-        List<Script> scripts = Lists.newArrayList();
-
-        for (Address address : addresses) {
-            Script script = ScriptBuilder.createOutputScript(address);
-            script.setCreationTimeSeconds(creationTime);
-            scripts.add(script);
-        }
-
-        return addWatchedScripts(scripts);
-    }
-
-    /**
-     * Adds the given output scripts to the wallet to be watched. Outputs can be retrieved
-     * by {@link #getWatchedOutputs(boolean)}.
-     *
-     * @return how many scripts were added successfully
-     */
-    public int addWatchedScripts(final List<Script> scripts) {
-        lock.lock();
-        try {
-            int added = 0;
-            for (final Script script : scripts) {
-                if (watchedScripts.contains(script)) continue;
-
-                watchedScripts.add(script);
-                added++;
-            }
-
-            queueOnScriptsAdded(scripts);
-            saveNow();
-            return added;
-        } finally {
-            lock.unlock();
-        }
-    }
-
-    /**
-     * Locates a keypair from the keychain given the hash of the public key. This is needed when finding out which
-     * key we need to use to redeem a transaction output.
-     *
-     * @return ECKey object or null if no such key was found.
-     */
-    @Nullable
-    public ECKey findKeyFromPubHash(byte[] pubkeyHash) {
-        lock.lock();
-        try {
-            for (ECKey key : keychain) {
-                if (Arrays.equals(key.getPubKeyHash(), pubkeyHash)) return key;
-            }
-            return null;
-        } finally {
-            lock.unlock();
-        }
-    }
-
-    /** Returns true if the given key is in the wallet, false otherwise. Currently an O(N) operation. */
-    public boolean hasKey(ECKey key) {
-        lock.lock();
-        try {
-            return keychain.contains(key);
-        } finally {
-            lock.unlock();
-        }
-    }
-
-    /**
-     * Returns true if this wallet contains a public key which hashes to the given hash.
-     */
-    public boolean isPubKeyHashMine(byte[] pubkeyHash) {
-        return findKeyFromPubHash(pubkeyHash) != null;
-    }
-
-    /** Returns true if this wallet is watching transactions for outputs with the script. */
-    public boolean isWatchedScript(Script script) {
-        lock.lock();
-        try {
-            return watchedScripts.contains(script);
-        } finally {
-            lock.unlock();
-        }
-    }
-
-    /**
-     * Locates a keypair from the keychain given the raw public key bytes.
-     * @return ECKey or null if no such key was found.
-     */
-    @Nullable
-    public ECKey findKeyFromPubKey(byte[] pubkey) {
-        lock.lock();
-        try {
-            for (ECKey key : keychain) {
-                if (Arrays.equals(key.getPubKey(), pubkey)) return key;
-            }
-            return null;
-        } finally {
-            lock.unlock();
-        }
-    }
-
-    /**
-     * Returns true if this wallet contains a keypair with the given public key.
-     */
-    public boolean isPubKeyMine(byte[] pubkey) {
-        return findKeyFromPubKey(pubkey) != null;
-    }
-
     /**
      * <p>It's possible to calculate a wallets balance from multiple points of view. This enum selects which
      * getBalance() should use.</p>
@@ -2361,21 +2502,13 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
             final String lastBlockSeenTimeStr = lastBlockSeenTime == null ? "time unknown" : lastBlockSeenTime.toString();
             builder.append(String.format("Last seen best block: %d (%s): %s%n",
                     getLastBlockSeenHeight(), lastBlockSeenTimeStr, getLastBlockSeenHash()));
-            if (this.keyCrypter != null) {
-                builder.append(String.format("Encryption: %s%n", keyCrypter.toString()));
-            }
+            final KeyCrypter crypter = keychain.getKeyCrypter();
+            if (crypter != null)
+                builder.append(String.format("Encryption: %s%n", crypter));
+
             // Do the keys.
             builder.append("\nKeys:\n");
-            for (ECKey key : keychain) {
-                final Address address = key.toAddress(params);
-                builder.append("  addr:");
-                builder.append(address.toString());
-                builder.append(" hash160:");
-                builder.append(Utils.bytesToHexString(address.getHash160()));
-                builder.append(" ");
-                builder.append(includePrivateKeys ? key.toStringWithPrivate() : key.toString());
-                builder.append("\n");
-            }
+            builder.append(keychain.toString(params, includePrivateKeys));
 
             if (!watchedScripts.isEmpty()) {
                 builder.append("\nWatched scripts:\n");
@@ -2656,9 +2789,7 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
     public long getEarliestKeyCreationTime() {
         lock.lock();
         try {
-            long earliestTime = Long.MAX_VALUE;
-            for (ECKey key : keychain)
-                earliestTime = Math.min(key.getCreationTimeSeconds(), earliestTime);
+            long earliestTime = keychain.getEarliestKeyCreationTime();
             for (Script script : watchedScripts)
                 earliestTime = Math.min(script.getCreationTimeSeconds(), earliestTime);
             if (earliestTime == Long.MAX_VALUE)
@@ -2755,15 +2886,17 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
     /**
      * Convenience wrapper around {@link Wallet#encrypt(com.google.bitcoin.crypto.KeyCrypter,
      * org.spongycastle.crypto.params.KeyParameter)} which uses the default Scrypt key derivation algorithm and
-     * parameters, derives a key from the given password and returns the created key.
+     * parameters to derive a key from the given password.
      */
-    public KeyParameter encrypt(CharSequence password) {
-        checkNotNull(password);
-        checkArgument(password.length() > 0);
-        KeyCrypter scrypt = new KeyCrypterScrypt();
-        KeyParameter derivedKey = scrypt.deriveKey(password);
-        encrypt(scrypt, derivedKey);
-        return derivedKey;
+    public void encrypt(CharSequence password) {
+        lock.lock();
+        try {
+            final KeyCrypterScrypt scrypt = new KeyCrypterScrypt();
+            keychain.encrypt(scrypt, scrypt.deriveKey(password));
+            saveNow();
+        } finally {
+            lock.unlock();
+        }
     }
 
     /**
@@ -2777,45 +2910,7 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
     public void encrypt(KeyCrypter keyCrypter, KeyParameter aesKey) {
         lock.lock();
         try {
-            checkNotNull(keyCrypter);
-            checkState(getEncryptionType() == EncryptionType.UNENCRYPTED, "Wallet is already encrypted");
-            // Create a new arraylist that will contain the encrypted keys
-            ArrayList<ECKey> encryptedKeyChain = new ArrayList<ECKey>();
-            for (ECKey key : keychain) {
-                if (key.isEncrypted()) {
-                    // Key is already encrypted - add as is.
-                    encryptedKeyChain.add(key);
-                } else {
-                    // Encrypt the key.
-                    ECKey encryptedKey = key.encrypt(keyCrypter, aesKey);
-
-                    // Check that the encrypted key can be successfully decrypted.
-                    // This is done as it is a critical failure if the private key cannot be decrypted successfully
-                    // (all bitcoin controlled by that private key is lost forever).
-                    // For a correctly constructed keyCrypter the encryption should always be reversible so it is just being as cautious as possible.
-                    if (!ECKey.encryptionIsReversible(key, encryptedKey, keyCrypter, aesKey)) {
-                        // Abort encryption
-                        throw new KeyCrypterException("The key " + key.toString() + " cannot be successfully decrypted after encryption so aborting wallet encryption.");
-                    }
-
-                    encryptedKeyChain.add(encryptedKey);
-                }
-            }
-
-            // Now ready to use the encrypted keychain so go through the old keychain clearing all the unencrypted private keys.
-            // (This is to avoid the possibility of key recovery from memory).
-            for (ECKey key : keychain) {
-                if (!key.isEncrypted()) {
-                    key.clearPrivateKey();
-                }
-            }
-
-            // Replace the old keychain with the encrypted one.
-            keychain = encryptedKeyChain;
-
-            // The wallet is now encrypted.
-            this.keyCrypter = keyCrypter;
-
+            keychain.encrypt(keyCrypter, aesKey);
             saveNow();
         } finally {
             lock.unlock();
@@ -2823,39 +2918,15 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
     }
 
     /**
-     * Decrypt the wallet with the wallets keyCrypter and AES key.
-     *
-     * @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming to create from a password)
+     * Decrypt the wallet with the wallets keyCrypter and password.
      * @throws KeyCrypterException Thrown if the wallet decryption fails. If so, the wallet state is unchanged.
      */
-    public void decrypt(KeyParameter aesKey) {
+    public void decrypt(CharSequence password) {
         lock.lock();
         try {
-            // Check the wallet is already encrypted - you cannot decrypt an unencrypted wallet.
-            checkState(getEncryptionType() != EncryptionType.UNENCRYPTED, "Wallet is already decrypted");
-            // Check that the wallet keyCrypter is non-null.
-            // This is set either at construction (if an encrypted wallet is created) or by wallet encryption.
-            checkNotNull(keyCrypter);
-
-            // Create a new arraylist that will contain the decrypted keys
-            ArrayList<ECKey> decryptedKeyChain = new ArrayList<ECKey>();
-
-            for (ECKey key : keychain) {
-                // Decrypt the key.
-                if (!key.isEncrypted()) {
-                    // Not encrypted - add to chain as is.
-                    decryptedKeyChain.add(key);
-                } else {
-                    ECKey decryptedECKey = key.decrypt(keyCrypter, aesKey);
-                    decryptedKeyChain.add(decryptedECKey);
-                }
-            }
-
-            // Replace the old keychain with the unencrypted one.
-            keychain = decryptedKeyChain;
-
-            // The wallet is now unencrypted.
-            keyCrypter = null;
+            final KeyCrypter crypter = keychain.getKeyCrypter();
+            checkState(crypter != null, "Not encrypted");
+            keychain.decrypt(crypter.deriveKey(password));
             saveNow();
         } finally {
             lock.unlock();
@@ -2863,31 +2934,16 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
     }
 
     /**
-     * Create a new, random encrypted ECKey and add it to the wallet.
-     *
-     * @param keyCrypter The keyCrypter to use in encrypting the new key
-     * @param aesKey The AES key to use to encrypt the new key
-     * @return ECKey the new, encrypted ECKey
-     */
-    public ECKey addNewEncryptedKey(KeyCrypter keyCrypter, KeyParameter aesKey) {
-        ECKey newKey = (new ECKey()).encrypt(checkNotNull(keyCrypter), checkNotNull(aesKey));
-        addKey(newKey);
-        return newKey;
-    }
-
-    /**
-     * <p>Convenience wrapper around {@link Wallet#addNewEncryptedKey(com.google.bitcoin.crypto.KeyCrypter,
-     * org.spongycastle.crypto.params.KeyParameter)} which just derives the key afresh and uses the pre-set
-     * keycrypter. The wallet must have been encrypted using one of the encrypt methods previously.</p>
+     * Decrypt the wallet with the wallets keyCrypter and AES key.
      *
-     * <p>Note that key derivation is deliberately very slow! So if you plan to add multiple keys, it can be
-     * faster to use the other method instead and re-use the {@link KeyParameter} object instead.</p>
+     * @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming to create from a password)
+     * @throws KeyCrypterException Thrown if the wallet decryption fails. If so, the wallet state is unchanged.
      */
-    public ECKey addNewEncryptedKey(CharSequence password) {
+    public void decrypt(KeyParameter aesKey) {
         lock.lock();
         try {
-            checkNotNull(keyCrypter, "Wallet is not encrypted, you must call encrypt() first.");
-            return addNewEncryptedKey(keyCrypter, keyCrypter.deriveKey(password));
+            keychain.decrypt(aesKey);
+            saveNow();
         } finally {
             lock.unlock();
         }
@@ -2898,11 +2954,12 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
      *  This can be used to check the validity of an entered password.
      *
      *  @return boolean true if password supplied can decrypt the first private key in the wallet, false otherwise.
+     *  @throws IllegalStateException if the wallet is not encrypted.
      */
     public boolean checkPassword(CharSequence password) {
         lock.lock();
         try {
-            return keyCrypter != null && checkAESKey(keyCrypter.deriveKey(checkNotNull(password)));
+            return keychain.checkPassword(password);
         } finally {
             lock.unlock();
         }
@@ -2916,65 +2973,21 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
     public boolean checkAESKey(KeyParameter aesKey) {
         lock.lock();
         try {
-            // If no keys then cannot decrypt.
-            if (!getKeys().iterator().hasNext())
-                return false;
-            // Find the first encrypted key in the wallet.
-            ECKey firstEncryptedECKey = null;
-            Iterator<ECKey> iterator = getKeys().iterator();
-            while (iterator.hasNext() && firstEncryptedECKey == null) {
-                ECKey loopECKey = iterator.next();
-                if (loopECKey.isEncrypted()) {
-                    firstEncryptedECKey = loopECKey;
-                }
-            }
-            // There are no encrypted keys in the wallet.
-            if (firstEncryptedECKey == null)
-                return false;
-            String originalAddress = firstEncryptedECKey.toAddress(getNetworkParameters()).toString();
-            if (firstEncryptedECKey.isEncrypted() && firstEncryptedECKey.getEncryptedPrivateKey() != null) {
-                try {
-                    ECKey rebornKey = firstEncryptedECKey.decrypt(keyCrypter, aesKey);
-
-                    // Check that the decrypted private key's address is correct ie it decrypted accurately.
-                    String rebornAddress = rebornKey.toAddress(getNetworkParameters()).toString();
-                    return originalAddress.equals(rebornAddress);
-                } catch (KeyCrypterException ede) {
-                    // The AES key supplied is incorrect.
-                    return false;
-                }
-            }
-            return false;
+            return keychain.checkAESKey(aesKey);
         } finally {
             lock.unlock();
         }
     }
 
     /**
-     * Get the wallet's KeyCrypter.
+     * Get the wallet's KeyCrypter, or null if the wallet is not encrypted.
      * (Used in encrypting/ decrypting an ECKey).
      */
+    @Nullable
     public KeyCrypter getKeyCrypter() {
         lock.lock();
         try {
-            return keyCrypter;
-        } finally {
-            lock.unlock();
-        }
-    }
-
-    /**
-     * Sets the wallet's KeyCrypter.
-     * Note that this does not encrypt the wallet, and should only be used if the keyCrypter can not be included in the
-     * constructor during initial wallet loading.
-     * Note that if the keyCrypter was not properly set during wallet load, {@link Wallet#getEncryptionType()} and
-     * {@link Wallet#isEncrypted()} will not return the correct results.
-     */
-    public void setKeyCrypter(KeyCrypter keyCrypter) {
-        lock.lock();
-        try {
-            checkState(this.keyCrypter == null);
-            this.keyCrypter = keyCrypter;
+            return keychain.getKeyCrypter();
         } finally {
             lock.unlock();
         }
@@ -2988,12 +3001,11 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
     public EncryptionType getEncryptionType() {
         lock.lock();
         try {
-            if (keyCrypter == null) {
-                // Unencrypted wallet.
+            KeyCrypter crypter = keychain.getKeyCrypter();
+            if (crypter != null)
+                return crypter.getUnderstoodEncryptionType();
+            else
                 return EncryptionType.UNENCRYPTED;
-            } else {
-                return keyCrypter.getUnderstoodEncryptionType();
-            }
         } finally {
             lock.unlock();
         }
@@ -3035,9 +3047,13 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
         return description;
     }
 
+    /**
+     * Returns the number of distinct data items (note: NOT keys) that will be inserted into a bloom filter, when it
+     * is constructed.
+     */
     @Override
     public int getBloomFilterElementCount() {
-        int size = getKeychainSize() * 2;
+        int size = keychain.getBloomFilterElementCount();
         for (Transaction tx : getTransactions(false)) {
             for (TransactionOutput out : tx.getOutputs()) {
                 try {
@@ -3075,24 +3091,22 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
     }
 
     /**
-     * Gets a bloom filter that contains all of the public keys from this wallet,
-     * and which will provide the given false-positive rate if it has size elements.
-     * Keep in mind that you will get 2 elements in the bloom filter for each key in the wallet.
+     * <p>Gets a bloom filter that contains all of the public keys from this wallet, and which will provide the given
+     * false-positive rate if it has size elements. Keep in mind that you will get 2 elements in the bloom filter for
+     * each key in the wallet, for the public key and the hash of the public key (address form).</p>
      * 
-     * This is used to generate a BloomFilter which can be #{link BloomFilter.merge}d with another.
-     * It could also be used if you have a specific target for the filter's size.
+     * <p>This is used to generate a BloomFilter which can be {@link BloomFilter#merge(BloomFilter)}d with another.
+     * It could also be used if you have a specific target for the filter's size.</p>
      * 
-     * See the docs for {@link BloomFilter(int, double)} for a brief explanation of anonymity when using bloom filters.
+     * <p>See the docs for {@link BloomFilter(int, double)} for a brief explanation of anonymity when using bloom
+     * filters.</p>
      */
     @Override
     public BloomFilter getBloomFilter(int size, double falsePositiveRate, long nTweak) {
-        BloomFilter filter = new BloomFilter(size, falsePositiveRate, nTweak);
+        BloomFilter filter;
         lock.lock();
         try {
-            for (ECKey key : keychain) {
-                filter.insert(key.getPubKey());
-                filter.insert(key.getPubKeyHash());
-            }
+            filter = keychain.getBloomFilter(size, falsePositiveRate, nTweak);
 
             for (Script script : watchedScripts) {
                 for (ScriptChunk chunk : script.getChunks()) {
@@ -3145,7 +3159,7 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
      * that were created by this wallet, but not others. You can override the coin selector for any given send
      * operation by changing {@link Wallet.SendRequest#coinSelector}.
      */
-    public void setCoinSelector(@Nonnull CoinSelector coinSelector) {
+    public void setCoinSelector(CoinSelector coinSelector) {
         lock.lock();
         try {
             this.coinSelector = checkNotNull(coinSelector);
@@ -3377,18 +3391,6 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
         }
     }
 
-    private void queueOnKeysAdded(final List<ECKey> keys) {
-        checkState(lock.isHeldByCurrentThread());
-        for (final ListenerRegistration<WalletEventListener> registration : eventListeners) {
-            registration.executor.execute(new Runnable() {
-                @Override
-                public void run() {
-                    registration.listener.onKeysAdded(Wallet.this, keys);
-                }
-            });
-        }
-    }
-
     private void queueOnScriptsAdded(final List<Script> scripts) {
         checkState(lock.isHeldByCurrentThread());
         for (final ListenerRegistration<WalletEventListener> registration : eventListeners) {
@@ -3734,14 +3736,14 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
 
     @Nullable
     private Transaction rekeyOneBatch(long keyRotationTimestamp, final TransactionBroadcaster broadcaster) {
-        final Transaction rekeyTx;
+        /*final Transaction rekeyTx;
 
         lock.lock();
         try {
             // Firstly, see if we have any keys that are beyond the rotation time, and any before.
             ECKey safeKey = null;
             boolean haveRotatingKeys = false;
-            for (ECKey key : keychain) {
+            for (ECKey key : basicKeyChain) {
                 final long t = key.getCreationTimeSeconds();
                 if (t < keyRotationTimestamp) {
                     haveRotatingKeys = true;
@@ -3814,6 +3816,7 @@ public class Wallet implements Serializable, BlockChainListener, PeerFilterProvi
                 }
             }
         }.start();
-        return rekeyTx;
+        return rekeyTx;*/
+        throw new RuntimeException("FIXME");
     }
 }
diff --git a/core/src/main/java/com/google/bitcoin/core/WalletEventListener.java b/core/src/main/java/com/google/bitcoin/core/WalletEventListener.java
index 95946fe..ca5e9f7 100644
--- a/core/src/main/java/com/google/bitcoin/core/WalletEventListener.java
+++ b/core/src/main/java/com/google/bitcoin/core/WalletEventListener.java
@@ -1,5 +1,5 @@
 /**
- * Copyright 2011 Google Inc.
+ * Copyright 2013 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 package com.google.bitcoin.core;
 
 import com.google.bitcoin.script.Script;
+import com.google.bitcoin.wallet.KeyChainEventListener;
 
 import java.math.BigInteger;
 import java.util.List;
@@ -25,7 +26,7 @@ import java.util.List;
  * <p>Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
  * or a block chain re-organize. It may be convenient to derive from {@link AbstractWalletEventListener} instead.</p>
  */
-public interface WalletEventListener {
+public interface WalletEventListener extends KeyChainEventListener {
     /**
      * This is called when a transaction is seen that sends coins <b>to</b> this wallet, either because it
      * was broadcast across the network or because a block was received. If a transaction is seen when it was broadcast,
@@ -116,12 +117,6 @@ public interface WalletEventListener {
      */
     void onWalletChanged(Wallet wallet);
 
-    /**
-     * Called whenever a new key is added to the wallet, whether that be via {@link Wallet#addKeys(java.util.List)}
-     * or due to some other automatic derivation.
-     */
-    void onKeysAdded(Wallet wallet, List<ECKey> keys);
-
     /** Called whenever a new watched script is added to the wallet. */
     void onScriptsAdded(Wallet wallet, List<Script> scripts);
 }
diff --git a/core/src/main/java/com/google/bitcoin/crypto/ChildNumber.java b/core/src/main/java/com/google/bitcoin/crypto/ChildNumber.java
index 40df049..3d8a0db 100644
--- a/core/src/main/java/com/google/bitcoin/crypto/ChildNumber.java
+++ b/core/src/main/java/com/google/bitcoin/crypto/ChildNumber.java
@@ -17,49 +17,60 @@
 package com.google.bitcoin.crypto;
 
 /**
- * <p>This is just a wrapper for the i (child number) as per BIP 32 with a boolean getter for the first bit and a getter
- * for the actual 0-based child number. A {@link List} of these forms a <i>path</i> through a
+ * <p>This is just a wrapper for the i (child number) as per BIP 32 with a boolean getter for the most significant bit
+ * and a getter for the actual 0-based child number. A {@link List} of these forms a <i>path</i> through a
  * {@link DeterministicHierarchy}. This class is immutable.
  */
 public class ChildNumber {
-    public static final int PRIV_BIT = 0x80000000;
+    /**
+     * The bit that's set in the child number to indicate whether this key is "hardened". Given a hardened key, it is
+     * not possible to derive a child public key if you know only the hardened public key. With a non-hardened key this
+     * is possible, so you can derive trees of public keys given only a public parent, but the downside is that it's
+     * possible to leak private keys if you disclose a parent public key and a child private key (elliptic curve maths
+     * allows you to work upwards).
+     */
+    public static final int HARDENED_BIT = 0x80000000;
+
     public static final ChildNumber ZERO = new ChildNumber(0);
+    public static final ChildNumber ONE = new ChildNumber(1);
+    public static final ChildNumber ZERO_HARDENED = new ChildNumber(0, true);
 
     /** Integer i as per BIP 32 spec, including the MSB denoting derivation type (0 = public, 1 = private) **/
     private final int i;
 
-    public ChildNumber(int childNumber, boolean isPrivate) {
-        if (hasPrivateBit(childNumber)) {
+    public ChildNumber(int childNumber, boolean isHardened) {
+        if (hasHardenedBit(childNumber))
             throw new IllegalArgumentException("Most significant bit is reserved and shouldn't be set: " + childNumber);
-        }
-        i = isPrivate ? (childNumber | PRIV_BIT) : childNumber;
+        i = isHardened ? (childNumber | HARDENED_BIT) : childNumber;
     }
 
     public ChildNumber(int i) {
         this.i = i;
     }
 
+    /** Returns the uint32 encoded form of the path element, including the most significant bit. */
     public int getI() {
         return i;
     }
 
-    public boolean isPrivateDerivation() {
-        return hasPrivateBit(i);
+    /** Returns the uint32 encoded form of the path element, including the most significant bit. */
+    public int i() { return i; }
+
+    public boolean isHardened() {
+        return hasHardenedBit(i);
     }
 
-    private static boolean hasPrivateBit(int a) {
-        return (a & PRIV_BIT) != 0;
+    private static boolean hasHardenedBit(int a) {
+        return (a & HARDENED_BIT) != 0;
     }
 
-    /**
-     * @return the child number without the private/public derivation bit set.
-     */
-    public int getChildNumber() {
-        return i & (~PRIV_BIT);
+    /** Returns the child number without the hardening bit set (i.e. index in that part of the tree). */
+    public int num() {
+        return i & (~HARDENED_BIT);
     }
 
     public String toString() {
-        return String.format("%d%s", getChildNumber(), isPrivateDerivation() ? "'" : "");
+        return String.format("%d%s", num(), isHardened() ? "'" : "");
     }
 
     @Override
diff --git a/core/src/main/java/com/google/bitcoin/crypto/DeterministicHierarchy.java b/core/src/main/java/com/google/bitcoin/crypto/DeterministicHierarchy.java
index e7ae180..540163a 100644
--- a/core/src/main/java/com/google/bitcoin/crypto/DeterministicHierarchy.java
+++ b/core/src/main/java/com/google/bitcoin/crypto/DeterministicHierarchy.java
@@ -25,6 +25,9 @@ import java.util.Map;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
+// TODO: This whole API feels a bit object heavy. Do we really need ChildNumber and so many maps, etc?
+// TODO: Should we be representing this using an actual tree arrangement in memory instead of a bunch of hashmaps?
+
 /**
  * <p>A DeterministicHierarchy calculates and keeps a whole tree (hierarchy) of keys originating from a single
  * root key. This implements part of the BIP 32 specification. A deterministic key tree is useful because
@@ -46,8 +49,8 @@ public class DeterministicHierarchy implements Serializable {
 
     private final Map<ImmutableList<ChildNumber>, DeterministicKey> keys = Maps.newHashMap();
     private final ImmutableList<ChildNumber> rootPath;
-    private final Map<ImmutableList<ChildNumber>, ChildNumber> lastPrivDerivedNumbers = Maps.newHashMap();
-    private final Map<ImmutableList<ChildNumber>, ChildNumber> lastPubDerivedNumbers = Maps.newHashMap();
+    // Keep track of how many child keys each node has. This is kind of weak.
+    private final Map<ImmutableList<ChildNumber>, ChildNumber> lastChildNumbers = Maps.newHashMap();
 
     /**
      * Constructs a new hierarchy rooted at the given key. Note that this does not have to be the top of the tree.
@@ -55,11 +58,21 @@ public class DeterministicHierarchy implements Serializable {
      */
     public DeterministicHierarchy(DeterministicKey rootKey) {
         putKey(rootKey);
-        rootPath = rootKey.getChildNumberPath();
+        rootPath = rootKey.getPath();
     }
 
-    private void putKey(DeterministicKey key) {
-        keys.put(key.getChildNumberPath(), key);
+    /**
+     * Inserts a key into the heirarchy. Used during deserialization: you normally don't need this. Keys must be
+     * inserted in order.
+     */
+    public void putKey(DeterministicKey key) {
+        ImmutableList<ChildNumber> path = key.getPath();
+        // Update our tracking of what the next child in each branch of the tree should be. Just assume that keys are
+        // inserted in order here.
+        final DeterministicKey parent = key.getParent();
+        if (parent != null)
+            lastChildNumbers.put(parent.getPath(), key.getChildNumber());
+        keys.put(path, key);
     }
 
     /**
@@ -76,7 +89,9 @@ public class DeterministicHierarchy implements Serializable {
                 ? ImmutableList.<ChildNumber>builder().addAll(rootPath).addAll(path).build()
                 : ImmutableList.copyOf(path);
         if (!keys.containsKey(absolutePath)) {
-            checkArgument(create, "No key found for {} path {}.", relativePath ? "relative" : "absolute", path);
+            if (!create)
+                throw new IllegalArgumentException(String.format("No key found for %s path %s.",
+                    relativePath ? "relative" : "absolute", HDUtils.formatPath(path)));
             checkArgument(absolutePath.size() > 0, "Can't derive the master key: nothing to derive from.");
             DeterministicKey parent = get(absolutePath.subList(0, absolutePath.size() - 1), relativePath, true);
             putKey(HDKeyDerivation.deriveChildKey(parent, absolutePath.get(absolutePath.size() - 1)));
@@ -100,7 +115,7 @@ public class DeterministicHierarchy implements Serializable {
         int nAttempts = 0;
         while (nAttempts++ < MAX_CHILD_DERIVATION_ATTEMPTS) {
             try {
-                ChildNumber createChildNumber = getNextChildNumberToDerive(parent.getChildNumberPath(), privateDerivation);
+                ChildNumber createChildNumber = getNextChildNumberToDerive(parent.getPath(), privateDerivation);
                 return deriveChild(parent, createChildNumber);
             } catch (HDDerivationException ignore) { }
         }
@@ -108,13 +123,20 @@ public class DeterministicHierarchy implements Serializable {
     }
 
     private ChildNumber getNextChildNumberToDerive(ImmutableList<ChildNumber> path, boolean privateDerivation) {
-        Map<ImmutableList<ChildNumber>, ChildNumber> lastDerivedNumbers = getLastDerivedNumbers(privateDerivation);
-        ChildNumber lastChildNumber = lastDerivedNumbers.get(path);
-        ChildNumber nextChildNumber = new ChildNumber(lastChildNumber != null ? lastChildNumber.getChildNumber() + 1 : 0, privateDerivation);
-        lastDerivedNumbers.put(path, nextChildNumber);
+        ChildNumber lastChildNumber = lastChildNumbers.get(path);
+        ChildNumber nextChildNumber = new ChildNumber(lastChildNumber != null ? lastChildNumber.num() + 1 : 0, privateDerivation);
+        lastChildNumbers.put(path, nextChildNumber);
         return nextChildNumber;
     }
 
+    public int getNumChildren(ImmutableList<ChildNumber> path) {
+        final ChildNumber cn = lastChildNumbers.get(path);
+        if (cn == null)
+            return 0;
+        else
+            return cn.num() + 1;   // children start with zero based childnumbers
+    }
+
     /**
      * Extends the tree by calculating the requested child for the given path. For example, to get the key at position
      * 1/2/3 you would pass 1/2 as the parent path and 3 as the child number.
@@ -141,8 +163,4 @@ public class DeterministicHierarchy implements Serializable {
     public DeterministicKey getRootKey() {
         return get(rootPath, false, false);
     }
-
-    private Map<ImmutableList<ChildNumber>, ChildNumber> getLastDerivedNumbers(boolean privateDerivation) {
-        return privateDerivation ? lastPrivDerivedNumbers : lastPubDerivedNumbers;
-    }
 }
diff --git a/core/src/main/java/com/google/bitcoin/crypto/DeterministicKey.java b/core/src/main/java/com/google/bitcoin/crypto/DeterministicKey.java
index 540eb1c..7351007 100644
--- a/core/src/main/java/com/google/bitcoin/crypto/DeterministicKey.java
+++ b/core/src/main/java/com/google/bitcoin/crypto/DeterministicKey.java
@@ -15,54 +15,80 @@
  */
 package com.google.bitcoin.crypto;
 
-import com.google.bitcoin.core.Base58;
-import com.google.bitcoin.core.ECKey;
-import com.google.bitcoin.core.Utils;
-import com.google.common.base.Joiner;
+import com.google.bitcoin.core.*;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Iterables;
+import org.spongycastle.crypto.params.KeyParameter;
 import org.spongycastle.math.ec.ECPoint;
 import org.spongycastle.util.encoders.Hex;
 
 import javax.annotation.Nullable;
-import java.io.Serializable;
 import java.math.BigInteger;
 import java.nio.ByteBuffer;
-import java.text.MessageFormat;
 import java.util.Arrays;
-import java.util.Collections;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-
-// TODO: Merge this with a redesigned ECKey class.
+import static com.google.common.base.Preconditions.*;
 
 /**
  * A deterministic key is a node in a {@link DeterministicHierarchy}. As per
- * <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">the BIP 32 specification</a> it is a pair (key, chaincode). If you
- * know its path in the tree you can derive more keys from this.
+ * <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">the BIP 32 specification</a> it is a pair
+ * (key, chaincode). If you know its path in the tree and its chain code you can derive more keys from this. To obtain
+ * one of these, you can call {@link HDKeyDerivation#createMasterPrivateKey(byte[])}.
  */
-public class DeterministicKey implements Serializable {
+public class DeterministicKey extends ECKey {
     private static final long serialVersionUID = 1L;
-    private static final Joiner PATH_JOINER = Joiner.on("/");
 
     private final DeterministicKey parent;
-    private ECPoint publicAsPoint;
-    private final BigInteger privateAsFieldElement;
     private final ImmutableList<ChildNumber> childNumberPath;
 
     /** 32 bytes */
     private final byte[] chainCode;
 
-    DeterministicKey(ImmutableList<ChildNumber> childNumberPath, byte[] chainCode,
-                     @Nullable ECPoint publicAsPoint, @Nullable BigInteger privateKeyFieldElt,
-                     @Nullable DeterministicKey parent) {
+    /** The 4 byte header that serializes in base58 to "xpub" */
+    public static final int HEADER_PUB = 0x0488B21E;
+    /** The 4 byte header that serializes in base58 to "xprv" */
+    public static final int HEADER_PRIV = 0x0488ADE4;
+
+    /** Constructs a key from its components. This is not normally something you should use. */
+    public DeterministicKey(ImmutableList<ChildNumber> childNumberPath,
+                            byte[] chainCode,
+                            ECPoint publicAsPoint,
+                            @Nullable BigInteger priv,
+                            @Nullable DeterministicKey parent) {
+        super(priv, compressPoint(checkNotNull(publicAsPoint)));
+        checkArgument(chainCode.length == 32);
+        this.parent = parent;
+        this.childNumberPath = checkNotNull(childNumberPath);
+        this.chainCode = Arrays.copyOf(chainCode, chainCode.length);
+    }
+
+    /** Constructs a key from its components. This is not normally something you should use. */
+    public DeterministicKey(ImmutableList<ChildNumber> childNumberPath,
+                            byte[] chainCode,
+                            BigInteger priv,
+                            @Nullable DeterministicKey parent) {
+        super(priv, compressPoint(ECKey.CURVE.getG().multiply(priv)));
         checkArgument(chainCode.length == 32);
         this.parent = parent;
-        this.childNumberPath = childNumberPath;
+        this.childNumberPath = checkNotNull(childNumberPath);
         this.chainCode = Arrays.copyOf(chainCode, chainCode.length);
-        this.publicAsPoint = publicAsPoint == null ? null : publicAsPoint.normalize();
-        this.privateAsFieldElement = privateKeyFieldElt;
+    }
+
+    /** Constructs a key from its components. This is not normally something you should use. */
+    public DeterministicKey(ImmutableList<ChildNumber> childNumberPath,
+                            byte[] chainCode,
+                            KeyCrypter crypter, ECPoint pub, EncryptedData priv, @Nullable DeterministicKey parent) {
+        this(childNumberPath, chainCode, pub, null, parent);
+        this.encryptedPrivateKey = checkNotNull(priv);
+        this.keyCrypter = checkNotNull(crypter);
+    }
+
+    /** Clones the key */
+    public DeterministicKey(DeterministicKey keyToClone, DeterministicKey newParent) {
+        super(keyToClone.priv, keyToClone.pub);
+        this.parent = newParent;
+        this.childNumberPath = keyToClone.childNumberPath;
+        this.chainCode = keyToClone.chainCode;
+        this.encryptedPrivateKey = keyToClone.encryptedPrivateKey;
     }
 
     /**
@@ -70,17 +96,22 @@ public class DeterministicKey implements Serializable {
      * A path can be written as 1/2/1 which means the first child of the root, the second child of that node, then
      * the first child of that node.
      */
-    public ImmutableList<ChildNumber> getChildNumberPath() {
+    public ImmutableList<ChildNumber> getPath() {
         return childNumberPath;
     }
 
+    /**
+     * Returns the path of this key as a human readable string starting with M to indicate the master key.
+     */
+    public String getPathAsString() {
+        return HDUtils.formatPath(getPath());
+    }
+
     private int getDepth() {
         return childNumberPath.size();
     }
 
-    /**
-     * Returns the last element of the path returned by {@link DeterministicKey#getChildNumberPath()}
-     */
+    /** Returns the last element of the path returned by {@link DeterministicKey#getPath()} */
     public ChildNumber getChildNumber() {
         return getDepth() == 0 ? ChildNumber.ZERO : childNumberPath.get(childNumberPath.size() - 1);
     }
@@ -93,32 +124,12 @@ public class DeterministicKey implements Serializable {
     }
 
     /**
-     * Returns the path of this key as a human readable string starting with M to indicate the master key.
-     */
-    public String getPath() {
-        return PATH_JOINER.join(Iterables.concat(Collections.singleton("M"), getChildNumberPath()));
-    }
-
-    /**
      * Returns RIPE-MD160(SHA256(pub key bytes)).
      */
     public byte[] getIdentifier() {
-        return Utils.sha256hash160(getPubKeyBytes());
+        return Utils.sha256hash160(getPubKey());
     }
 
-    ECPoint getPubPoint() {
-        if (publicAsPoint == null) {
-            checkNotNull(privateAsFieldElement);
-            publicAsPoint = ECKey.CURVE.getG().multiply(privateAsFieldElement).normalize();
-        }
-        return publicAsPoint;
-    }
-
-    public byte[] getPubKeyBytes() {
-        return getPubPoint().getEncoded(true);
-    }
-
-
     /** Returns the first 32 bits of the result of {@link #getIdentifier()}. */
     public byte[] getFingerprint() {
         // TODO: why is this different than armory's fingerprint? BIP 32: "The first 32 bits of the identifier are called the fingerprint."
@@ -126,29 +137,17 @@ public class DeterministicKey implements Serializable {
     }
 
     @Nullable
-    public BigInteger getPrivAsFieldElement() {
-        return privateAsFieldElement;
-    }
-
-    @Nullable
     public DeterministicKey getParent() {
         return parent;
     }
 
     /**
-     * Returns the private key bytes, if they were provided during construction.
-     */
-    @Nullable
-    public byte[] getPrivKeyBytes() {
-        return privateAsFieldElement == null ? null : privateAsFieldElement.toByteArray();
-    }
-
-    /**
-     * @return private key bytes, padded with zeros to 33 bytes.
+     * Returns private key bytes, padded with zeros to 33 bytes.
+     * @throws java.lang.IllegalStateException if the private key bytes are missing.
      */
     public byte[] getPrivKeyBytes33() {
         byte[] bytes33 = new byte[33];
-        byte[] priv = checkNotNull(getPrivKeyBytes(), "Private key missing");
+        byte[] priv = getPrivKeyBytes();
         System.arraycopy(priv, 0, bytes33, 33 - priv.length, priv.length);
         return bytes33;
     }
@@ -157,38 +156,148 @@ public class DeterministicKey implements Serializable {
      * Returns the same key with the private part removed. May return the same instance.
      */
     public DeterministicKey getPubOnly() {
-        if (!hasPrivate()) return this;
-        final DeterministicKey parentPub = getParent() == null ? null : getParent().getPubOnly();
-        return new DeterministicKey(getChildNumberPath(), getChainCode(), getPubPoint(), null, parentPub);
+        if (isPubKeyOnly()) return this;
+        //final DeterministicKey parentPub = getParent() == null ? null : getParent().getPubOnly();
+        return new DeterministicKey(getPath(), getChainCode(), getPubKeyPoint(), null, parent);
     }
 
-    public boolean hasPrivate() {
-        return privateAsFieldElement != null;
+
+    static byte[] addChecksum(byte[] input) {
+        int inputLength = input.length;
+        byte[] checksummed = new byte[inputLength + 4];
+        System.arraycopy(input, 0, checksummed, 0, inputLength);
+        byte[] checksum = Utils.doubleDigest(input);
+        System.arraycopy(checksum, 0, checksummed, inputLength, 4);
+        return checksummed;
     }
 
-    public ECKey toECKey() {
-        return new ECKey(getPrivKeyBytes(), getPubKeyBytes());
+    @Override
+    public DeterministicKey encrypt(KeyCrypter keyCrypter, KeyParameter aesKey) throws KeyCrypterException {
+        throw new UnsupportedOperationException("Must supply a new parent for encryption");
     }
 
-    public String serializePubB58() {
-        return toBase58(serialize(true));
+    public DeterministicKey encrypt(KeyCrypter keyCrypter, KeyParameter aesKey, @Nullable DeterministicKey newParent) throws KeyCrypterException {
+        // Same as the parent code, except we construct a DeterministicKey instead of an ECKey.
+        checkNotNull(keyCrypter);
+        if (newParent != null)
+            checkArgument(newParent.isEncrypted());
+        final byte[] privKeyBytes = getPrivKeyBytes();
+        checkState(privKeyBytes != null, "Private key is not available");
+        EncryptedData encryptedPrivateKey = keyCrypter.encrypt(privKeyBytes, aesKey);
+        return new DeterministicKey(childNumberPath, chainCode, keyCrypter, pub, encryptedPrivateKey, newParent);
     }
 
-    public String serializePrivB58() {
-        return toBase58(serialize(false));
+    /**
+     * A deterministic key is considered to be encrypted if it has access to encrypted private key bytes, OR if its
+     * parent does. The reason is because the parent would be encrypted under the same key and this key knows how to
+     * rederive its own private key bytes from the parent, if needed.
+     */
+    @Override
+    public boolean isEncrypted() {
+        return priv == null && (super.isEncrypted() || (parent != null && parent.isEncrypted()));
     }
 
-    static String toBase58(byte[] ser) {
-        return Base58.encode(addChecksum(ser));
+    /**
+     * Returns this keys {@link com.google.bitcoin.crypto.KeyCrypter} <b>or</b> the keycrypter of its parent key.
+     */
+    @Override @Nullable
+    public KeyCrypter getKeyCrypter() {
+        if (keyCrypter != null)
+            return keyCrypter;
+        else if (parent != null)
+            return parent.getKeyCrypter();
+        else
+            return null;
     }
 
-    static byte[] addChecksum(byte[] input) {
-        int inputLength = input.length;
-        byte[] checksummed = new byte[inputLength + 4];
-        System.arraycopy(input, 0, checksummed, 0, inputLength);
-        byte[] checksum = Utils.doubleDigest(input);
-        System.arraycopy(checksum, 0, checksummed, inputLength, 4);
-        return checksummed;
+    @Override
+    public ECDSASignature sign(Sha256Hash input, @Nullable KeyParameter aesKey) throws KeyCrypterException {
+        if (isEncrypted()) {
+            // If the key is encrypted, ECKey.sign will decrypt it first before rerunning sign. Decryption walks the
+            // key heirarchy to find the private key (see below), so, we can just run the inherited method.
+            return super.sign(input, aesKey);
+        } else {
+            // If it's not encrypted, derive the private via the parents.
+            final BigInteger privateKey = findOrDerivePrivateKey();
+            if (privateKey == null) {
+                // This key is a part of a public-key only heirarchy and cannot be used for signing
+                throw new MissingPrivateKeyException();
+            }
+            return super.doSign(input, privateKey);
+        }
+    }
+
+    @Override
+    public DeterministicKey decrypt(KeyCrypter keyCrypter, KeyParameter aesKey) throws KeyCrypterException {
+        checkNotNull(keyCrypter);
+        // Check that the keyCrypter matches the one used to encrypt the keys, if set.
+        if (this.keyCrypter != null && !this.keyCrypter.equals(keyCrypter))
+            throw new KeyCrypterException("The keyCrypter being used to decrypt the key is different to the one that was used to encrypt it");
+        BigInteger privKey = findOrDeriveEncryptedPrivateKey(keyCrypter, aesKey);
+        DeterministicKey key = new DeterministicKey(childNumberPath, chainCode, privKey, parent);
+        if (!Arrays.equals(key.getPubKey(), getPubKey()))
+            throw new KeyCrypterException("Provided AES key is wrong");
+        return key;
+    }
+
+    // For when a key is encrypted, either decrypt our encrypted private key bytes, or work up the tree asking parents
+    // to decrypt and re-derive.
+    private BigInteger findOrDeriveEncryptedPrivateKey(KeyCrypter keyCrypter, KeyParameter aesKey) {
+        if (encryptedPrivateKey != null)
+            return new BigInteger(1, keyCrypter.decrypt(encryptedPrivateKey, aesKey));
+        // Otherwise we don't have it, but maybe we can figure it out from our parents. Walk up the tree looking for
+        // the first key that has some encrypted private key data.
+        DeterministicKey cursor = parent;
+        while (cursor != null) {
+            if (cursor.encryptedPrivateKey != null) break;
+            cursor = cursor.parent;
+        }
+        if (cursor == null)
+            throw new KeyCrypterException("Neither this key nor its parents have an encrypted private key");
+        byte[] parentalPrivateKeyBytes = keyCrypter.decrypt(cursor.encryptedPrivateKey, aesKey);
+        return derivePrivateKeyDownwards(cursor, parentalPrivateKeyBytes);
+    }
+
+    @Nullable
+    private BigInteger findOrDerivePrivateKey() {
+        DeterministicKey cursor = this;
+        while (cursor != null) {
+            if (cursor.priv != null) break;
+            cursor = cursor.parent;
+        }
+        if (cursor == null)
+            return null;
+        return derivePrivateKeyDownwards(cursor, cursor.priv.toByteArray());
+    }
+
+    private BigInteger derivePrivateKeyDownwards(DeterministicKey cursor, byte[] parentalPrivateKeyBytes) {
+        DeterministicKey downCursor = new DeterministicKey(cursor.childNumberPath, cursor.chainCode,
+                cursor.pub, new BigInteger(1, parentalPrivateKeyBytes), cursor.parent);
+        // Now we have to rederive the keys along the path back to ourselves. That path can be found by just truncating
+        // our path with the length of the parents path.
+        ImmutableList<ChildNumber> path = childNumberPath.subList(cursor.getDepth(), childNumberPath.size());
+        for (ChildNumber num : path) {
+            downCursor = HDKeyDerivation.deriveChildKey(downCursor, num);
+        }
+        // downCursor is now the same key as us, but with private key bytes.
+        checkState(downCursor.pub.equals(pub));
+        return checkNotNull(downCursor.priv);
+    }
+
+    public DeterministicKey derive(int child) {
+        return HDKeyDerivation.deriveChildKey(this, new ChildNumber(child, true));
+    }
+
+    /**
+     * Returns the private key of this deterministic key. Even if this object isn't storing the private key,
+     * it can be re-derived by walking up to the parents if necessary and this is what will happen.
+     * @throws java.lang.IllegalStateException if the parents are encrypted or a watching chain.
+     */
+    @Override
+    public BigInteger getPrivKey() {
+        final BigInteger key = findOrDerivePrivateKey();
+        checkState(key != null, "Private key bytes not available");
+        return key;
     }
 
     public byte[] serializePublic() {
@@ -201,23 +310,111 @@ public class DeterministicKey implements Serializable {
 
     private byte[] serialize(boolean pub) {
         ByteBuffer ser = ByteBuffer.allocate(78);
-        ser.putInt(pub ? 0x0488B21E : 0x0488ADE4);
+        ser.putInt(pub ? HEADER_PUB : HEADER_PRIV);
         ser.put((byte) getDepth());
         if (parent == null) {
             ser.putInt(0);
         } else {
             ser.put(parent.getFingerprint());
         }
-        ser.putInt(getChildNumber().getI());
+        ser.putInt(getChildNumber().i());
         ser.put(getChainCode());
-        ser.put(pub ? getPubKeyBytes() : getPrivKeyBytes33());
-        assert ser.position() == 78;
-
+        ser.put(pub ? getPubKey() : getPrivKeyBytes33());
+        checkState(ser.position() == 78);
         return ser.array();
     }
 
+    public String serializePubB58() {
+        return toBase58(serialize(true));
+    }
+
+    public String serializePrivB58() {
+        return toBase58(serialize(false));
+    }
+
+    static String toBase58(byte[] ser) {
+        return Base58.encode(addChecksum(ser));
+    }
+
+    public static DeterministicKey deserializeB58(@Nullable DeterministicKey parent, String base58) {
+        try {
+            ByteBuffer buffer = ByteBuffer.wrap(Base58.decodeChecked(base58));
+            int header = buffer.getInt();
+            if (header != HEADER_PRIV && header != HEADER_PUB)
+                throw new IllegalArgumentException("Unknown header bytes: " + base58.substring(0, 4));
+            boolean pub = header == HEADER_PUB;
+            byte depth = buffer.get();
+            byte[] parentFingerprint = new byte[4];
+            buffer.get(parentFingerprint);
+            final int i = buffer.getInt();
+            final ChildNumber childNumber = new ChildNumber(i);
+            ImmutableList<ChildNumber> path;
+            if (parent != null) {
+                if (Arrays.equals(parentFingerprint, HDUtils.longTo4ByteArray(0)))
+                    throw new IllegalArgumentException("Parent was provided but this key doesn't have one");
+                if (!Arrays.equals(parent.getFingerprint(), parentFingerprint))
+                    throw new IllegalArgumentException("Parent fingerprints don't match");
+                path = HDUtils.append(parent.getPath(), childNumber);
+                if (path.size() != depth)
+                    throw new IllegalArgumentException("Depth does not match");
+            } else {
+                if (depth == 0) {
+                    path = ImmutableList.of();
+                } else if (depth == 1) {
+                    // We have been given a key that is not a root key, yet we also don't have any object representing
+                    // the parent. This can happen when deserializing an account key for a watching wallet. In this case,
+                    // we assume that the parent has a path of zero.
+                    path = ImmutableList.of(childNumber);
+                } else {
+                    throw new IllegalArgumentException("Depth is " + depth + " and no parent key was provided, so we " +
+                        "cannot reconstruct the key path from the provided data.");
+                }
+            }
+            byte[] chainCode = new byte[32];
+            buffer.get(chainCode);
+            byte[] data = new byte[33];
+            buffer.get(data);
+            checkArgument(!buffer.hasRemaining(), "Found unexpected data in key");
+            if (pub) {
+                ECPoint point = ECKey.CURVE.getCurve().decodePoint(data);
+                return new DeterministicKey(path, chainCode, point, null, parent);
+            } else {
+                return new DeterministicKey(path, chainCode, new BigInteger(1, data), parent);
+            }
+        } catch (AddressFormatException e) {
+            throw new IllegalArgumentException(e);
+        }
+    }
+
+    /**
+     * Verifies equality of all fields but NOT the parent pointer (thus the same key derived in two separate heirarchy
+     * objects will equal each other.
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+
+        DeterministicKey key = (DeterministicKey) o;
+
+        if (!Arrays.equals(chainCode, key.chainCode)) return false;
+        if (!childNumberPath.equals(key.childNumberPath)) return false;
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode();
+        result = 31 * result + childNumberPath.hashCode();
+        result = 31 * result + Arrays.hashCode(chainCode);
+        return result;
+    }
+
     @Override
     public String toString() {
-        return MessageFormat.format("ExtendedHierarchicKey[pub: {0}]", new String(Hex.encode(getPubKeyBytes())));
+        return String.format("pub:%s chaincode:%s path:%s", new String(Hex.encode(getPubKey())),
+                new String(Hex.encode(getChainCode())), getPathAsString());
     }
 }
diff --git a/core/src/main/java/com/google/bitcoin/crypto/EncryptableItem.java b/core/src/main/java/com/google/bitcoin/crypto/EncryptableItem.java
new file mode 100644
index 0000000..4a4bb96
--- /dev/null
+++ b/core/src/main/java/com/google/bitcoin/crypto/EncryptableItem.java
@@ -0,0 +1,43 @@
+/**
+ * Copyright 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.bitcoin.crypto;
+
+import org.bitcoinj.wallet.Protos;
+
+import javax.annotation.Nullable;
+
+/**
+ * Provides a uniform way to access something that can be optionally encrypted with a
+ * {@link com.google.bitcoin.crypto.KeyCrypter}, yielding an {@link com.google.bitcoin.crypto.EncryptedData}, and
+ * which can have a creation time associated with it.
+ */
+public interface EncryptableItem {
+    /** Returns whether the item is encrypted or not. If it is, then {@link #getSecretBytes()} will return null. */
+    public boolean isEncrypted();
+
+    /** Returns the raw bytes of the item, if not encrypted, or null if encrypted or the secret is missing. */
+    @Nullable public byte[] getSecretBytes();
+
+    /** Returns the initialization vector and encrypted secret bytes, or null if not encrypted. */
+    @Nullable public EncryptedData getEncryptedData();
+
+    /** Returns an enum constant describing what algorithm was used to encrypt the key or UNENCRYPTED. */
+    public Protos.Wallet.EncryptionType getEncryptionType();
+
+    /** Returns the time in seconds since the UNIX epoch at which this encryptable item was first created/derived. */
+    public long getCreationTimeSeconds();
+}
diff --git a/core/src/main/java/com/google/bitcoin/crypto/EncryptedData.java b/core/src/main/java/com/google/bitcoin/crypto/EncryptedData.java
new file mode 100644
index 0000000..b596e2f
--- /dev/null
+++ b/core/src/main/java/com/google/bitcoin/crypto/EncryptedData.java
@@ -0,0 +1,56 @@
+/**
+ * Copyright 2013 Jim Burton.
+ *
+ * Licensed under the MIT license (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://opensource.org/licenses/mit-license.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.bitcoin.crypto;
+
+import java.util.Arrays;
+
+/**
+ * <p>An instance of EncryptedData is a holder for an initialization vector and encrypted bytes. It is typically
+ * used to hold encrypted private key bytes.</p>
+ *
+ * <p>The initialisation vector is random data that is used to initialise the AES block cipher when the
+ * private key bytes were encrypted. You need these for decryption.</p>
+ */
+public final class EncryptedData {
+    public final byte[] initialisationVector;
+    public final byte[] encryptedBytes;
+
+    public EncryptedData(byte[] initialisationVector, byte[] encryptedBytes) {
+        this.initialisationVector = Arrays.copyOf(initialisationVector, initialisationVector.length);
+        this.encryptedBytes = Arrays.copyOf(encryptedBytes, encryptedBytes.length);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        EncryptedData that = (EncryptedData) o;
+        return Arrays.equals(encryptedBytes, that.encryptedBytes) && Arrays.equals(initialisationVector, that.initialisationVector);
+
+    }
+
+    @Override
+    public int hashCode() {
+        int result = Arrays.hashCode(initialisationVector);
+        result = 31 * result + Arrays.hashCode(encryptedBytes);
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "EncryptedData [initialisationVector=" + Arrays.toString(initialisationVector) + ", encryptedPrivateKey=" + Arrays.toString(encryptedBytes) + "]";
+    }
+}
diff --git a/core/src/main/java/com/google/bitcoin/crypto/EncryptedPrivateKey.java b/core/src/main/java/com/google/bitcoin/crypto/EncryptedPrivateKey.java
deleted file mode 100644
index 2fa5f90..0000000
--- a/core/src/main/java/com/google/bitcoin/crypto/EncryptedPrivateKey.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/**
- * Copyright 2013 Jim Burton.
- *
- * Licensed under the MIT license (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://opensource.org/licenses/mit-license.php
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.bitcoin.crypto;
-
-import java.util.Arrays;
-
-/**
- * <p>An EncryptedPrivateKey contains the information produced after encrypting the private key bytes of an ECKey.</p>
- *
- * <p>It contains two member variables - initialisationVector and encryptedPrivateBytes. The initialisationVector is
- * a randomly chosen list of bytes that were used to initialise the AES block cipher when the private key bytes were encrypted.
- * You need these for decryption. The encryptedPrivateBytes are the result of AES encrypting the private keys using
- * an AES key that is derived from a user entered password. You need the password to recreate the AES key in order
- * to decrypt these bytes.</p>
- */
-public class EncryptedPrivateKey {
-
-    private byte[] initialisationVector = null;
-    private byte[] encryptedPrivateBytes = null;
-
-    /**
-     * Cloning constructor.
-     * @param encryptedPrivateKey EncryptedPrivateKey to clone.
-     */
-    public EncryptedPrivateKey(EncryptedPrivateKey encryptedPrivateKey) {
-        setInitialisationVector(encryptedPrivateKey.getInitialisationVector());
-        setEncryptedPrivateBytes(encryptedPrivateKey.getEncryptedBytes());
-    }
-
-    /**
-     * @param iv
-     * @param encryptedPrivateKeys
-     */
-    public EncryptedPrivateKey(byte[] initialisationVector, byte[] encryptedPrivateKeys) {
-        setInitialisationVector(initialisationVector);
-        setEncryptedPrivateBytes(encryptedPrivateKeys);
-    }
-
-    public byte[] getInitialisationVector() {
-        return initialisationVector;
-    }
-
-    /**
-     * Set the initialisationVector, cloning the bytes.
-     *
-     * @param initialisationVector
-     */
-    public void setInitialisationVector(byte[] initialisationVector) {
-        if (initialisationVector == null) {
-            this.initialisationVector = null;
-            return;
-        }
-
-        byte[] cloneIV = new byte[initialisationVector.length];
-        System.arraycopy(initialisationVector, 0, cloneIV, 0, initialisationVector.length);
-
-        this.initialisationVector = cloneIV;
-    }
-
-    public byte[] getEncryptedBytes() {
-        return encryptedPrivateBytes;
-    }
-
-    /**
-     * Set the encrypted private key bytes, cloning them.
-     *
-     * @param encryptedPrivateBytes
-     */
-    public void setEncryptedPrivateBytes(byte[] encryptedPrivateBytes) {
-        if (encryptedPrivateBytes == null) {
-            this.encryptedPrivateBytes = null;
-            return;
-        }
-
-        this.encryptedPrivateBytes = Arrays.copyOf(encryptedPrivateBytes, encryptedPrivateBytes.length);
-    }
-
-    @Override
-    public EncryptedPrivateKey clone() {
-        return new EncryptedPrivateKey(getInitialisationVector(), getEncryptedBytes());
-    }
-
-    @Override
-    public int hashCode() {
-        return com.google.common.base.Objects.hashCode(encryptedPrivateBytes, initialisationVector);
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (obj == null) {
-            return false;
-        }
-        if (getClass() != obj.getClass()) {
-            return false;
-        }
-        final EncryptedPrivateKey other = (EncryptedPrivateKey) obj;
-
-        return com.google.common.base.Objects.equal(this.initialisationVector, other.initialisationVector)
-                && com.google.common.base.Objects.equal(this.encryptedPrivateBytes, other.encryptedPrivateBytes);
-    }
-
-    @Override
-    public String toString() {
-        return "EncryptedPrivateKey [initialisationVector=" + Arrays.toString(initialisationVector) + ", encryptedPrivateKey=" + Arrays.toString(encryptedPrivateBytes) + "]";
-    }
-
-    /**
-     * Clears all the EncryptedPrivateKey contents from memory (overwriting all data including PRIVATE KEYS).
-     * WARNING - this method irreversibly deletes the private key information.
-     */
-    public void clear() {
-        if (encryptedPrivateBytes != null) {
-            Arrays.fill(encryptedPrivateBytes, (byte)0);
-        }
-        if (initialisationVector != null) {
-            Arrays.fill(initialisationVector, (byte)0);
-        }
-    }
-}
diff --git a/core/src/main/java/com/google/bitcoin/crypto/HDKeyDerivation.java b/core/src/main/java/com/google/bitcoin/crypto/HDKeyDerivation.java
index 7164495..2c4fc2b 100644
--- a/core/src/main/java/com/google/bitcoin/crypto/HDKeyDerivation.java
+++ b/core/src/main/java/com/google/bitcoin/crypto/HDKeyDerivation.java
@@ -29,7 +29,8 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
 
 /**
- * Implementation of the (public derivation version) deterministic wallet child key generation algorithm.
+ * Implementation of the <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32</a>
+ * deterministic wallet child key generation algorithm.
  */
 public final class HDKeyDerivation {
 
@@ -65,12 +66,11 @@ public final class HDKeyDerivation {
     /**
      * @throws HDDerivationException if privKeyBytes is invalid (0 or >= n).
      */
-    public static DeterministicKey createMasterPrivKeyFromBytes(
-            byte[] privKeyBytes, byte[] chainCode) throws HDDerivationException {
-        BigInteger privateKeyFieldElt = new BigInteger(1, privKeyBytes);
-        assertNonZero(privateKeyFieldElt, "Generated master key is invalid.");
-        assertLessThanN(privateKeyFieldElt, "Generated master key is invalid.");
-        return new DeterministicKey(ImmutableList.<ChildNumber>of(), chainCode, null, privateKeyFieldElt, null);
+    public static DeterministicKey createMasterPrivKeyFromBytes(byte[] privKeyBytes, byte[] chainCode) throws HDDerivationException {
+        BigInteger priv = new BigInteger(1, privKeyBytes);
+        assertNonZero(priv, "Generated master key is invalid.");
+        assertLessThanN(priv, "Generated master key is invalid.");
+        return new DeterministicKey(ImmutableList.<ChildNumber>of(), chainCode, priv, null);
     }
 
     public static DeterministicKey createMasterPubKeyFromBytes(byte[] pubKeyBytes, byte[] chainCode) {
@@ -78,7 +78,8 @@ public final class HDKeyDerivation {
     }
 
     /**
-     * @param childNumber the "extended" child number, ie. with the 0x80000000 bit specifying private/public derivation.
+     * Derives a key given the "extended" child number, ie. with the 0x80000000 bit specifying whether to use hardened
+     * derivation or not.
      */
     public static DeterministicKey deriveChildKey(DeterministicKey parent, int childNumber) {
         return deriveChildKey(parent, new ChildNumber(childNumber));
@@ -88,49 +89,67 @@ public final class HDKeyDerivation {
      * @throws HDDerivationException if private derivation is attempted for a public-only parent key, or
      * if the resulting derived key is invalid (eg. private key == 0).
      */
-    public static DeterministicKey deriveChildKey(DeterministicKey parent, ChildNumber childNumber)
-            throws HDDerivationException {
-
-        RawKeyBytes rawKey = deriveChildKeyBytes(parent, childNumber);
-        return new DeterministicKey(
-                HDUtils.append(parent.getChildNumberPath(), childNumber),
-                rawKey.chainCode,
-                parent.hasPrivate() ? null : ECKey.CURVE.getCurve().decodePoint(rawKey.keyBytes),
-                parent.hasPrivate() ? new BigInteger(1, rawKey.keyBytes) : null,
-                parent);
+    public static DeterministicKey deriveChildKey(DeterministicKey parent, ChildNumber childNumber) throws HDDerivationException {
+        if (parent.isPubKeyOnly()) {
+            RawKeyBytes rawKey = deriveChildKeyBytesFromPublic(parent, childNumber);
+            return new DeterministicKey(
+                    HDUtils.append(parent.getPath(), childNumber),
+                    rawKey.chainCode,
+                    ECKey.CURVE.getCurve().decodePoint(rawKey.keyBytes),   // c'tor will compress
+                    null,
+                    parent);
+        } else {
+            RawKeyBytes rawKey = deriveChildKeyBytesFromPrivate(parent, childNumber);
+            return new DeterministicKey(
+                    HDUtils.append(parent.getPath(), childNumber),
+                    rawKey.chainCode,
+                    new BigInteger(1, rawKey.keyBytes),
+                    parent);
+        }
     }
 
-    private static RawKeyBytes deriveChildKeyBytes(DeterministicKey parent, ChildNumber childNumber)
-            throws HDDerivationException {
-
-        byte[] parentPublicKey = HDUtils.getBytes(parent.getPubPoint());
+    private static RawKeyBytes deriveChildKeyBytesFromPrivate(DeterministicKey parent,
+                                                              ChildNumber childNumber) throws HDDerivationException {
+        checkArgument(parent.hasPrivKey(), "Parent key must have private key bytes for this method.");
+        byte[] parentPublicKey = ECKey.compressPoint(parent.getPubKeyPoint()).getEncoded();
         assert parentPublicKey.length == 33 : parentPublicKey.length;
         ByteBuffer data = ByteBuffer.allocate(37);
-        if (childNumber.isPrivateDerivation()) {
+        if (childNumber.isHardened()) {
             data.put(parent.getPrivKeyBytes33());
         } else {
             data.put(parentPublicKey);
         }
-        data.putInt(childNumber.getI());
+        data.putInt(childNumber.i());
         byte[] i = HDUtils.hmacSha512(parent.getChainCode(), data.array());
         assert i.length == 64 : i.length;
         byte[] il = Arrays.copyOfRange(i, 0, 32);
         byte[] chainCode = Arrays.copyOfRange(i, 32, 64);
         BigInteger ilInt = new BigInteger(1, il);
         assertLessThanN(ilInt, "Illegal derived key: I_L >= n");
-        byte[] keyBytes;
-        final BigInteger privAsFieldElement = parent.getPrivAsFieldElement();
-        if (privAsFieldElement != null) {
-            BigInteger ki = privAsFieldElement.add(ilInt).mod(ECKey.CURVE.getN());
-            assertNonZero(ki, "Illegal derived key: derived private key equals 0.");
-            keyBytes = ki.toByteArray();
-        } else {
-            checkArgument(!childNumber.isPrivateDerivation(), "Can't use private derivation with public keys only.");
-            ECPoint Ki = ECKey.CURVE.getG().multiply(ilInt).add(parent.getPubPoint());
-            checkArgument(!Ki.isInfinity(), "Illegal derived key: derived public key equals infinity.");
-            keyBytes = Ki.getEncoded(true);
-        }
-        return new RawKeyBytes(keyBytes, chainCode);
+        final BigInteger priv = parent.getPrivKey();
+        BigInteger ki = priv.add(ilInt).mod(ECKey.CURVE.getN());
+        assertNonZero(ki, "Illegal derived key: derived private key equals 0.");
+        return new RawKeyBytes(ki.toByteArray(), chainCode);
+    }
+
+    private static RawKeyBytes deriveChildKeyBytesFromPublic(DeterministicKey parent, ChildNumber childNumber) throws HDDerivationException {
+        checkArgument(!childNumber.isHardened(), "Can't use private derivation with public keys only.");
+        byte[] parentPublicKey = ECKey.compressPoint(parent.getPubKeyPoint()).getEncoded();
+        assert parentPublicKey.length == 33 : parentPublicKey.length;
+        ByteBuffer data = ByteBuffer.allocate(37);
+        data.put(parentPublicKey);
+        data.putInt(childNumber.i());
+        byte[] i = HDUtils.hmacSha512(parent.getChainCode(), data.array());
+        assert i.length == 64 : i.length;
+        byte[] il = Arrays.copyOfRange(i, 0, 32);
+        byte[] chainCode = Arrays.copyOfRange(i, 32, 64);
+        BigInteger ilInt = new BigInteger(1, il);
+        // TODO: Throw a specific exception here to make sure the caller iterates.
+        assertLessThanN(ilInt, "Illegal derived key: I_L >= n");
+        ECPoint Ki = ECKey.CURVE.getG().multiply(ilInt).add(parent.getPubKeyPoint());
+        checkArgument(!Ki.equals(ECKey.CURVE.getCurve().getInfinity()),
+                "Illegal derived key: derived public key equals infinity.");
+        return new RawKeyBytes(Ki.getEncoded(true), chainCode);
     }
 
     private static void assertNonZero(BigInteger integer, String errorMessage) {
diff --git a/core/src/main/java/com/google/bitcoin/crypto/HDUtils.java b/core/src/main/java/com/google/bitcoin/crypto/HDUtils.java
index 99cb051..4cf991b 100644
--- a/core/src/main/java/com/google/bitcoin/crypto/HDUtils.java
+++ b/core/src/main/java/com/google/bitcoin/crypto/HDUtils.java
@@ -17,21 +17,23 @@
 package com.google.bitcoin.crypto;
 
 import com.google.bitcoin.core.ECKey;
+import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
 import org.spongycastle.crypto.digests.SHA512Digest;
 import org.spongycastle.crypto.macs.HMac;
 import org.spongycastle.crypto.params.KeyParameter;
-import org.spongycastle.math.ec.ECPoint;
 
 import java.nio.ByteBuffer;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 
 /**
  * Static utilities used in BIP 32 Hierarchical Deterministic Wallets (HDW).
  */
 public final class HDUtils {
-
-    private HDUtils() { }
+    private static final Joiner PATH_JOINER = Joiner.on("/");
 
     static HMac createHmacSha512Digest(byte[] key) {
         SHA512Digest digest = new SHA512Digest();
@@ -62,11 +64,11 @@ public final class HDUtils {
         return bytes;
     }
 
-    static byte[] getBytes(ECPoint pubKPoint) {
-        return pubKPoint.getEncoded(true);
+    public static ImmutableList<ChildNumber> append(ImmutableList<ChildNumber> path, ChildNumber childNumber) {
+        return ImmutableList.<ChildNumber>builder().addAll(path).add(childNumber).build();
     }
 
-    static ImmutableList<ChildNumber> append(ImmutableList<ChildNumber> path, ChildNumber childNumber) {
-        return ImmutableList.<ChildNumber>builder().addAll(path).add(childNumber).build();
+    public static String formatPath(List<ChildNumber> path) {
+        return PATH_JOINER.join(Iterables.concat(Collections.singleton("M"), path));
     }
 }
diff --git a/core/src/main/java/com/google/bitcoin/crypto/KeyCrypter.java b/core/src/main/java/com/google/bitcoin/crypto/KeyCrypter.java
index d855681..41c407f 100644
--- a/core/src/main/java/com/google/bitcoin/crypto/KeyCrypter.java
+++ b/core/src/main/java/com/google/bitcoin/crypto/KeyCrypter.java
@@ -15,23 +15,23 @@
  */
 package com.google.bitcoin.crypto;
 
-import java.io.Serializable;
-
 import org.bitcoinj.wallet.Protos.Wallet.EncryptionType;
 import org.spongycastle.crypto.params.KeyParameter;
 
+import java.io.Serializable;
+
 /**
  * <p>A KeyCrypter can be used to encrypt and decrypt a message. The sequence of events to encrypt and then decrypt
  * a message are as follows:</p>
  *
- *<p>(1) Ask the user for a password. deriveKey() is then called to create an KeyParameter. This contains the AES
- *key that will be used for encryption.</p>
- *<p>(2) Encrypt the message using encrypt(), providing the message bytes and the KeyParameter from (1). This returns
- *an EncryptedPrivateKey which contains the encryptedPrivateKey bytes and an initialisation vector.</p>
- *<p>(3) To decrypt an EncryptedPrivateKey, repeat step (1) to get a KeyParameter, then call decrypt().</p>
+ * <p>(1) Ask the user for a password. deriveKey() is then called to create an KeyParameter. This contains the AES
+ * key that will be used for encryption.</p>
+ * <p>(2) Encrypt the message using encrypt(), providing the message bytes and the KeyParameter from (1). This returns
+ * an EncryptedData which contains the encryptedPrivateKey bytes and an initialisation vector.</p>
+ * <p>(3) To decrypt an EncryptedData, repeat step (1) to get a KeyParameter, then call decrypt().</p>
  *
- *<p>There can be different algorithms used for encryption/ decryption so the getUnderstoodEncryptionType is used
- *to determine whether any given KeyCrypter can understand the type of encrypted data you have.</p>
+ * <p>There can be different algorithms used for encryption/ decryption so the getUnderstoodEncryptionType is used
+ * to determine whether any given KeyCrypter can understand the type of encrypted data you have.</p>
  */
 public interface KeyCrypter extends Serializable {
 
@@ -54,7 +54,7 @@ public interface KeyCrypter extends Serializable {
      *
      * @throws KeyCrypterException if decryption was unsuccessful.
      */
-    public byte[] decrypt(EncryptedPrivateKey encryptedBytesToDecode, KeyParameter aesKey) throws KeyCrypterException;
+    public byte[] decrypt(EncryptedData encryptedBytesToDecode, KeyParameter aesKey) throws KeyCrypterException;
 
     /**
      * Encrypt the supplied bytes, converting them into ciphertext.
@@ -62,5 +62,5 @@ public interface KeyCrypter extends Serializable {
      * @return encryptedPrivateKey An encryptedPrivateKey containing the encrypted bytes and an initialisation vector.
      * @throws KeyCrypterException if encryption was unsuccessful
      */
-    public EncryptedPrivateKey encrypt(byte[] plainBytes, KeyParameter aesKey) throws KeyCrypterException;
+    public EncryptedData encrypt(byte[] plainBytes, KeyParameter aesKey) throws KeyCrypterException;
 }
diff --git a/core/src/main/java/com/google/bitcoin/crypto/KeyCrypterScrypt.java b/core/src/main/java/com/google/bitcoin/crypto/KeyCrypterScrypt.java
index e0dcbdb..fbd9d5c 100644
--- a/core/src/main/java/com/google/bitcoin/crypto/KeyCrypterScrypt.java
+++ b/core/src/main/java/com/google/bitcoin/crypto/KeyCrypterScrypt.java
@@ -158,7 +158,7 @@ public class KeyCrypterScrypt implements KeyCrypter, Serializable {
      * Password based encryption using AES - CBC 256 bits.
      */
     @Override
-    public EncryptedPrivateKey encrypt(byte[] plainBytes, KeyParameter aesKey) throws KeyCrypterException {
+    public EncryptedData encrypt(byte[] plainBytes, KeyParameter aesKey) throws KeyCrypterException {
         checkNotNull(plainBytes);
         checkNotNull(aesKey);
 
@@ -177,7 +177,7 @@ public class KeyCrypterScrypt implements KeyCrypter, Serializable {
 
             cipher.doFinal(encryptedBytes, length);
 
-            return new EncryptedPrivateKey(iv, encryptedBytes);
+            return new EncryptedData(iv, encryptedBytes);
         } catch (Exception e) {
             throw new KeyCrypterException("Could not encrypt bytes.", e);
         }
@@ -192,18 +192,18 @@ public class KeyCrypterScrypt implements KeyCrypter, Serializable {
      * @throws                 KeyCrypterException if bytes could not be decoded to a valid key
      */
     @Override
-    public byte[] decrypt(EncryptedPrivateKey privateKeyToDecode, KeyParameter aesKey) throws KeyCrypterException {
+    public byte[] decrypt(EncryptedData privateKeyToDecode, KeyParameter aesKey) throws KeyCrypterException {
         checkNotNull(privateKeyToDecode);
         checkNotNull(aesKey);
 
         try {
-            ParametersWithIV keyWithIv = new ParametersWithIV(new KeyParameter(aesKey.getKey()), privateKeyToDecode.getInitialisationVector());
+            ParametersWithIV keyWithIv = new ParametersWithIV(new KeyParameter(aesKey.getKey()), privateKeyToDecode.initialisationVector);
 
             // Decrypt the message.
             BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine()));
             cipher.init(false, keyWithIv);
 
-            byte[] cipherBytes = privateKeyToDecode.getEncryptedBytes();
+            byte[] cipherBytes = privateKeyToDecode.encryptedBytes;
             int minimumSize = cipher.getOutputSize(cipherBytes.length);
             byte[] outputBuffer = new byte[minimumSize];
             int length1 = cipher.processBytes(cipherBytes, 0, cipherBytes.length, outputBuffer, 0);
diff --git a/core/src/main/java/com/google/bitcoin/crypto/MnemonicCode.java b/core/src/main/java/com/google/bitcoin/crypto/MnemonicCode.java
index 6e25c4c..cb37575 100644
--- a/core/src/main/java/com/google/bitcoin/crypto/MnemonicCode.java
+++ b/core/src/main/java/com/google/bitcoin/crypto/MnemonicCode.java
@@ -41,6 +41,9 @@ public class MnemonicCode {
 
     public static String BIP39_ENGLISH_SHA256 = "ad90bf3beb7b0eb7e5acd74727dc0da96e0a280a258354e7293fb7e211ac03db";
 
+    /** UNIX time for when the BIP39 standard was finalised. This can be used as a default seed birthday. */
+    public static long BIP39_STANDARDISATION_TIME_SECS = 1381276800;
+
     private static final int PBKDF2_ROUNDS = 2048;
 
     public MnemonicCode() throws IOException {
diff --git a/core/src/main/java/com/google/bitcoin/jni/NativeWalletEventListener.java b/core/src/main/java/com/google/bitcoin/jni/NativeWalletEventListener.java
index 7c1c6dc..091f001 100644
--- a/core/src/main/java/com/google/bitcoin/jni/NativeWalletEventListener.java
+++ b/core/src/main/java/com/google/bitcoin/jni/NativeWalletEventListener.java
@@ -49,7 +49,7 @@ public class NativeWalletEventListener implements WalletEventListener {
     public native void onWalletChanged(Wallet wallet);
 
     @Override
-    public native void onKeysAdded(Wallet wallet, List<ECKey> keys);
+    public native void onKeysAdded(List<ECKey> keys);
 
     @Override
     public native void onScriptsAdded(Wallet wallet, List<Script> scripts);
diff --git a/core/src/main/java/com/google/bitcoin/kits/WalletAppKit.java b/core/src/main/java/com/google/bitcoin/kits/WalletAppKit.java
index 6823bf6..0ea043f 100644
--- a/core/src/main/java/com/google/bitcoin/kits/WalletAppKit.java
+++ b/core/src/main/java/com/google/bitcoin/kits/WalletAppKit.java
@@ -22,11 +22,11 @@ import com.google.bitcoin.net.discovery.DnsDiscovery;
 import com.google.bitcoin.store.BlockStoreException;
 import com.google.bitcoin.store.SPVBlockStore;
 import com.google.bitcoin.store.WalletProtobufSerializer;
+import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.AbstractIdleService;
-import com.google.common.util.concurrent.FutureCallback;
-import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.Service;
+import org.bitcoinj.wallet.Protos;
 
 import java.io.File;
 import java.io.FileInputStream;
@@ -34,6 +34,7 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -158,12 +159,14 @@ public class WalletAppKit extends AbstractIdleService {
     }
 
     /**
-     * <p>Override this to load all wallet extensions if any are necessary.</p>
+     * <p>Override this to return wallet extensions if any are necessary.</p>
      *
      * <p>When this is called, chain(), store(), and peerGroup() will return the created objects, however they are not
-     * initialized/started</p>
+     * initialized/started.</p>
      */
-    protected void addWalletExtensions() throws Exception { }
+    protected List<WalletExtension> provideWalletExtensions() throws Exception {
+        return ImmutableList.of();
+    }
 
     /**
      * This method is invoked on a background thread after all objects are initialised, but before the peer group
@@ -194,9 +197,9 @@ public class WalletAppKit extends AbstractIdleService {
                 // object.
                 long time = Long.MAX_VALUE;
                 if (vWalletFile.exists()) {
-                    Wallet wallet = new Wallet(params);
                     FileInputStream stream = new FileInputStream(vWalletFile);
-                    new WalletProtobufSerializer().readWallet(WalletProtobufSerializer.parseToProto(stream), wallet);
+                    final WalletProtobufSerializer serializer = new WalletProtobufSerializer();
+                    final Wallet wallet = serializer.readWallet(params, null, WalletProtobufSerializer.parseToProto(stream));
                     time = wallet.getEarliestKeyCreationTime();
                 }
                 CheckpointManager.checkpoint(params, checkpoints, vStore, time);
@@ -207,15 +210,18 @@ public class WalletAppKit extends AbstractIdleService {
                 vPeerGroup.setUserAgent(userAgent, version);
             if (vWalletFile.exists()) {
                 walletStream = new FileInputStream(vWalletFile);
-                vWallet = new Wallet(params);
-                addWalletExtensions(); // All extensions must be present before we deserialize
-                new WalletProtobufSerializer().readWallet(WalletProtobufSerializer.parseToProto(walletStream), vWallet);
+                List<WalletExtension> extensions = provideWalletExtensions();
+                WalletExtension[] extArray = extensions.toArray(new WalletExtension[extensions.size()]);
+                Protos.Wallet proto = WalletProtobufSerializer.parseToProto(walletStream);
+                vWallet = new WalletProtobufSerializer().readWallet(params, extArray, proto);
                 if (shouldReplayWallet)
                     vWallet.clearTransactions(0);
             } else {
                 vWallet = new Wallet(params);
-                vWallet.addKey(new ECKey());
-                addWalletExtensions();
+                vWallet.freshReceiveKey();
+                for (WalletExtension e : provideWalletExtensions()) {
+                    vWallet.addExtension(e);
+                }
             }
             if (useAutoSave) vWallet.autosaveToFile(vWalletFile, 1, TimeUnit.SECONDS, null);
             // Set up peer addresses or discovery first, so if wallet extensions try to broadcast a transaction
diff --git a/core/src/main/java/com/google/bitcoin/params/MainNetParams.java b/core/src/main/java/com/google/bitcoin/params/MainNetParams.java
index 3e23ba6..424422c 100644
--- a/core/src/main/java/com/google/bitcoin/params/MainNetParams.java
+++ b/core/src/main/java/com/google/bitcoin/params/MainNetParams.java
@@ -44,8 +44,8 @@ public class MainNetParams extends NetworkParameters {
         subsidyDecreaseBlockCount = 210000;
         spendableCoinbaseDepth = 100;
         String genesisHash = genesisBlock.getHashAsString();
-        checkState(genesisHash.equals("000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f"),
-                genesisHash);
+        
+        //TODO modified Transaction.bitcoinSerialize checkState(genesisHash.equals("000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f"), genesisHash);
 
         // This contains (at a minimum) the blocks which are not BIP30 compliant. BIP30 changed how duplicate
         // transactions are handled. Duplicated transactions could occur in the case where a coinbase had the same
diff --git a/core/src/main/java/com/google/bitcoin/params/PPCNetParams.java b/core/src/main/java/com/google/bitcoin/params/PPCNetParams.java
new file mode 100644
index 0000000..b7ec9df
--- /dev/null
+++ b/core/src/main/java/com/google/bitcoin/params/PPCNetParams.java
@@ -0,0 +1,70 @@
+package com.google.bitcoin.params;
+
+import static com.google.common.base.Preconditions.checkState;
+
+import org.spongycastle.util.encoders.Hex;
+
+import com.google.bitcoin.core.NetworkParameters;
+import com.google.bitcoin.core.Utils;
+
+public class PPCNetParams extends NetworkParameters {
+	public PPCNetParams() {
+
+		super();
+		interval = INTERVAL;
+		targetTimespan = TARGET_TIMESPAN;
+		proofOfWorkLimit = Utils.decodeCompactBits(0x1d00ffffL);
+		addressHeader = 55;
+		p2shHeader = 117;
+		dumpedPrivateKeyHeader = addressHeader + 128;
+		acceptableAddressCodes = new int[] { addressHeader, p2shHeader };
+		port = 9901;
+		packetMagic = 0xe6e8e9e5;
+		genesisBlock.setDifficultyTarget(0x1d00ffffL);// todo
+														// bnProofOfWorkLimit.GetCompact();
+		genesisBlock.setTime(1345084287L);
+		genesisBlock.setNonce(2179302059l);
+		id = "net.peercoin.production";
+		subsidyDecreaseBlockCount = 210000;
+		spendableCoinbaseDepth = 100;
+		alertSigningKey = Hex
+				.decode("04a0a849dd49b113d3179a332dd77715c43be4d0076e2f19e66de23dd707e56630f792f298dfd209bf042bb3561f4af6983f3d81e439737ab0bf7f898fecd21aab");// SunnyKing
+		String genesisHash = genesisBlock.getHashAsString();
+		if (false)
+			checkState(
+					genesisHash
+							.equals("0000000032fe677166d54963b62a4677d8957e87c508eaa4fd7eb1c880cd27e3"),
+					genesisHash);
+
+		// This contains (at a minimum) the blocks which are not BIP30
+		// compliant. BIP30 changed how duplicate
+		// transactions are handled. Duplicated transactions could occur in the
+		// case where a coinbase had the same
+		// extraNonce and the same outputs but appeared at different heights,
+		// and greatly complicated re-org handling.
+		// Having these here simplifies block connection logic considerably.
+		/*
+		checkpoints.put(91722, new Sha256Hash("00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e"));
+		checkpoints.put(91812, new Sha256Hash("00000000000af0aed4792b1acee3d966af36cf5def14935db8de83d6f9306f2f"));
+		checkpoints.put(91842, new Sha256Hash("00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec"));
+		checkpoints.put(91880, new Sha256Hash("00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721"));
+		checkpoints.put(200000, new Sha256Hash("000000000000034a7dedef4a161fa058a2d67a173a90155f3a2fe6fc132e0ebf"));
+		*/
+		dnsSeeds = new String[] { "seed.ppcoin.net" };
+	}
+
+	private static PPCNetParams instance;
+
+	public static synchronized PPCNetParams get() {
+		if (instance == null) {
+			instance = new PPCNetParams();
+		}
+		return instance;
+	}
+
+	@Override
+	public String getPaymentProtocolId() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+}
diff --git a/core/src/main/java/com/google/bitcoin/params/PPCTestParams.java b/core/src/main/java/com/google/bitcoin/params/PPCTestParams.java
new file mode 100644
index 0000000..a5f5fdb
--- /dev/null
+++ b/core/src/main/java/com/google/bitcoin/params/PPCTestParams.java
@@ -0,0 +1,70 @@
+package com.google.bitcoin.params;
+
+import static com.google.common.base.Preconditions.checkState;
+
+import org.spongycastle.util.encoders.Hex;
+
+import com.google.bitcoin.core.NetworkParameters;
+import com.google.bitcoin.core.Utils;
+
+public class PPCTestParams extends NetworkParameters {
+	public PPCTestParams() {
+
+		super();
+		interval = INTERVAL;
+		targetTimespan = TARGET_TIMESPAN;
+		proofOfWorkLimit = Utils.decodeCompactBits(0x1d00ffffL);
+		addressHeader = 111;
+		p2shHeader = 196;
+		dumpedPrivateKeyHeader = addressHeader + 128;
+		acceptableAddressCodes = new int[] { addressHeader, p2shHeader };
+		port = 9903;
+		packetMagic = 0xcbf2c0ef;
+		genesisBlock.setDifficultyTarget(0x1d00ffffL);// todo
+														// bnProofOfWorkLimit.GetCompact();
+		genesisBlock.setTime(1345084287L);
+		genesisBlock.setNonce(2179302059l);
+		id = "net.peercoin.testnet";
+		subsidyDecreaseBlockCount = 210000;
+		spendableCoinbaseDepth = 100;
+		alertSigningKey = Hex
+				.decode("04a0a849dd49b113d3179a332dd77715c43be4d0076e2f19e66de23dd707e56630f792f298dfd209bf042bb3561f4af6983f3d81e439737ab0bf7f898fecd21aab");// SunnyKing
+		String genesisHash = genesisBlock.getHashAsString();
+		if (false)
+			checkState(
+					genesisHash
+							.equals("00000001f757bb737f6596503e17cd17b0658ce630cc727c0cca81aec47c9f06"),
+					genesisHash);
+
+		// This contains (at a minimum) the blocks which are not BIP30
+		// compliant. BIP30 changed how duplicate
+		// transactions are handled. Duplicated transactions could occur in the
+		// case where a coinbase had the same
+		// extraNonce and the same outputs but appeared at different heights,
+		// and greatly complicated re-org handling.
+		// Having these here simplifies block connection logic considerably.
+		/*
+		checkpoints.put(91722, new Sha256Hash("00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e"));
+		checkpoints.put(91812, new Sha256Hash("00000000000af0aed4792b1acee3d966af36cf5def14935db8de83d6f9306f2f"));
+		checkpoints.put(91842, new Sha256Hash("00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec"));
+		checkpoints.put(91880, new Sha256Hash("00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721"));
+		checkpoints.put(200000, new Sha256Hash("000000000000034a7dedef4a161fa058a2d67a173a90155f3a2fe6fc132e0ebf"));
+		*/
+		dnsSeeds = new String[] { "tnseed.ppcoin.net" };
+	}
+
+	private static PPCTestParams instance;
+
+	public static synchronized PPCTestParams get() {
+		if (instance == null) {
+			instance = new PPCTestParams();
+		}
+		return instance;
+	}
+
+	@Override
+	public String getPaymentProtocolId() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+}
diff --git a/core/src/main/java/com/google/bitcoin/params/TestNet3Params.java b/core/src/main/java/com/google/bitcoin/params/TestNet3Params.java
index 0e5bb54..8cdf46f 100644
--- a/core/src/main/java/com/google/bitcoin/params/TestNet3Params.java
+++ b/core/src/main/java/com/google/bitcoin/params/TestNet3Params.java
@@ -46,7 +46,7 @@ public class TestNet3Params extends NetworkParameters {
         spendableCoinbaseDepth = 100;
         subsidyDecreaseBlockCount = 210000;
         String genesisHash = genesisBlock.getHashAsString();
-        checkState(genesisHash.equals("000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943"));
+        //TODO modified Transaction.bitcoinSerialize checkState(genesisHash.equals("000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943"));
         alertSigningKey = Hex.decode("04302390343f91cc401d56d68b123028bf52e5fca1939df127f63c6467cdf9c8e2c14b61104cf817d0b780da337893ecc4aaff1309e536162dabbdb45200ca2b0a");
 
         dnsSeeds = new String[] {
diff --git a/core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelClient.java b/core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelClient.java
index 58aa233..f9247bc 100644
--- a/core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelClient.java
+++ b/core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelClient.java
@@ -175,8 +175,10 @@ public class PaymentChannelClient implements IPaymentChannelClient {
             return CloseReason.SERVER_REQUESTED_TOO_MUCH_VALUE;
         }
 
-        state = new PaymentChannelClientState(wallet, myKey,
-                new ECKey(null, initiate.getMultisigKey().toByteArray()),
+        final byte[] pubKeyBytes = initiate.getMultisigKey().toByteArray();
+        if (!ECKey.isPubKeyCanonical(pubKeyBytes))
+            throw new VerificationException("Server gave us a non-canonical public key, protocol error.");
+        state = new PaymentChannelClientState(wallet, myKey, ECKey.fromPublicOnly(pubKeyBytes),
                 contractValue, initiate.getExpireTimeSecs());
         try {
             state.initiate();
diff --git a/core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelClientState.java b/core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelClientState.java
index 9f6e56e..4fbaec3 100644
--- a/core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelClientState.java
+++ b/core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelClientState.java
@@ -161,8 +161,6 @@ public class PaymentChannelClientState {
         this.wallet = checkNotNull(wallet);
         initWalletListeners();
         this.serverMultisigKey = checkNotNull(serverMultisigKey);
-        if (!myKey.isPubKeyCanonical() || !serverMultisigKey.isPubKeyCanonical())
-            throw new VerificationException("Pubkey was not canonical (ie non-standard)");
         this.myKey = checkNotNull(myKey);
         this.valueToMe = this.totalValue = checkNotNull(value);
         this.expiryTime = expiryTimeInSeconds;
diff --git a/core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelServer.java b/core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelServer.java
index eef3fc4..e437465 100644
--- a/core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelServer.java
+++ b/core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelServer.java
@@ -217,7 +217,7 @@ public class PaymentChannelServer {
                 minAcceptedChannelSize.longValue());
 
         myKey = new ECKey();
-        wallet.addKey(myKey);
+        wallet.freshReceiveKey();
 
         expireTime = Utils.currentTimeSeconds() + timeWindow;
         step = InitStep.WAITING_ON_UNSIGNED_REFUND;
diff --git a/core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelServerState.java b/core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelServerState.java
index 5d72a10..f11011f 100644
--- a/core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelServerState.java
+++ b/core/src/main/java/com/google/bitcoin/protocols/channels/PaymentChannelServerState.java
@@ -119,7 +119,7 @@ public class PaymentChannelServerState {
             this.broadcaster = checkNotNull(broadcaster);
             this.multisigContract = checkNotNull(storedServerChannel.contract);
             this.multisigScript = multisigContract.getOutput(0).getScriptPubKey();
-            this.clientKey = new ECKey(null, multisigScript.getChunks().get(1).data);
+            this.clientKey = ECKey.fromPublicOnly(multisigScript.getChunks().get(1).data);
             this.clientOutput = checkNotNull(storedServerChannel.clientOutput);
             this.refundTransactionUnlockTimeSecs = storedServerChannel.refundTransactionUnlockTimeSecs;
             this.serverKey = checkNotNull(storedServerChannel.myKey);
@@ -192,7 +192,7 @@ public class PaymentChannelServerState {
 
         // Sign the refund tx with the scriptPubKey and return the signature. We don't have the spending transaction
         // so do the steps individually.
-        clientKey = new ECKey(null, clientMultiSigPubKey);
+        clientKey = ECKey.fromPublicOnly(clientMultiSigPubKey);
         Script multisigPubKey = ScriptBuilder.createMultiSigOutputScript(2, ImmutableList.of(clientKey, serverKey));
         // We are really only signing the fact that the transaction has a proper lock time and don't care about anything
         // else, so we sign SIGHASH_NONE and SIGHASH_ANYONECANPAY.
diff --git a/core/src/main/java/com/google/bitcoin/protocols/channels/StoredPaymentChannelClientStates.java b/core/src/main/java/com/google/bitcoin/protocols/channels/StoredPaymentChannelClientStates.java
index f485998..e463884 100644
--- a/core/src/main/java/com/google/bitcoin/protocols/channels/StoredPaymentChannelClientStates.java
+++ b/core/src/main/java/com/google/bitcoin/protocols/channels/StoredPaymentChannelClientStates.java
@@ -57,9 +57,9 @@ public class StoredPaymentChannelClientStates implements WalletExtension {
      * {@link TransactionBroadcaster} which are used to complete and announce contract and refund
      * transactions.
      */
-    public StoredPaymentChannelClientStates(Wallet containingWallet, TransactionBroadcaster announcePeerGroup) {
+    public StoredPaymentChannelClientStates(@Nullable Wallet containingWallet, TransactionBroadcaster announcePeerGroup) {
         this.announcePeerGroup = checkNotNull(announcePeerGroup);
-        this.containingWallet = checkNotNull(containingWallet);
+        this.containingWallet = containingWallet;
     }
 
     /** Returns this extension from the given wallet, or null if no such extension was added. */
@@ -255,7 +255,7 @@ public class StoredPaymentChannelClientStates implements WalletExtension {
                 StoredClientChannel channel = new StoredClientChannel(new Sha256Hash(storedState.getId().toByteArray()),
                         new Transaction(params, storedState.getContractTransaction().toByteArray()),
                         refundTransaction,
-                        new ECKey(new BigInteger(1, storedState.getMyKey().toByteArray()), null, true),
+                        ECKey.fromPrivate(storedState.getMyKey().toByteArray()),
                         BigInteger.valueOf(storedState.getValueToMe()),
                         BigInteger.valueOf(storedState.getRefundFees()), false);
                 if (storedState.hasCloseTransactionHash())
diff --git a/core/src/main/java/com/google/bitcoin/protocols/channels/StoredPaymentChannelServerStates.java b/core/src/main/java/com/google/bitcoin/protocols/channels/StoredPaymentChannelServerStates.java
index d12991c..b122a40 100644
--- a/core/src/main/java/com/google/bitcoin/protocols/channels/StoredPaymentChannelServerStates.java
+++ b/core/src/main/java/com/google/bitcoin/protocols/channels/StoredPaymentChannelServerStates.java
@@ -23,6 +23,7 @@ import com.google.protobuf.ByteString;
 import net.jcip.annotations.GuardedBy;
 import org.slf4j.LoggerFactory;
 
+import javax.annotation.Nullable;
 import java.math.BigInteger;
 import java.util.*;
 import java.util.concurrent.locks.ReentrantLock;
@@ -39,7 +40,7 @@ public class StoredPaymentChannelServerStates implements WalletExtension {
     static final String EXTENSION_ID = StoredPaymentChannelServerStates.class.getName();
 
     @GuardedBy("lock") @VisibleForTesting final Map<Sha256Hash, StoredServerChannel> mapChannels = new HashMap<Sha256Hash, StoredServerChannel>();
-    private final Wallet wallet;
+    private Wallet wallet;
     private final TransactionBroadcaster broadcaster;
 
     private final Timer channelTimeoutHandler = new Timer(true);
@@ -59,8 +60,8 @@ public class StoredPaymentChannelServerStates implements WalletExtension {
      * Creates a new PaymentChannelServerStateManager and associates it with the given {@link Wallet} and
      * {@link TransactionBroadcaster} which are used to complete and announce payment transactions.
      */
-    public StoredPaymentChannelServerStates(Wallet wallet, TransactionBroadcaster broadcaster) {
-        this.wallet = checkNotNull(wallet);
+    public StoredPaymentChannelServerStates(@Nullable Wallet wallet, TransactionBroadcaster broadcaster) {
+        this.wallet = wallet;
         this.broadcaster = checkNotNull(broadcaster);
     }
 
@@ -173,7 +174,7 @@ public class StoredPaymentChannelServerStates implements WalletExtension {
     public void deserializeWalletExtension(Wallet containingWallet, byte[] data) throws Exception {
         lock.lock();
         try {
-            checkArgument(containingWallet == wallet);
+            this.wallet = containingWallet;
             ServerState.StoredServerPaymentChannels states = ServerState.StoredServerPaymentChannels.parseFrom(data);
             NetworkParameters params = containingWallet.getParams();
             for (ServerState.StoredServerPaymentChannel storedState : states.getChannelsList()) {
@@ -181,7 +182,7 @@ public class StoredPaymentChannelServerStates implements WalletExtension {
                         new Transaction(params, storedState.getContractTransaction().toByteArray()),
                         new TransactionOutput(params, null, storedState.getClientOutput().toByteArray(), 0),
                         storedState.getRefundTransactionUnlockTimeSecs(),
-                        new ECKey(storedState.getMyKey().toByteArray(), null),
+                        ECKey.fromPrivate(storedState.getMyKey().toByteArray()),
                         BigInteger.valueOf(storedState.getBestValueToMe()),
                         storedState.hasBestValueSignature() ? storedState.getBestValueSignature().toByteArray() : null);
                 putChannel(channel);
diff --git a/core/src/main/java/com/google/bitcoin/store/UnreadableWalletException.java b/core/src/main/java/com/google/bitcoin/store/UnreadableWalletException.java
index 43cba41..0c9d31b 100644
--- a/core/src/main/java/com/google/bitcoin/store/UnreadableWalletException.java
+++ b/core/src/main/java/com/google/bitcoin/store/UnreadableWalletException.java
@@ -12,4 +12,14 @@ public class UnreadableWalletException extends Exception {
     public UnreadableWalletException(String s, Throwable t) {
         super(s, t);
     }
+
+    public static class BadPassword extends UnreadableWalletException {
+        public BadPassword() {
+            super("Password incorrect");
+        }
+    }
+
+    public static class FutureVersion extends UnreadableWalletException {
+        public FutureVersion() { super("Unknown wallet version from the future."); }
+    }
 }
diff --git a/core/src/main/java/com/google/bitcoin/store/WalletProtobufSerializer.java b/core/src/main/java/com/google/bitcoin/store/WalletProtobufSerializer.java
index 50b0bc4..87938ea 100644
--- a/core/src/main/java/com/google/bitcoin/store/WalletProtobufSerializer.java
+++ b/core/src/main/java/com/google/bitcoin/store/WalletProtobufSerializer.java
@@ -19,10 +19,10 @@ package com.google.bitcoin.store;
 
 import com.google.bitcoin.core.*;
 import com.google.bitcoin.core.TransactionConfidence.ConfidenceType;
-import com.google.bitcoin.crypto.EncryptedPrivateKey;
 import com.google.bitcoin.crypto.KeyCrypter;
 import com.google.bitcoin.crypto.KeyCrypterScrypt;
 import com.google.bitcoin.script.Script;
+import com.google.bitcoin.wallet.KeyChainGroup;
 import com.google.bitcoin.wallet.WalletTransaction;
 import com.google.common.collect.Lists;
 import com.google.protobuf.ByteString;
@@ -35,17 +35,14 @@ import org.bitcoinj.wallet.Protos.Wallet.EncryptionType;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.annotation.Nullable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.math.BigInteger;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.ListIterator;
-import java.util.Map;
+import java.util.*;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
@@ -55,7 +52,7 @@ import static com.google.common.base.Preconditions.checkNotNull;
  * a data interchange format developed by Google with an efficient binary representation, a type safe specification
  * language and compilers that generate code to work with those data structures for many languages. Protocol buffers
  * can have their format evolved over time: conceptually they represent data using (tag, length, value) tuples. The
- * format is defined by the <tt>bitcoin.proto</tt> file in the bitcoinj source distribution.<p>
+ * format is defined by the <tt>wallet.proto</tt> file in the bitcoinj source distribution.<p>
  *
  * This class is used through its static methods. The most common operations are writeWallet and readWallet, which do
  * the obvious operations on Output/InputStreams. You can use a {@link java.io.ByteArrayInputStream} and equivalent
@@ -127,40 +124,7 @@ public class WalletProtobufSerializer {
             walletBuilder.addTransaction(txProto);
         }
 
-        for (ECKey key : wallet.getKeys()) {
-            Protos.Key.Builder keyBuilder = Protos.Key.newBuilder().setCreationTimestamp(key.getCreationTimeSeconds() * 1000)
-                                                         // .setLabel() TODO
-                                                            .setType(Protos.Key.Type.ORIGINAL);
-            if (key.getPrivKeyBytes() != null)
-                keyBuilder.setPrivateKey(ByteString.copyFrom(key.getPrivKeyBytes()));
-
-            EncryptedPrivateKey encryptedPrivateKey = key.getEncryptedPrivateKey();
-            if (encryptedPrivateKey != null) {
-                // Key is encrypted.
-                Protos.EncryptedPrivateKey.Builder encryptedKeyBuilder = Protos.EncryptedPrivateKey.newBuilder()
-                    .setEncryptedPrivateKey(ByteString.copyFrom(encryptedPrivateKey.getEncryptedBytes()))
-                    .setInitialisationVector(ByteString.copyFrom(encryptedPrivateKey.getInitialisationVector()));
-
-                if (key.getKeyCrypter() == null) {
-                    throw new IllegalStateException("The encrypted key " + key.toString() + " has no KeyCrypter.");
-                } else {
-                    // If it is a Scrypt + AES encrypted key, set the persisted key type.
-                    if (key.getKeyCrypter().getUnderstoodEncryptionType() == Protos.Wallet.EncryptionType.ENCRYPTED_SCRYPT_AES) {
-                        keyBuilder.setType(Protos.Key.Type.ENCRYPTED_SCRYPT_AES);
-                    } else {
-                        throw new IllegalArgumentException("The key " + key.toString() + " is encrypted with a KeyCrypter of type " + key.getKeyCrypter().getUnderstoodEncryptionType() +
-                                ". This WalletProtobufSerialiser does not understand that type of encryption.");
-                    }
-                }
-                keyBuilder.setEncryptedPrivateKey(encryptedKeyBuilder);
-            }
-
-            // We serialize the public key even if the private key is present for speed reasons: we don't want to do
-            // lots of slow EC math to load the wallet, we prefer to store the redundant data instead. It matters more
-            // on mobile platforms.
-            keyBuilder.setPublicKey(ByteString.copyFrom(key.getPubKey()));
-            walletBuilder.addKey(keyBuilder);
-        }
+        walletBuilder.addAllKey(wallet.serializeKeychainToProtobuf());
 
         for (Script script : wallet.getWatchedScripts()) {
             Protos.Script protoScript =
@@ -372,9 +336,7 @@ public class WalletProtobufSerializer {
             NetworkParameters params = NetworkParameters.fromID(paramsID);
             if (params == null)
                 throw new UnreadableWalletException("Unknown network parameters ID " + paramsID);
-            Wallet wallet = new Wallet(params);
-            readWallet(walletProto, wallet);
-            return wallet;
+            return readWallet(params, null, walletProto);
         } catch (IOException e) {
             throw new UnreadableWalletException("Could not parse input stream to protobuf", e);
         }
@@ -391,45 +353,21 @@ public class WalletProtobufSerializer {
      *
      * @throws UnreadableWalletException thrown in various error conditions (see description).
      */
-    public void readWallet(Protos.Wallet walletProto, Wallet wallet) throws UnreadableWalletException {
+    public Wallet readWallet(NetworkParameters params, @Nullable WalletExtension[] extensions,
+                             Protos.Wallet walletProto) throws UnreadableWalletException {
+        if (walletProto.getVersion() > 1)
+            throw new UnreadableWalletException.FutureVersion();
+
         // Read the scrypt parameters that specify how encryption and decryption is performed.
+        KeyChainGroup chain;
         if (walletProto.hasEncryptionParameters()) {
             Protos.ScryptParameters encryptionParameters = walletProto.getEncryptionParameters();
-            wallet.setKeyCrypter(new KeyCrypterScrypt(encryptionParameters));
-        }
-
-        if (walletProto.hasDescription()) {
-            wallet.setDescription(walletProto.getDescription());
-        }
-
-        // Read all keys
-        for (Protos.Key keyProto : walletProto.getKeyList()) {
-            if (!(keyProto.getType() == Protos.Key.Type.ORIGINAL || keyProto.getType() == Protos.Key.Type.ENCRYPTED_SCRYPT_AES)) {
-                throw new UnreadableWalletException("Unknown key type in wallet, type = " + keyProto.getType());
-            }
-
-            byte[] privKey = keyProto.hasPrivateKey() ? keyProto.getPrivateKey().toByteArray() : null;
-            EncryptedPrivateKey encryptedPrivateKey = null;
-            if (keyProto.hasEncryptedPrivateKey()) {
-                Protos.EncryptedPrivateKey encryptedPrivateKeyProto = keyProto.getEncryptedPrivateKey();
-                encryptedPrivateKey = new EncryptedPrivateKey(encryptedPrivateKeyProto.getInitialisationVector().toByteArray(),
-                        encryptedPrivateKeyProto.getEncryptedPrivateKey().toByteArray());
-            }
-
-            byte[] pubKey = keyProto.hasPublicKey() ? keyProto.getPublicKey().toByteArray() : null;
-
-            ECKey ecKey;
-            final KeyCrypter keyCrypter = wallet.getKeyCrypter();
-            if (keyCrypter != null && keyCrypter.getUnderstoodEncryptionType() != EncryptionType.UNENCRYPTED) {
-                // If the key is encrypted construct an ECKey using the encrypted private key bytes.
-                ecKey = new ECKey(encryptedPrivateKey, pubKey, keyCrypter);
-            } else {
-                // Construct an unencrypted private key.
-                ecKey = new ECKey(privKey, pubKey);
-            }
-            ecKey.setCreationTimeSeconds((keyProto.getCreationTimestamp() + 500) / 1000);
-            wallet.addKey(ecKey);
+            final KeyCrypterScrypt keyCrypter = new KeyCrypterScrypt(encryptionParameters);
+            chain = KeyChainGroup.fromProtobufEncrypted(walletProto.getKeyList(), keyCrypter);
+        } else {
+            chain = KeyChainGroup.fromProtobufUnencrypted(walletProto.getKeyList());
         }
+        Wallet wallet = new Wallet(params, chain);
 
         List<Script> scripts = Lists.newArrayList();
         for (Protos.Script protoScript : walletProto.getWatchedScriptList()) {
@@ -445,6 +383,10 @@ public class WalletProtobufSerializer {
 
         wallet.addWatchedScripts(scripts);
 
+        if (walletProto.hasDescription()) {
+            wallet.setDescription(walletProto.getDescription());
+        }
+
         // Read all transactions and insert into the txMap.
         for (Protos.Transaction txProto : walletProto.getTransactionList()) {
             readTransaction(txProto, wallet.getParams());
@@ -474,7 +416,7 @@ public class WalletProtobufSerializer {
             wallet.setKeyRotationTime(new Date(walletProto.getKeyRotationTime() * 1000));
         }
 
-        loadExtensions(wallet, walletProto);
+        loadExtensions(wallet, extensions != null ? extensions : new WalletExtension[0], walletProto);
 
         if (walletProto.hasVersion()) {
             wallet.setVersion(walletProto.getVersion());
@@ -482,10 +424,14 @@ public class WalletProtobufSerializer {
 
         // Make sure the object can be re-used to read another wallet without corruption.
         txMap.clear();
+
+        return wallet;
     }
 
-    private void loadExtensions(Wallet wallet, Protos.Wallet walletProto) throws UnreadableWalletException {
-        final Map<String, WalletExtension> extensions = wallet.getExtensions();
+    private void loadExtensions(Wallet wallet, WalletExtension[] extensionsList, Protos.Wallet walletProto) throws UnreadableWalletException {
+        final Map<String, WalletExtension> extensions = new HashMap<String, WalletExtension>();
+        for (WalletExtension e : extensionsList)
+            extensions.put(e.getWalletExtensionID(), e);
         for (Protos.Extension extProto : walletProto.getExtensionList()) {
             String id = extProto.getId();
             WalletExtension extension = extensions.get(id);
@@ -500,6 +446,7 @@ public class WalletProtobufSerializer {
                 log.info("Loading wallet extension {}", id);
                 try {
                     extension.deserializeWalletExtension(wallet, extProto.getData().toByteArray());
+                    wallet.addExtension(extension);
                 } catch (Exception e) {
                     if (extProto.getMandatory() && requireMandatoryExtensions)
                         throw new UnreadableWalletException("Could not parse mandatory extension in wallet: " + id);
diff --git a/core/src/main/java/com/google/bitcoin/utils/TestWithWallet.java b/core/src/main/java/com/google/bitcoin/utils/TestWithWallet.java
index 5c4a477..9ede9dc 100644
--- a/core/src/main/java/com/google/bitcoin/utils/TestWithWallet.java
+++ b/core/src/main/java/com/google/bitcoin/utils/TestWithWallet.java
@@ -49,10 +49,10 @@ public class TestWithWallet {
     public void setUp() throws Exception {
         BriefLogFormatter.init();
         Wallet.SendRequest.DEFAULT_FEE_PER_KB = BigInteger.ZERO;
-        myKey = new ECKey();
-        myAddress = myKey.toAddress(params);
         wallet = new Wallet(params);
-        wallet.addKey(myKey);
+        wallet.setKeychainLookaheadSize(5);
+        myKey = wallet.currentReceiveKey();
+        myAddress = myKey.toAddress(params);
         blockStore = new MemoryBlockStore(params);
         chain = new BlockChain(params, wallet, blockStore);
     }
diff --git a/core/src/main/java/com/google/bitcoin/wallet/AbstractKeyChainEventListener.java b/core/src/main/java/com/google/bitcoin/wallet/AbstractKeyChainEventListener.java
new file mode 100644
index 0000000..eda9b0d
--- /dev/null
+++ b/core/src/main/java/com/google/bitcoin/wallet/AbstractKeyChainEventListener.java
@@ -0,0 +1,11 @@
+package com.google.bitcoin.wallet;
+
+import com.google.bitcoin.core.ECKey;
+
+import java.util.List;
+
+public class AbstractKeyChainEventListener implements KeyChainEventListener {
+    @Override
+    public void onKeysAdded(List<ECKey> keys) {
+    }
+}
diff --git a/core/src/main/java/com/google/bitcoin/wallet/BasicKeyChain.java b/core/src/main/java/com/google/bitcoin/wallet/BasicKeyChain.java
new file mode 100644
index 0000000..77bc32e
--- /dev/null
+++ b/core/src/main/java/com/google/bitcoin/wallet/BasicKeyChain.java
@@ -0,0 +1,502 @@
+/**
+ * Copyright 2013 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.bitcoin.wallet;
+
+import com.google.bitcoin.core.BloomFilter;
+import com.google.bitcoin.core.ECKey;
+import com.google.bitcoin.crypto.*;
+import com.google.bitcoin.store.UnreadableWalletException;
+import com.google.bitcoin.utils.ListenerRegistration;
+import com.google.bitcoin.utils.Threading;
+import com.google.common.collect.ImmutableList;
+import com.google.protobuf.ByteString;
+import org.bitcoinj.wallet.Protos;
+import org.spongycastle.crypto.params.KeyParameter;
+
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.Executor;
+import java.util.concurrent.locks.ReentrantLock;
+
+import static com.google.common.base.Preconditions.*;
+
+/**
+ * A {@link KeyChain} that implements the simplest model possible: it can have keys imported into it, and just acts as
+ * a dumb bag of keys. It will, left to its own devices, always return the same key for usage by the wallet, although
+ * it will automatically add one to itself if it's empty or if encryption is requested.
+ */
+public class BasicKeyChain implements EncryptableKeyChain {
+    private final ReentrantLock lock = Threading.lock("BasicKeyChain");
+
+    // Maps used to let us quickly look up a key given data we find in transcations or the block chain.
+    private final LinkedHashMap<ByteString, ECKey> hashToKeys;
+    private final LinkedHashMap<ByteString, ECKey> pubkeyToKeys;
+    @Nullable private final KeyCrypter keyCrypter;
+
+    private final CopyOnWriteArrayList<ListenerRegistration<KeyChainEventListener>> listeners;
+
+    public BasicKeyChain() {
+        this(null);
+    }
+
+    BasicKeyChain(@Nullable KeyCrypter crypter) {
+        this.keyCrypter = crypter;
+        hashToKeys = new LinkedHashMap<ByteString, ECKey>();
+        pubkeyToKeys = new LinkedHashMap<ByteString, ECKey>();
+        listeners = new CopyOnWriteArrayList<ListenerRegistration<KeyChainEventListener>>();
+    }
+
+    /** Returns the {@link KeyCrypter} in use or null if the key chain is not encrypted. */
+    @Nullable
+    public KeyCrypter getKeyCrypter() {
+        lock.lock();
+        try {
+            return keyCrypter;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public ECKey getKey(@Nullable KeyPurpose ignored) {
+        lock.lock();
+        try {
+            if (hashToKeys.isEmpty()) {
+                checkState(keyCrypter == null);   // We will refuse to encrypt an empty key chain.
+                final ECKey key = new ECKey();
+                importKeyLocked(key);
+                queueOnKeysAdded(ImmutableList.of(key));
+            }
+            return hashToKeys.values().iterator().next();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /** Returns a copy of the list of keys that this chain is managing. */
+    public List<ECKey> getKeys() {
+        lock.lock();
+        try {
+            return new ArrayList<ECKey>(hashToKeys.values());
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    public int importKeys(ECKey... keys) {
+        return importKeys(ImmutableList.copyOf(keys));
+    }
+
+    public int importKeys(List<? extends ECKey> keys) {
+        lock.lock();
+        try {
+            // Check that if we're encrypted, the keys are all encrypted, and if we're not, that none are.
+            // We are NOT checking that the actual password matches here because we don't have access to the password at
+            // this point: if you screw up and import keys with mismatched passwords, you lose! So make sure the
+            // password is checked first.
+            for (ECKey key : keys) {
+                checkKeyEncryptionStateMatches(key);
+            }
+            List<ECKey> actuallyAdded = new ArrayList<ECKey>(keys.size());
+            for (final ECKey key : keys) {
+                if (hasKey(key)) continue;
+                actuallyAdded.add(key);
+                importKeyLocked(key);
+            }
+            if (actuallyAdded.size() > 0)
+                queueOnKeysAdded(actuallyAdded);
+            return actuallyAdded.size();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    private void checkKeyEncryptionStateMatches(ECKey key) {
+        if (keyCrypter == null && key.isEncrypted())
+            throw new KeyCrypterException("Key is encrypted but chain is not");
+        else if (keyCrypter != null && !key.isEncrypted())
+            throw new KeyCrypterException("Key is not encrypted but chain is");
+        else if (keyCrypter != null && key.getKeyCrypter() != null && !key.getKeyCrypter().equals(keyCrypter))
+            throw new KeyCrypterException("Key encrypted under different parameters to chain");
+    }
+
+    private void importKeyLocked(ECKey key) {
+        pubkeyToKeys.put(ByteString.copyFrom(key.getPubKey()), key);
+        hashToKeys.put(ByteString.copyFrom(key.getPubKeyHash()), key);
+    }
+
+    /* package */ void importKey(ECKey key) {
+        lock.lock();
+        try {
+            importKeyLocked(key);
+            queueOnKeysAdded(ImmutableList.of(key));
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public ECKey findKeyFromPubHash(byte[] pubkeyHash) {
+        lock.lock();
+        try {
+            return hashToKeys.get(ByteString.copyFrom(pubkeyHash));
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public ECKey findKeyFromPubKey(byte[] pubkey) {
+        lock.lock();
+        try {
+            return pubkeyToKeys.get(ByteString.copyFrom(pubkey));
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public boolean hasKey(ECKey key) {
+        return findKeyFromPubKey(key.getPubKey()) != null;
+    }
+
+    @Override
+    public int numKeys() {
+        return pubkeyToKeys.size();
+    }
+
+    /**
+     * Removes the given key from the keychain. Be very careful with this - losing a private key <b>destroys the
+     * money associated with it</b>.
+     * @return Whether the key was removed or not.
+     */
+    public boolean removeKey(ECKey key) {
+        lock.lock();
+        try {
+            boolean a = hashToKeys.remove(ByteString.copyFrom(key.getPubKeyHash())) != null;
+            boolean b = pubkeyToKeys.remove(ByteString.copyFrom(key.getPubKey())) != null;
+            checkState(a == b);   // Should be in both maps or neither.
+            return a;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public long getEarliestKeyCreationTime() {
+        lock.lock();
+        try {
+            long time = Long.MAX_VALUE;
+            for (ECKey key : hashToKeys.values())
+                time = Math.min(key.getCreationTimeSeconds(), time);
+            return time;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    public List<ListenerRegistration<KeyChainEventListener>> getListeners() {
+        return new ArrayList<ListenerRegistration<KeyChainEventListener>>(listeners);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //
+    // Serialization support
+    //
+    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+    Map<ECKey, Protos.Key.Builder> serializeToEditableProtobufs() {
+        Map<ECKey, Protos.Key.Builder> result = new LinkedHashMap<ECKey, Protos.Key.Builder>();
+        for (ECKey ecKey : hashToKeys.values()) {
+            Protos.Key.Builder protoKey = serializeEncryptableItem(ecKey);
+            protoKey.setPublicKey(ByteString.copyFrom(ecKey.getPubKey()));
+            result.put(ecKey, protoKey);
+        }
+        return result;
+    }
+
+    @Override
+    public List<Protos.Key> serializeToProtobuf() {
+        Collection<Protos.Key.Builder> builders = serializeToEditableProtobufs().values();
+        List<Protos.Key> result = new ArrayList<Protos.Key>(builders.size());
+        for (Protos.Key.Builder builder : builders) result.add(builder.build());
+        return result;
+    }
+
+    /*package*/ static Protos.Key.Builder serializeEncryptableItem(EncryptableItem item) {
+        Protos.Key.Builder proto = Protos.Key.newBuilder();
+        proto.setCreationTimestamp(item.getCreationTimeSeconds() * 1000);
+        if (item.isEncrypted() && item.getEncryptedData() != null) {
+            // The encrypted data can be missing for an "encrypted" key in the case of a deterministic wallet for
+            // which the leaf keys chain to an encrypted parent and rederive their private keys on the fly. In that
+            // case the caller in DeterministicKeyChain will take care of setting the type.
+            EncryptedData data = item.getEncryptedData();
+            proto.getEncryptedDataBuilder()
+                    .setEncryptedPrivateKey(ByteString.copyFrom(data.encryptedBytes))
+                    .setInitialisationVector(ByteString.copyFrom(data.initialisationVector));
+            // We don't allow mixing of encryption types at the moment.
+            checkState(item.getEncryptionType() == Protos.Wallet.EncryptionType.ENCRYPTED_SCRYPT_AES);
+            proto.setType(Protos.Key.Type.ENCRYPTED_SCRYPT_AES);
+        } else {
+            final byte[] secret = item.getSecretBytes();
+            // The secret might be missing in the case of a watching wallet, or a key for which the private key
+            // is expected to be rederived on the fly from its parent.
+            if (secret != null)
+                proto.setSecretBytes(ByteString.copyFrom(secret));
+            proto.setType(Protos.Key.Type.ORIGINAL);
+        }
+        return proto;
+    }
+
+    /**
+     * Returns a new BasicKeyChain that contains all basic, ORIGINAL type keys extracted from the list. Unrecognised
+     * key types are ignored.
+     */
+    public static BasicKeyChain fromProtobufUnencrypted(List<Protos.Key> keys) throws UnreadableWalletException {
+        BasicKeyChain chain = new BasicKeyChain();
+        chain.deserializeFromProtobuf(keys);
+        return chain;
+    }
+
+    /**
+     * Returns a new BasicKeyChain that contains all basic, ORIGINAL type keys and also any encrypted keys extracted
+     * from the list. Unrecognised key types are ignored.
+     * @throws com.google.bitcoin.store.UnreadableWalletException.BadPassword if the password doesn't seem to match
+     * @throws com.google.bitcoin.store.UnreadableWalletException if the data structures are corrupted/inconsistent
+     */
+    public static BasicKeyChain fromProtobufEncrypted(List<Protos.Key> keys, KeyCrypter crypter) throws UnreadableWalletException {
+        BasicKeyChain chain = new BasicKeyChain(checkNotNull(crypter));
+        chain.deserializeFromProtobuf(keys);
+        return chain;
+    }
+
+    private void deserializeFromProtobuf(List<Protos.Key> keys) throws UnreadableWalletException {
+        lock.lock();
+        try {
+            checkState(hashToKeys.isEmpty(), "Tried to deserialize into a non-empty chain");
+            for (Protos.Key key : keys) {
+                if (key.getType() != Protos.Key.Type.ORIGINAL && key.getType() != Protos.Key.Type.ENCRYPTED_SCRYPT_AES)
+                    continue;
+                boolean encrypted = key.getType() == Protos.Key.Type.ENCRYPTED_SCRYPT_AES;
+                byte[] priv = key.hasSecretBytes() ? key.getSecretBytes().toByteArray() : null;
+                if (!key.hasPublicKey())
+                    throw new UnreadableWalletException("Public key missing");
+                byte[] pub = key.getPublicKey().toByteArray();
+                ECKey ecKey;
+                if (encrypted) {
+                    checkState(keyCrypter != null, "This wallet is encrypted but encrypt() was not called prior to deserialization");
+                    if (!key.hasEncryptedData())
+                        throw new UnreadableWalletException("Encrypted private key data missing");
+                    Protos.EncryptedData proto = key.getEncryptedData();
+                    EncryptedData e = new EncryptedData(proto.getInitialisationVector().toByteArray(),
+                            proto.getEncryptedPrivateKey().toByteArray());
+                    ecKey = ECKey.fromEncrypted(e, keyCrypter, pub);
+                } else {
+                    if (priv != null)
+                        ecKey = ECKey.fromPrivateAndPrecalculatedPublic(priv, pub);
+                    else
+                        ecKey = ECKey.fromPublicOnly(pub);
+                }
+                ecKey.setCreationTimeSeconds((key.getCreationTimestamp() + 500) / 1000);
+                importKeyLocked(ecKey);
+            }
+        } finally {
+            lock.unlock();
+        }
+    }
+
+
+    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //
+    // Event listener support
+    //
+    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public void addEventListener(KeyChainEventListener listener) {
+        addEventListener(listener, Threading.USER_THREAD);
+    }
+
+    @Override
+    public void addEventListener(KeyChainEventListener listener, Executor executor) {
+        listeners.add(new ListenerRegistration<KeyChainEventListener>(listener, executor));
+    }
+
+    @Override
+    public boolean removeEventListener(KeyChainEventListener listener) {
+        return ListenerRegistration.removeFromList(listener, listeners);
+    }
+
+    private void queueOnKeysAdded(final List<ECKey> keys) {
+        checkState(lock.isHeldByCurrentThread());
+        for (final ListenerRegistration<KeyChainEventListener> registration : listeners) {
+            registration.executor.execute(new Runnable() {
+                @Override
+                public void run() {
+                    registration.listener.onKeysAdded(keys);
+                }
+            });
+        }
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //
+    // Encryption support
+    //
+    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+    /**
+     * Convenience wrapper around {@link #toEncrypted(com.google.bitcoin.crypto.KeyCrypter,
+     * org.spongycastle.crypto.params.KeyParameter)} which uses the default Scrypt key derivation algorithm and
+     * parameters, derives a key from the given password and returns the created key.
+     */
+    @Override
+    public BasicKeyChain toEncrypted(CharSequence password) {
+        checkNotNull(password);
+        checkArgument(password.length() > 0);
+        KeyCrypter scrypt = new KeyCrypterScrypt();
+        KeyParameter derivedKey = scrypt.deriveKey(password);
+        return toEncrypted(scrypt, derivedKey);
+    }
+
+    /**
+     * Encrypt the wallet using the KeyCrypter and the AES key. A good default KeyCrypter to use is
+     * {@link com.google.bitcoin.crypto.KeyCrypterScrypt}.
+     *
+     * @param keyCrypter The KeyCrypter that specifies how to encrypt/ decrypt a key
+     * @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming
+     *               to create from a password)
+     * @throws KeyCrypterException Thrown if the wallet encryption fails. If so, the wallet state is unchanged.
+     */
+    @Override
+    public BasicKeyChain toEncrypted(KeyCrypter keyCrypter, KeyParameter aesKey) {
+        lock.lock();
+        try {
+            checkNotNull(keyCrypter);
+            checkState(this.keyCrypter == null, "Key chain is already encrypted");
+            BasicKeyChain encrypted = new BasicKeyChain(keyCrypter);
+            for (ECKey key : hashToKeys.values()) {
+                ECKey encryptedKey = key.encrypt(keyCrypter, aesKey);
+                // Check that the encrypted key can be successfully decrypted.
+                // This is done as it is a critical failure if the private key cannot be decrypted successfully
+                // (all bitcoin controlled by that private key is lost forever).
+                // For a correctly constructed keyCrypter the encryption should always be reversible so it is just
+                // being as cautious as possible.
+                if (!ECKey.encryptionIsReversible(key, encryptedKey, keyCrypter, aesKey))
+                    throw new KeyCrypterException("The key " + key.toString() + " cannot be successfully decrypted after encryption so aborting wallet encryption.");
+                encrypted.importKeyLocked(encryptedKey);
+            }
+            return encrypted;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public BasicKeyChain toDecrypted(CharSequence password) {
+        checkNotNull(keyCrypter, "Wallet is already decrypted");
+        KeyParameter aesKey = keyCrypter.deriveKey(password);
+        return toDecrypted(aesKey);
+    }
+
+    @Override
+    public BasicKeyChain toDecrypted(KeyParameter aesKey) {
+        lock.lock();
+        try {
+            checkState(keyCrypter != null, "Wallet is already decrypted");
+            // Do an up-front check.
+            if (numKeys() > 0 && !checkAESKey(aesKey))
+                throw new KeyCrypterException("Password/key was incorrect.");
+            BasicKeyChain decrypted = new BasicKeyChain();
+            for (ECKey key : hashToKeys.values()) {
+                decrypted.importKeyLocked(key.decrypt(keyCrypter, aesKey));
+            }
+            return decrypted;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Returns whether the given password is correct for this key chain.
+     * @throws IllegalStateException if the chain is not encrypted at all.
+     */
+    @Override
+    public boolean checkPassword(CharSequence password) {
+        checkNotNull(password);
+        checkState(keyCrypter != null, "Key chain not encrypted");
+        return checkAESKey(keyCrypter.deriveKey(password));
+    }
+
+    /**
+     * Check whether the AES key can decrypt the first encrypted key in the wallet.
+     *
+     * @return true if AES key supplied can decrypt the first encrypted private key in the wallet, false otherwise.
+     */
+    @Override
+    public boolean checkAESKey(KeyParameter aesKey) {
+        lock.lock();
+        try {
+            // If no keys then cannot decrypt.
+            if (hashToKeys.isEmpty()) return false;
+            checkState(keyCrypter != null, "Key chain is not encrypted");
+
+            // Find the first encrypted key in the wallet.
+            ECKey first = null;
+            for (ECKey key : hashToKeys.values()) {
+                if (key.isEncrypted()) {
+                    first = key;
+                    break;
+                }
+            }
+            checkState(first != null, "No encrypted keys in the wallet");
+
+            try {
+                ECKey rebornKey = first.decrypt(keyCrypter, aesKey);
+                return Arrays.equals(first.getPubKey(), rebornKey.getPubKey());
+            } catch (KeyCrypterException e) {
+                // The AES key supplied is incorrect.
+                return false;
+            }
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //
+    // Bloom filtering support
+    //
+    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+    @Override
+    public BloomFilter getFilter(int size, double falsePositiveRate, long tweak) {
+        BloomFilter filter = new BloomFilter(size, falsePositiveRate, tweak);
+        for (ECKey key : hashToKeys.values()) {
+            filter.insert(key.getPubKey());
+            filter.insert(key.getPubKeyHash());
+        }
+        return filter;
+    }
+
+    @Override
+    public int numBloomFilterEntries() {
+        return numKeys() * 2;
+    }
+}
diff --git a/core/src/main/java/com/google/bitcoin/wallet/DeterministicKeyChain.java b/core/src/main/java/com/google/bitcoin/wallet/DeterministicKeyChain.java
new file mode 100644
index 0000000..70e6935
--- /dev/null
+++ b/core/src/main/java/com/google/bitcoin/wallet/DeterministicKeyChain.java
@@ -0,0 +1,698 @@
+/**
+ * Copyright 2013 The bitcoinj developers.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.bitcoin.wallet;
+
+import com.google.bitcoin.core.BloomFilter;
+import com.google.bitcoin.core.ECKey;
+import com.google.bitcoin.core.Utils;
+import com.google.bitcoin.crypto.*;
+import com.google.bitcoin.store.UnreadableWalletException;
+import com.google.bitcoin.utils.Threading;
+import com.google.common.collect.ImmutableList;
+import com.google.protobuf.ByteString;
+import org.bitcoinj.wallet.Protos;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.spongycastle.crypto.params.KeyParameter;
+import org.spongycastle.math.ec.ECPoint;
+
+import javax.annotation.Nullable;
+import java.math.BigInteger;
+import java.security.SecureRandom;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.Executor;
+import java.util.concurrent.locks.ReentrantLock;
+
+import static com.google.common.base.Preconditions.*;
+import static com.google.common.collect.Lists.newLinkedList;
+
+/**
+ * <p>A deterministic key chain is a {@link KeyChain} that uses the
+ * <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32 standard</a>, as implemented by
+ * {@link com.google.bitcoin.crypto.DeterministicHierarchy}, to derive all the keys in the keychain from a master seed.
+ * This type of wallet is extremely convenient and flexible. Although backing up full wallet files is always a good
+ * idea, to recover money only the root seed needs to be preserved and that is a number small enough that it can be
+ * written down on paper or, when represented using a BIP 39 {@link com.google.bitcoin.crypto.MnemonicCode},
+ * dictated over the phone (possibly even memorized).</p>
+ *
+ * <p>Deterministic key chains have other advantages: parts of the key tree can be selectively revealed to allow
+ * for auditing, and new public keys can be generated without access to the private keys, yielding a highly secure
+ * configuration for web servers which can accept payments into a wallet but not spend from them. This does not work
+ * quite how you would expect due to a quirk of elliptic curve mathematics and the techniques used to deal with it.
+ * A watching wallet is not instantiated using the public part of the master key as you may imagine. Instead, you
+ * need to take the account key (first child of the master key) and provide the public part of that to the watching
+ * wallet instead. You can do this by calling {@link #getWatchingKey()} and then serializing it with
+ * {@link com.google.bitcoin.crypto.DeterministicKey#serializePubB58()}. The resulting "xpub..." string encodes
+ * sufficient information about the account key to create a watching chain via
+ * {@link com.google.bitcoin.crypto.DeterministicKey#deserializeB58(com.google.bitcoin.crypto.DeterministicKey, String)}
+ * (with null as the first parameter) and then
+ * {@link DeterministicKeyChain#DeterministicKeyChain(com.google.bitcoin.crypto.DeterministicKey)}.</p>
+ *
+ * <p>This class builds on {@link com.google.bitcoin.crypto.DeterministicHierarchy} and
+ * {@link com.google.bitcoin.crypto.DeterministicKey} by adding support for serialization to and from protobufs,
+ * and encryption of parts of the key tree. Internally it arranges itself as per the BIP 32 spec, with the seed being
+ * used to derive a master key, which is then used to derive an account key, the account key is used to derive two
+ * child keys called the <i>internal</i> and <i>external</i> keys (for change and handing out addresses respectively)
+ * and finally the actual leaf keys that users use hanging off the end. The leaf keys are special in that they don't
+ * internally store the private part at all, instead choosing to rederive the private key from the parent when
+ * needed for signing. This simplifies the design for encrypted key chains.</p>
+ */
+public class DeterministicKeyChain implements EncryptableKeyChain {
+    private static final Logger log = LoggerFactory.getLogger(DeterministicKeyChain.class);
+    private final ReentrantLock lock = Threading.lock("DeterministicKeyChain");
+
+    private DeterministicHierarchy hierarchy;
+    private DeterministicKey rootKey;
+    private DeterministicSeed seed;
+
+    // Paths through the key tree. External keys are ones that are communicated to other parties. Internal keys are
+    // keys created for change addresses, coinbases, mixing, etc - anything that isn't communicated. The distinction
+    // is somewhat arbitrary but can be useful for audits. The first number is the "account number" but we don't use
+    // that feature yet. In future we might hand out different accounts for cases where we wish to hand payers
+    // a payment request that can generate lots of addresses independently.
+    public static final ImmutableList<ChildNumber> ACCOUNT_ZERO_PATH = ImmutableList.of(ChildNumber.ZERO_HARDENED);
+    public static final ImmutableList<ChildNumber> EXTERNAL_PATH = ImmutableList.of(ChildNumber.ZERO_HARDENED, ChildNumber.ZERO);
+    public static final ImmutableList<ChildNumber> INTERNAL_PATH = ImmutableList.of(ChildNumber.ZERO_HARDENED, new ChildNumber(1, false));
+
+    // We try to ensure we have at least this many keys ready and waiting to be handed out via getKey().
+    // See docs for getLookaheadSize() for more info on what this is for. The -1 value means it hasn't been calculated
+    // yet. For new chains it's set to whatever the default is, unless overridden by setLookaheadSize. For deserialized
+    // chains, it will be calculated on demand from the number of loaded keys.
+    private static final int LAZY_CALCULATE_LOOKAHEAD = -1;
+    private int lookaheadSize = 100;
+
+    // The parent keys for external keys (handed out to other people) and internal keys (used for change addresses).
+    private DeterministicKey externalKey, internalKey;
+    // How many keys on each path have actually been used. This may be fewer than the number that have been deserialized
+    // or held in memory, because of the lookahead zone.
+    private int issuedExternalKeys, issuedInternalKeys;
+
+    // We simplify by wrapping a basic key chain and that way we get some functionality like key lookup and event
+    // listeners "for free". All keys in the key tree appear here, even if they aren't meant to be used for receiving
+    // money.
+    private final BasicKeyChain basicKeyChain;
+
+    /**
+     * Generates a new key chain with a 128 bit seed selected randomly from the given {@link java.security.SecureRandom}
+     * object.
+     */
+    public DeterministicKeyChain(SecureRandom random) {
+        this(getRandomSeed(random), Utils.currentTimeMillis() / 1000);
+    }
+
+    private static byte[] getRandomSeed(SecureRandom random) {
+        byte[] seed = new byte[128 / 8];
+        random.nextBytes(seed);
+        return seed;
+    }
+
+    /**
+     * Creates a deterministic key chain starting from the given seed. All keys yielded by this chain will be the same
+     * if the starting seed is the same. You should provide the creation time in seconds since the UNIX epoch for the
+     * seed: this lets us know from what part of the chain we can expect to see derived keys appear.
+     */
+    public DeterministicKeyChain(byte[] seed, long seedCreationTimeSecs) {
+        this(new DeterministicSeed(seed, seedCreationTimeSecs));
+    }
+
+    public DeterministicKeyChain(DeterministicSeed seed) {
+        this(seed, null);
+    }
+
+    /**
+     * Creates a deterministic key chain that watches the given (public only) root key. You can use this to calculate
+     * balances and generally follow along, but spending is not possible with such a chain. Currently you can't use
+     * this method to watch an arbitrary fragment of some other tree, this limitation may be removed in future.
+     */
+    public DeterministicKeyChain(DeterministicKey watchingKey) {
+        checkArgument(watchingKey.isPubKeyOnly(), "Private subtrees not currently supported");
+        checkArgument(watchingKey.getPath().size() == 1, "You can only watch an account key currently");
+        basicKeyChain = new BasicKeyChain();
+        initializeHierarchyUnencrypted(watchingKey);
+    }
+
+    public static DeterministicKeyChain watch(DeterministicKey accountKey) {
+        return new DeterministicKeyChain(accountKey);
+    }
+
+    DeterministicKeyChain(DeterministicSeed seed, @Nullable KeyCrypter crypter) {
+        this.seed = seed;
+        basicKeyChain = new BasicKeyChain(crypter);
+        if (!seed.isEncrypted()) {
+            rootKey = HDKeyDerivation.createMasterPrivateKey(checkNotNull(seed.getSecretBytes()));
+            initializeHierarchyUnencrypted(rootKey);
+        } else {
+            // We can't initialize ourselves with just an encrypted seed, so we expected deserialization code to do the
+            // rest of the setup (loading the root key).
+        }
+    }
+
+    // For use in encryption.
+    private DeterministicKeyChain(KeyCrypter crypter, KeyParameter aesKey, DeterministicKeyChain chain) {
+        checkArgument(!chain.rootKey.isEncrypted(), "Chain already encrypted");
+
+        this.issuedExternalKeys = chain.issuedExternalKeys;
+        this.issuedInternalKeys = chain.issuedInternalKeys;
+
+        this.lookaheadSize = chain.lookaheadSize;
+
+        this.seed = chain.seed.encrypt(crypter, aesKey);
+        basicKeyChain = new BasicKeyChain(crypter);
+        // The first number is the "account number" but we don't use that feature.
+        rootKey = chain.rootKey.encrypt(crypter, aesKey, null);
+        hierarchy = new DeterministicHierarchy(rootKey);
+        basicKeyChain.importKey(rootKey);
+
+        DeterministicKey account = encryptNonLeaf(aesKey, chain, rootKey, ACCOUNT_ZERO_PATH);
+        externalKey = encryptNonLeaf(aesKey, chain, account, EXTERNAL_PATH);
+        internalKey = encryptNonLeaf(aesKey, chain, account, INTERNAL_PATH);
+
+        // Now copy the (pubkey only) leaf keys across to avoid rederiving them. The private key bytes are missing
+        // anyway so there's nothing to encrypt.
+        for (ECKey eckey : chain.basicKeyChain.getKeys()) {
+            DeterministicKey key = (DeterministicKey) eckey;
+            if (key.getPath().size() != 3) continue; // Not a leaf key.
+            DeterministicKey parent = hierarchy.get(checkNotNull(key.getParent()).getPath(), false, false);
+            // Clone the key to the new encrypted hierarchy.
+            key = new DeterministicKey(key.getPubOnly(), parent);
+            hierarchy.putKey(key);
+            basicKeyChain.importKey(key);
+        }
+    }
+
+    private DeterministicKey encryptNonLeaf(KeyParameter aesKey, DeterministicKeyChain chain,
+                                            DeterministicKey parent, ImmutableList<ChildNumber> path) {
+        DeterministicKey key = chain.hierarchy.get(path, false, false);
+        key = key.encrypt(checkNotNull(basicKeyChain.getKeyCrypter()), aesKey, parent);
+        hierarchy.putKey(key);
+        basicKeyChain.importKey(key);
+        return key;
+    }
+
+    // Derives the account path keys and inserts them into the basic key chain. This is important to preserve their
+    // order for serialization, amongst other things.
+    private void initializeHierarchyUnencrypted(DeterministicKey baseKey) {
+        if (baseKey.getPath().isEmpty()) {
+            // baseKey is a master/root key derived directly from a seed.
+            addToBasicChain(rootKey);
+            hierarchy = new DeterministicHierarchy(rootKey);
+            addToBasicChain(hierarchy.get(ACCOUNT_ZERO_PATH, false, true));
+        } else if (baseKey.getPath().size() == 1) {
+            // baseKey is a "watching key" that we were given so we could follow along with this account.
+            rootKey = null;
+            addToBasicChain(baseKey);
+            hierarchy = new DeterministicHierarchy(baseKey);
+        } else {
+            throw new IllegalArgumentException();
+        }
+        externalKey = hierarchy.deriveChild(ACCOUNT_ZERO_PATH, false, false, ChildNumber.ZERO);
+        internalKey = hierarchy.deriveChild(ACCOUNT_ZERO_PATH, false, false, ChildNumber.ONE);
+        addToBasicChain(externalKey);
+        addToBasicChain(internalKey);
+    }
+
+    /** Returns a freshly derived key that has not been returned by this method before. */
+    @Override
+    public DeterministicKey getKey(KeyPurpose purpose) {
+        lock.lock();
+        try {
+            DeterministicKey key, parentKey;
+            int index;
+            switch (purpose) {
+                // Map both REFUND and RECEIVE_KEYS to the same branch for now. Refunds are a feature of the BIP 70
+                // payment protocol. Later we may wish to map it to a different branch (in a new wallet version?).
+                // This would allow a watching wallet to only be able to see inbound payments, but not change
+                // (i.e. spends) or refunds. Might be useful for auditing ...
+                case RECEIVE_FUNDS:
+                case REFUND:
+                    index = ++issuedExternalKeys;
+                    parentKey = externalKey;
+                    break;
+                case CHANGE:
+                    index = ++issuedInternalKeys;
+                    parentKey = internalKey;
+                    break;
+                default:
+                    throw new UnsupportedOperationException();
+            }
+            // TODO: Handle the case where the derived key is >= curve order.
+            List<DeterministicKey> lookahead = maybeLookAhead(parentKey, index);
+            basicKeyChain.importKeys(lookahead);
+            key = hierarchy.get(HDUtils.append(parentKey.getPath(), new ChildNumber(index - 1, false)), false, false);
+            return key;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    private void addToBasicChain(DeterministicKey key) {
+        basicKeyChain.importKeys(ImmutableList.of(key));
+    }
+
+    @Override
+    public DeterministicKey findKeyFromPubHash(byte[] pubkeyHash) {
+        lock.lock();
+        try {
+            return (DeterministicKey) basicKeyChain.findKeyFromPubHash(pubkeyHash);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public DeterministicKey findKeyFromPubKey(byte[] pubkey) {
+        lock.lock();
+        try {
+            return (DeterministicKey) basicKeyChain.findKeyFromPubKey(pubkey);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public boolean hasKey(ECKey key) {
+        lock.lock();
+        try {
+            return basicKeyChain.hasKey(key);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /** Returns the deterministic key for the given absolute path in the hierarchy. */
+    protected DeterministicKey getKeyByPath(ChildNumber... path) {
+        return getKeyByPath(ImmutableList.<ChildNumber>copyOf(path));
+    }
+
+    /** Returns the deterministic key for the given absolute path in the hierarchy. */
+    protected DeterministicKey getKeyByPath(ImmutableList<ChildNumber> path) {
+        return hierarchy.get(path, false, false);
+    }
+
+    /**
+     * <p>An alias for <code>getKeyByPath(DeterministicKeyChain.ACCOUNT_ZERO_PATH).getPubOnly()</code>.
+     * Use this when you would like to create a watching key chain that follows this one, but can't spend money from it.
+     * The returned key can be serialized and then passed into {@link #watch(com.google.bitcoin.crypto.DeterministicKey)}
+     * on another system to watch the hierarchy.</p>
+     */
+    public DeterministicKey getWatchingKey() {
+        return getKeyByPath(ACCOUNT_ZERO_PATH).getPubOnly();
+    }
+
+    @Override
+    public int numKeys() {
+        // We need to return here the total number of keys including the lookahead zone, not the number of keys we
+        // have issued via getKey/freshReceiveKey.
+        return basicKeyChain.numKeys();
+    }
+
+    @Override
+    public long getEarliestKeyCreationTime() {
+        return seed != null ? seed.getCreationTimeSeconds() : Utils.currentTimeSeconds();
+    }
+
+    @Override
+    public void addEventListener(KeyChainEventListener listener) {
+        basicKeyChain.addEventListener(listener);
+    }
+
+    @Override
+    public void addEventListener(KeyChainEventListener listener, Executor executor) {
+        basicKeyChain.addEventListener(listener, executor);
+    }
+
+    @Override
+    public boolean removeEventListener(KeyChainEventListener listener) {
+        return basicKeyChain.removeEventListener(listener);
+    }
+
+    /** Returns a list of words that represent the seed. */
+    public List<String> toMnemonicCode() {
+        lock.lock();
+        try {
+            return seed.toMnemonicCode();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //
+    // Serialization support
+    //
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public List<Protos.Key> serializeToProtobuf() {
+        lock.lock();
+        try {
+            // Most of the serialization work is delegated to the basic key chain, which will serialize the bulk of the
+            // data (handling encryption along the way), and letting us patch it up with the extra data we care about.
+            LinkedList<Protos.Key> entries = newLinkedList();
+            if (seed != null) {
+                Protos.Key.Builder seedEntry = BasicKeyChain.serializeEncryptableItem(seed);
+                seedEntry.setType(Protos.Key.Type.DETERMINISTIC_ROOT_SEED);
+                entries.add(seedEntry.build());
+            }
+            Map<ECKey, Protos.Key.Builder> keys = basicKeyChain.serializeToEditableProtobufs();
+            for (Map.Entry<ECKey, Protos.Key.Builder> entry : keys.entrySet()) {
+                DeterministicKey key = (DeterministicKey) entry.getKey();
+                Protos.Key.Builder proto = entry.getValue();
+                proto.setType(Protos.Key.Type.DETERMINISTIC_KEY);
+                final Protos.DeterministicKey.Builder detKey = proto.getDeterministicKeyBuilder();
+                detKey.setChainCode(ByteString.copyFrom(key.getChainCode()));
+                for (ChildNumber num : key.getPath())
+                    detKey.addPath(num.i());
+                if (key.equals(externalKey)) {
+                    detKey.setIssuedSubkeys(issuedExternalKeys);
+                    detKey.setLookaheadSize(lookaheadSize);
+                } else if (key.equals(internalKey)) {
+                    detKey.setIssuedSubkeys(issuedInternalKeys);
+                    detKey.setLookaheadSize(lookaheadSize);
+                }
+                entries.add(proto.build());
+            }
+            return entries;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Returns all the key chains found in the given list of keys. Typically there will only be one, but in the case of
+     * key rotation it can happen that there are multiple chains found.
+     */
+    public static List<DeterministicKeyChain> fromProtobuf(List<Protos.Key> keys, @Nullable KeyCrypter crypter) throws UnreadableWalletException {
+        List<DeterministicKeyChain> chains = newLinkedList();
+        DeterministicSeed seed = null;
+        DeterministicKeyChain chain = null;
+        int lookaheadSize = -1;
+        for (Protos.Key key : keys) {
+            final Protos.Key.Type t = key.getType();
+            if (t == Protos.Key.Type.DETERMINISTIC_ROOT_SEED) {
+                if (chain != null) {
+                    checkState(lookaheadSize >= 0);
+                    chain.setLookaheadSize(lookaheadSize);
+                    chain.maybeLookAhead();
+                    chains.add(chain);
+                    chain = null;
+                }
+                long timestamp = key.getCreationTimestamp() / 1000;
+                if (key.hasSecretBytes()) {
+                    seed = new DeterministicSeed(key.getSecretBytes().toByteArray(), timestamp);
+                } else if (key.hasEncryptedData()) {
+                    EncryptedData data = new EncryptedData(key.getEncryptedData().getInitialisationVector().toByteArray(),
+                            key.getEncryptedData().getEncryptedPrivateKey().toByteArray());
+                    seed = new DeterministicSeed(data, timestamp);
+                } else {
+                    throw new UnreadableWalletException("Malformed key proto: " + key.toString());
+                }
+                if (log.isDebugEnabled())
+                    log.debug("Deserializing: DETERMINISTIC_ROOT_SEED: {}", seed);
+            } else if (t == Protos.Key.Type.DETERMINISTIC_KEY) {
+                if (!key.hasDeterministicKey())
+                    throw new UnreadableWalletException("Deterministic key missing extra data: " + key.toString());
+                byte[] chainCode = key.getDeterministicKey().getChainCode().toByteArray();
+                // Deserialize the path through the tree.
+                LinkedList<ChildNumber> path = newLinkedList();
+                for (int i : key.getDeterministicKey().getPathList())
+                    path.add(new ChildNumber(i));
+                // Deserialize the public key and path.
+                ECPoint pubkey = ECKey.CURVE.getCurve().decodePoint(key.getPublicKey().toByteArray());
+                final ImmutableList<ChildNumber> immutablePath = ImmutableList.copyOf(path);
+                // Possibly create the chain, if we didn't already do so yet.
+                boolean isWatchingAccountKey = false;
+                if (chain == null) {
+                    if (seed == null) {
+                        DeterministicKey accountKey = new DeterministicKey(immutablePath, chainCode, pubkey, null, null);
+                        if (!accountKey.getPath().equals(ACCOUNT_ZERO_PATH))
+                            throw new UnreadableWalletException("Expecting account key but found key with path: " +
+                                    HDUtils.formatPath(accountKey.getPath()));
+                        chain = new DeterministicKeyChain(accountKey);
+                        isWatchingAccountKey = true;
+                    } else {
+                        chain = new DeterministicKeyChain(seed, crypter);
+                        chain.lookaheadSize = LAZY_CALCULATE_LOOKAHEAD;
+                        // If the seed is encrypted, then the chain is incomplete at this point. However, we will load
+                        // it up below as we parse in the keys. We just need to check at the end that we've loaded
+                        // everything afterwards.
+                    }
+                }
+                // Find the parent key assuming this is not the root key, and not an account key for a watching chain.
+                DeterministicKey parent = null;
+                if (!path.isEmpty() && !isWatchingAccountKey) {
+                    ChildNumber index = path.removeLast();
+                    parent = chain.hierarchy.get(path, false, false);
+                    path.add(index);
+                }
+                DeterministicKey detkey;
+                if (key.hasSecretBytes()) {
+                    // Not encrypted: private key is available.
+                    final BigInteger priv = new BigInteger(1, key.getSecretBytes().toByteArray());
+                    detkey = new DeterministicKey(immutablePath, chainCode, pubkey, priv, parent);
+                } else {
+                    if (key.hasEncryptedData()) {
+                        Protos.EncryptedData proto = key.getEncryptedData();
+                        EncryptedData data = new EncryptedData(proto.getInitialisationVector().toByteArray(),
+                                proto.getEncryptedPrivateKey().toByteArray());
+                        checkNotNull(crypter, "Encountered an encrypted key but no key crypter provided");
+                        detkey = new DeterministicKey(immutablePath, chainCode, crypter, pubkey, data, parent);
+                    } else {
+                        // No secret key bytes and key is not encrypted: either a watching key or private key bytes
+                        // will be rederived on the fly from the parent.
+                        detkey = new DeterministicKey(immutablePath, chainCode, pubkey, null, parent);
+                    }
+                }
+                if (log.isDebugEnabled())
+                    log.debug("Deserializing: DETERMINISTIC_KEY: {}", detkey);
+                if (!isWatchingAccountKey) {
+                    // If the non-encrypted case, the non-leaf keys (account, internal, external) have already been
+                    // rederived and inserted at this point and the two lines below are just a no-op. In the encrypted
+                    // case though, we can't rederive and we must reinsert, potentially building the heirarchy object
+                    // if need be.
+                    if (path.size() == 0) {
+                        // Master key.
+                        chain.rootKey = detkey;
+                        chain.hierarchy = new DeterministicHierarchy(detkey);
+                    } else if (path.size() == 2) {
+                        if (detkey.getChildNumber().num() == 0) {
+                            chain.externalKey = detkey;
+                            chain.issuedExternalKeys = key.getDeterministicKey().getIssuedSubkeys();
+                            lookaheadSize = Math.max(lookaheadSize, key.getDeterministicKey().getLookaheadSize());
+                        } else if (detkey.getChildNumber().num() == 1) {
+                            chain.internalKey = detkey;
+                            chain.issuedInternalKeys = key.getDeterministicKey().getIssuedSubkeys();
+                        }
+                    }
+                }
+                chain.hierarchy.putKey(detkey);
+                chain.basicKeyChain.importKey(detkey);
+            }
+        }
+        if (chain != null) {
+            checkState(lookaheadSize >= 0);
+            chain.setLookaheadSize(lookaheadSize);
+            chain.maybeLookAhead();
+            chains.add(chain);
+        }
+        return chains;
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //
+    // Encryption support
+    //
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public DeterministicKeyChain toEncrypted(CharSequence password) {
+        checkNotNull(password);
+        checkArgument(password.length() > 0);
+        checkState(seed != null, "Attempt to encrypt a watching chain.");
+        checkState(!seed.isEncrypted());
+        KeyCrypter scrypt = new KeyCrypterScrypt();
+        KeyParameter derivedKey = scrypt.deriveKey(password);
+        return toEncrypted(scrypt, derivedKey);
+    }
+
+    @Override
+    public DeterministicKeyChain toEncrypted(KeyCrypter keyCrypter, KeyParameter aesKey) {
+        return new DeterministicKeyChain(keyCrypter, aesKey, this);
+    }
+
+    @Override
+    public DeterministicKeyChain toDecrypted(CharSequence password) {
+        checkNotNull(password);
+        checkArgument(password.length() > 0);
+        KeyCrypter crypter = getKeyCrypter();
+        checkState(crypter != null, "Chain not encrypted");
+        KeyParameter derivedKey = crypter.deriveKey(password);
+        return toDecrypted(derivedKey);
+    }
+
+    @Override
+    public DeterministicKeyChain toDecrypted(KeyParameter aesKey) {
+        checkState(getKeyCrypter() != null, "Key chain not encrypted");
+        checkState(seed.isEncrypted());
+        DeterministicSeed decSeed = seed.decrypt(getKeyCrypter(), aesKey);
+        DeterministicKeyChain chain = new DeterministicKeyChain(decSeed);
+        chain.lookaheadSize = lookaheadSize;
+        // Now copy the (pubkey only) leaf keys across to avoid rederiving them. The private key bytes are missing
+        // anyway so there's nothing to decrypt.
+        for (ECKey eckey : basicKeyChain.getKeys()) {
+            DeterministicKey key = (DeterministicKey) eckey;
+            if (key.getPath().size() != 3) continue; // Not a leaf key.
+            checkState(key.isEncrypted());
+            DeterministicKey parent = chain.hierarchy.get(checkNotNull(key.getParent()).getPath(), false, false);
+            // Clone the key to the new decrypted hierarchy.
+            key = new DeterministicKey(key.getPubOnly(), parent);
+            chain.hierarchy.putKey(key);
+            chain.basicKeyChain.importKey(key);
+        }
+        chain.issuedExternalKeys = issuedExternalKeys;
+        chain.issuedInternalKeys = issuedInternalKeys;
+        return chain;
+    }
+
+    @Override
+    public boolean checkPassword(CharSequence password) {
+        checkNotNull(password);
+        checkState(getKeyCrypter() != null, "Key chain not encrypted");
+        return checkAESKey(getKeyCrypter().deriveKey(password));
+    }
+
+    @Override
+    public boolean checkAESKey(KeyParameter aesKey) {
+        checkNotNull(aesKey);
+        checkState(getKeyCrypter() != null, "Key chain not encrypted");
+        try {
+            return rootKey.decrypt(getKeyCrypter(), aesKey).getPubKeyPoint().equals(rootKey.getPubKeyPoint());
+        } catch (KeyCrypterException e) {
+            return false;
+        }
+    }
+
+    @Nullable
+    @Override
+    public KeyCrypter getKeyCrypter() {
+        return basicKeyChain.getKeyCrypter();
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //
+    // Bloom filtering support
+    //
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+    @Override
+    public int numBloomFilterEntries() {
+        return numKeys() * 2;
+    }
+
+    @Override
+    public BloomFilter getFilter(int size, double falsePositiveRate, long tweak) {
+        checkArgument(size >= numBloomFilterEntries());
+        return basicKeyChain.getFilter(size, falsePositiveRate, tweak);
+    }
+
+    /**
+     * <p>The number of public keys we should pre-generate on each path before they are requested by the app. This is
+     * required so that when scanning through the chain given only a seed, we can give enough keys to the remote node
+     * via the Bloom filter such that we see transactions that are "from the future", for example transactions created
+     * by a different app that's sharing the same seed, or transactions we made before but we're replaying the chain
+     * given just the seed. The default is 100.</p>
+     */
+    public int getLookaheadSize() {
+        lock.lock();
+        try {
+            return lookaheadSize;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Sets a new lookahead size. See {@link #getLookaheadSize()} for details on what this is. Setting a new size
+     * that's larger than the current size will return immediately and the new size will only take effect next time
+     * a fresh filter is requested (e.g. due to a new peer being connected). So you should set this before starting
+     * to sync the chain, if you want to modify it.
+     */
+    public void setLookaheadSize(int lookaheadSize) {
+        lock.lock();
+        try {
+            this.lookaheadSize = lookaheadSize;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    // Pre-generate enough keys to reach the lookahead size.
+    private void maybeLookAhead() {
+        lock.lock();
+        try {
+            List<DeterministicKey> keys = maybeLookAhead(externalKey, issuedExternalKeys);
+            keys.addAll(maybeLookAhead(internalKey, issuedInternalKeys));
+            // Batch add all keys at once so there's only one event listener invocation, as this will be listened to
+            // by the wallet and used to rebuild/broadcast the Bloom filter. That's expensive so we don't want to do
+            // it more often than necessary.
+            basicKeyChain.importKeys(keys);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    // Returned keys must be inserted into the basic key chain.
+    private List<DeterministicKey> maybeLookAhead(DeterministicKey parent, int issued) {
+        checkState(lock.isHeldByCurrentThread());
+        final int numChildren = hierarchy.getNumChildren(parent.getPath());
+        int needed = issued + getLookaheadSize() - numChildren;
+        checkState(needed >= 0, "needed = " + needed);
+        List<DeterministicKey> result  = new ArrayList<DeterministicKey>(needed);
+        if (needed == 0) return result;
+        long now = System.currentTimeMillis();
+        log.info("Pre-generating {} keys for {}", needed, parent.getPathAsString());
+        for (int i = 0; i < needed; i++) {
+            // TODO: Handle the case where the derived key is >= curve order.
+            DeterministicKey key = HDKeyDerivation.deriveChildKey(parent, numChildren + i);
+            key = key.getPubOnly();
+            hierarchy.putKey(key);
+            result.add(key);
+        }
+        log.info("Took {} msec", System.currentTimeMillis() - now);
+        return result;
+    }
+
+    /** Returns the seed or null if this chain is encrypted or watching. */
+    @Nullable
+    public DeterministicSeed getSeed() {
+        lock.lock();
+        try {
+            return seed;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    // For internal usage only (for printing keys in KeyChainGroup).
+    /* package */ List<ECKey> getKeys() {
+        return basicKeyChain.getKeys();
+    }
+}
diff --git a/core/src/main/java/com/google/bitcoin/wallet/DeterministicSeed.java b/core/src/main/java/com/google/bitcoin/wallet/DeterministicSeed.java
new file mode 100644
index 0000000..1578296
--- /dev/null
+++ b/core/src/main/java/com/google/bitcoin/wallet/DeterministicSeed.java
@@ -0,0 +1,151 @@
+/**
+ * Copyright 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.bitcoin.wallet;
+
+import com.google.bitcoin.crypto.*;
+import org.bitcoinj.wallet.Protos;
+import org.spongycastle.crypto.params.KeyParameter;
+import org.spongycastle.util.encoders.Hex;
+
+import javax.annotation.Nullable;
+import java.io.IOException;
+import java.util.List;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+
+/**
+ * Holds the seed bytes for the BIP32 deterministic wallet algorithm, inside a
+ * {@link com.google.bitcoin.wallet.DeterministicKeyChain}. The purpose of this wrapper is to simplify the encryption
+ * code.
+ */
+public class DeterministicSeed implements EncryptableItem {
+    @Nullable private final byte[] unencryptedSeed;
+    @Nullable private final EncryptedData encryptedSeed;
+    private final long creationTimeSeconds;
+
+    private static MnemonicCode MNEMONIC_CODE;
+    private static synchronized MnemonicCode getCachedMnemonicCode() {
+        try {
+            // This object can be large and has to load the word list from disk, so we lazy cache it.
+            if (MNEMONIC_CODE == null) {
+                MNEMONIC_CODE = new MnemonicCode();
+            }
+            return MNEMONIC_CODE;
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public DeterministicSeed(byte[] unencryptedSeed, long creationTimeSeconds) {
+        this.unencryptedSeed = checkNotNull(unencryptedSeed);
+        this.encryptedSeed = null;
+        this.creationTimeSeconds = creationTimeSeconds;
+    }
+
+    public DeterministicSeed(EncryptedData encryptedSeed, long creationTimeSeconds) {
+        this.unencryptedSeed = null;
+        this.encryptedSeed = checkNotNull(encryptedSeed);
+        this.creationTimeSeconds = creationTimeSeconds;
+    }
+
+    /**
+     * Constructs a seed from a BIP 39 mnemonic code. See {@link com.google.bitcoin.crypto.MnemonicCode} for more
+     * details on this scheme.
+     * @param words A list of words.
+     * @param creationTimeSeconds When the seed was originally created, UNIX time.
+     * @throws MnemonicException if there is a problem decoding the words.
+     */
+    public DeterministicSeed(List<String> words, long creationTimeSeconds) throws MnemonicException.MnemonicChecksumException, MnemonicException.MnemonicLengthException, MnemonicException.MnemonicWordException {
+        this(getCachedMnemonicCode().toEntropy(words), creationTimeSeconds);
+    }
+
+    @Override
+    public boolean isEncrypted() {
+        checkState(unencryptedSeed != null || encryptedSeed != null);
+        return encryptedSeed != null;
+    }
+
+    @Override
+    public String toString() {
+        if (isEncrypted())
+            return "DeterministicSeed [encrypted]";
+        else
+            return "DeterministicSeed " + toHexString();
+    }
+
+    /** Returns the seed as hex or null if encrypted. */
+    @Nullable
+    public String toHexString() {
+        if (unencryptedSeed != null)
+            return new String(Hex.encode(unencryptedSeed));
+        else
+            return null;
+    }
+
+    @Nullable
+    @Override
+    public byte[] getSecretBytes() {
+        return unencryptedSeed;
+    }
+
+    @Nullable
+    @Override
+    public EncryptedData getEncryptedData() {
+        return encryptedSeed;
+    }
+
+    @Override
+    public Protos.Wallet.EncryptionType getEncryptionType() {
+        return Protos.Wallet.EncryptionType.ENCRYPTED_SCRYPT_AES;
+    }
+
+    @Override
+    public long getCreationTimeSeconds() {
+        return creationTimeSeconds;
+    }
+
+    public DeterministicSeed encrypt(KeyCrypter keyCrypter, KeyParameter aesKey) {
+        checkState(encryptedSeed == null, "Trying to encrypt seed twice");
+        checkState(unencryptedSeed != null, "Seed bytes missing so cannot encrypt");
+        EncryptedData data = keyCrypter.encrypt(unencryptedSeed, aesKey);
+        return new DeterministicSeed(data, creationTimeSeconds);
+    }
+
+    public DeterministicSeed decrypt(KeyCrypter crypter, KeyParameter aesKey) {
+        checkState(isEncrypted());
+        checkNotNull(encryptedSeed);
+        return new DeterministicSeed(crypter.decrypt(encryptedSeed, aesKey), creationTimeSeconds);
+    }
+
+    /** Returns a list of words that represent the seed, or IllegalStateException if the seed is encrypted or missing. */
+    public List<String> toMnemonicCode(MnemonicCode code) {
+        try {
+            if (isEncrypted())
+                throw new IllegalStateException("The seed is encrypted");
+            final byte[] seed = checkNotNull(getSecretBytes());
+            return code.toMnemonic(seed);
+        } catch (MnemonicException.MnemonicLengthException e) {
+            throw new RuntimeException(e);  // Cannot happen.
+        }
+    }
+
+    /** Returns a list of words that represent the seed, or IllegalStateException if the seed is encrypted or missing. */
+    public List<String> toMnemonicCode() {
+        return toMnemonicCode(getCachedMnemonicCode());
+    }
+}
diff --git a/core/src/main/java/com/google/bitcoin/wallet/EncryptableKeyChain.java b/core/src/main/java/com/google/bitcoin/wallet/EncryptableKeyChain.java
new file mode 100644
index 0000000..7bdde56
--- /dev/null
+++ b/core/src/main/java/com/google/bitcoin/wallet/EncryptableKeyChain.java
@@ -0,0 +1,67 @@
+/**
+ * Copyright 2013 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.bitcoin.wallet;
+
+import com.google.bitcoin.crypto.KeyCrypter;
+import com.google.bitcoin.crypto.KeyCrypterException;
+import org.spongycastle.crypto.params.KeyParameter;
+
+import javax.annotation.Nullable;
+
+/**
+ * An encryptable key chain is a key-chain that can be encrypted with a user-provided password or AES key.
+ */
+public interface EncryptableKeyChain extends KeyChain {
+    /**
+     * Takes the given password, which should be strong, derives a key from it and then invokes
+     * {@link #toEncrypted(com.google.bitcoin.crypto.KeyCrypter, org.spongycastle.crypto.params.KeyParameter)} with
+     * {@link com.google.bitcoin.crypto.KeyCrypterScrypt} as the crypter.
+     *
+     * @return The derived key, in case you wish to cache it for future use.
+     */
+    public EncryptableKeyChain toEncrypted(CharSequence password);
+
+    /**
+     * Returns a new keychain holding identical/cloned keys to this chain, but encrypted under the given key.
+     * Old keys and keychains remain valid and so you should ensure you don't accidentally hold references to them.
+     */
+    public EncryptableKeyChain toEncrypted(KeyCrypter keyCrypter, KeyParameter aesKey);
+
+    /**
+     * Decrypts the key chain with the given password. See {@link #toDecrypted(org.spongycastle.crypto.params.KeyParameter)}
+     * for details.
+     */
+    public EncryptableKeyChain toDecrypted(CharSequence password);
+
+    /**
+     * Decrypt the key chain with the given AES key and whatever {@link KeyCrypter} is already set. Note that if you
+     * just want to spend money from an encrypted wallet, don't decrypt the whole thing first. Instead, set the
+     * {@link com.google.bitcoin.core.Wallet.SendRequest#aesKey} field before asking the wallet to build the send.
+     *
+     * @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming to
+     *               create from a password)
+     * @throws KeyCrypterException Thrown if the wallet decryption fails. If so, the wallet state is unchanged.
+     */
+    public EncryptableKeyChain toDecrypted(KeyParameter aesKey);
+
+    public boolean checkPassword(CharSequence password);
+    public boolean checkAESKey(KeyParameter aesKey);
+
+    /** Returns the key crypter used by this key chain, or null if it's not encrypted. */
+    @Nullable
+    public KeyCrypter getKeyCrypter();
+}
diff --git a/core/src/main/java/com/google/bitcoin/wallet/KeyChain.java b/core/src/main/java/com/google/bitcoin/wallet/KeyChain.java
new file mode 100644
index 0000000..6d2ecf6
--- /dev/null
+++ b/core/src/main/java/com/google/bitcoin/wallet/KeyChain.java
@@ -0,0 +1,105 @@
+/**
+ * Copyright 2013 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.bitcoin.wallet;
+
+import com.google.bitcoin.core.BloomFilter;
+import com.google.bitcoin.core.ECKey;
+import org.bitcoinj.wallet.Protos;
+
+import java.util.List;
+import java.util.concurrent.Executor;
+
+/**
+ * <p>A KeyChain is a class that stores a collection of keys for a {@link com.google.bitcoin.core.Wallet}. Key chains
+ * are expected to be able to look up keys given a hash (i.e. address) or pubkey bytes, and provide keys on request
+ * for a given purpose. They can inform event listeners about new keys being added.</p>
+ *
+ * <p>However it is important to understand what this interface does <i>not</i> provide. It cannot encrypt or decrypt
+ * keys, for instance you need an implementor of {@link EncryptableKeyChain}. It cannot have keys imported into it,
+ * that you to use a method of a specific key chain instance, such as {@link BasicKeyChain}. The reason for these
+ * restrictions is to support key chains that may be handled by external hardware or software, or which are derived
+ * deterministically from a seed (and thus the notion of importing a key is meaningless).</p>
+ */
+public interface KeyChain {
+    /**
+     * Locates a keypair from the keychain given the hash of the public key. This is needed when finding out which
+     * key we need to use to redeem a transaction output.
+     *
+     * @return ECKey object or null if no such key was found.
+     */
+    public ECKey findKeyFromPubHash(byte[] pubkeyHash);
+
+    /**
+     * Locates a keypair from the keychain given the raw public key bytes.
+     * @return ECKey or null if no such key was found.
+     */
+    public ECKey findKeyFromPubKey(byte[] pubkey);
+
+    /** Returns true if the given key is in the chain. */
+    public boolean hasKey(ECKey key);
+
+    enum KeyPurpose {
+        RECEIVE_FUNDS,
+        CHANGE,
+        REFUND
+    }
+
+    /** Obtains a key intended for the given purpose. The chain may create a new key, derive one, or re-use an old one. */
+    public ECKey getKey(KeyPurpose purpose);
+
+    /** Returns a list of keys serialized to the bitcoinj protobuf format. */
+    public List<Protos.Key> serializeToProtobuf();
+
+    /** Adds a listener for events that are run when keys are added, on the user thread. */
+    public void addEventListener(KeyChainEventListener listener);
+
+    /** Adds a listener for events that are run when keys are added, on the given executor. */
+    public void addEventListener(KeyChainEventListener listener, Executor executor);
+
+    /** Removes a listener for events that are run when keys are added. */
+    public boolean removeEventListener(KeyChainEventListener listener);
+
+    /** Returns the number of keys this key chain manages. */
+    public int numKeys();
+
+    /**
+     * Returns the number of elements this chain wishes to insert into the Bloom filter. The size passed to
+     * {@link #getFilter(int, double, long)} should be at least this large.
+     */
+    public int numBloomFilterEntries();
+
+    /**
+     * <p>Returns the earliest creation time of keys in this chain, in seconds since the epoch. This can return zero
+     * if at least one key does not have that data (was created before key timestamping was implemented). If there
+     * are no keys in the wallet, {@link Long#MAX_VALUE} is returned.</p>
+     */
+    public long getEarliestKeyCreationTime();
+
+    /**
+     * <p>Gets a bloom filter that contains all of the public keys from this chain, and which will provide the given
+     * false-positive rate if it has size elements. Keep in mind that you will get 2 elements in the bloom filter for
+     * each key in the key chain, for the public key and the hash of the public key (address form). For this reason
+     * size should be <i>at least</i> 2x the result of {@link #numKeys()}.</p>
+     *
+     * <p>This is used to generate a {@link BloomFilter} which can be {@link BloomFilter#merge(BloomFilter)}d with
+     * another. It could also be used if you have a specific target for the filter's size.</p>
+     *
+     * <p>See the docs for {@link com.google.bitcoin.core.BloomFilter#BloomFilter(int, double, long)} for a brief
+     * explanation of anonymity when using bloom filters, and for the meaning of these parameters.</p>
+     */
+    public BloomFilter getFilter(int size, double falsePositiveRate, long tweak);
+}
diff --git a/core/src/main/java/com/google/bitcoin/wallet/KeyChainEventListener.java b/core/src/main/java/com/google/bitcoin/wallet/KeyChainEventListener.java
new file mode 100644
index 0000000..211ad21
--- /dev/null
+++ b/core/src/main/java/com/google/bitcoin/wallet/KeyChainEventListener.java
@@ -0,0 +1,29 @@
+/**
+ * Copyright 2013 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.bitcoin.wallet;
+
+import com.google.bitcoin.core.ECKey;
+
+import java.util.List;
+
+public interface KeyChainEventListener {
+    /**
+     * Called whenever a new key is added to the key chain, whether that be via an explicit addition or due to some
+     * other automatic derivation. See the documentation for your {@link KeyChain} implementation for details on what
+     * can trigger this event.
+     */
+    void onKeysAdded(List<ECKey> keys);
+}
diff --git a/core/src/main/java/com/google/bitcoin/wallet/KeyChainGroup.java b/core/src/main/java/com/google/bitcoin/wallet/KeyChainGroup.java
new file mode 100644
index 0000000..84b5fe2
--- /dev/null
+++ b/core/src/main/java/com/google/bitcoin/wallet/KeyChainGroup.java
@@ -0,0 +1,432 @@
+/**
+ * Copyright 2014 Mike Hearn
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.bitcoin.wallet;
+
+import com.google.bitcoin.core.*;
+import com.google.bitcoin.crypto.DeterministicKey;
+import com.google.bitcoin.crypto.KeyCrypter;
+import com.google.bitcoin.store.UnreadableWalletException;
+import com.google.bitcoin.utils.ListenerRegistration;
+import com.google.bitcoin.utils.Threading;
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Lists;
+import org.bitcoinj.wallet.Protos;
+import org.spongycastle.crypto.params.KeyParameter;
+
+import javax.annotation.Nullable;
+import java.security.SecureRandom;
+import java.util.*;
+import java.util.concurrent.Executor;
+
+import static com.google.common.base.Preconditions.*;
+
+/**
+ * <p>A KeyChainGroup is used by the {@link com.google.bitcoin.core.Wallet} and
+ * manages: a {@link com.google.bitcoin.wallet.BasicKeyChain} object (which will normally be empty), and zero or more
+ * {@link com.google.bitcoin.wallet.DeterministicKeyChain}s. A deterministic key chain will be created lazily/on demand
+ * when a fresh or current key is requested, possibly being initialized from the private key bytes of the earliest non
+ * rotating key in the basic key chain if one is available, or from a fresh random seed if not.</p>
+ *
+ * <p>If a key rotation time is set, it may be necessary to add a new DeterministicKeyChain with a fresh seed
+ * and also preserve the old one, so funds can be swept from the rotating keys. In this case, there may be
+ * more than one deterministic chain. The latest chain is called the active chain and is where new keys are served
+ * from.</p>
+ *
+ * <p>The wallet delegates most key management tasks to this class. It is <b>not</b> thread safe and requires external
+ * locking, i.e. by the wallet lock. The group then in turn delegates most operations to the key chain objects,
+ * combining their responses together when necessary.</p>
+ */
+public class KeyChainGroup implements PeerFilterProvider {
+    private BasicKeyChain basic;
+    private final List<DeterministicKeyChain> chains;
+    private final EnumMap<KeyChain.KeyPurpose, DeterministicKey> currentKeys;
+    @Nullable private KeyCrypter keyCrypter;
+    private int lookaheadSize = -1;
+
+    /** Creates a keychain group with no basic chain, and a single randomly initialized HD chain. */
+    public KeyChainGroup() {
+        this(null, new ArrayList<DeterministicKeyChain>(1), null);
+    }
+
+    /** Creates a keychain group with no basic chain, and an HD chain initialized from the given seed. */
+    public KeyChainGroup(DeterministicSeed seed) {
+        this(null, ImmutableList.of(new DeterministicKeyChain(seed)), null);
+    }
+
+    /**
+     * Creates a keychain group with no basic chain, and an HD chain that is watching the given watching key.
+     * This HAS to be an account key as returned by {@link DeterministicKeyChain#getWatchingKey()}.
+     */
+    public KeyChainGroup(DeterministicKey watchKey) {
+        this(null, ImmutableList.of(new DeterministicKeyChain(watchKey)), null);
+    }
+
+    // Used for deserialization.
+    private KeyChainGroup(@Nullable BasicKeyChain basicKeyChain, List<DeterministicKeyChain> chains, @Nullable KeyCrypter crypter) {
+        this.basic = basicKeyChain == null ? new BasicKeyChain() : basicKeyChain;
+        this.chains = checkNotNull(chains);
+        this.keyCrypter = crypter;
+        this.currentKeys = new EnumMap<KeyChain.KeyPurpose, DeterministicKey>(KeyChain.KeyPurpose.class);
+    }
+
+    private void createAndActivateNewHDChain() {
+        final DeterministicKeyChain chain = new DeterministicKeyChain(new SecureRandom());
+        for (ListenerRegistration<KeyChainEventListener> registration : basic.getListeners())
+            chain.addEventListener(registration.listener, registration.executor);
+        if (lookaheadSize >= 0)
+            chain.setLookaheadSize(lookaheadSize);
+        chains.add(chain);
+    }
+
+    /**
+     * Returns a key that hasn't been seen in a transaction yet, and which is suitable for displaying in a wallet
+     * user interface as "a convenient key to receive funds on" when the purpose parameter is
+     * {@link com.google.bitcoin.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS}. The returned key is stable until
+     * it's actually seen in a pending or confirmed transaction, at which point this method will start returning
+     * a different key (for each purpose independently).
+     */
+    public DeterministicKey currentKey(KeyChain.KeyPurpose purpose) {
+        final DeterministicKey current = currentKeys.get(purpose);
+        return current != null ? current  : freshKey(purpose);
+    }
+
+    /**
+     * Returns a key that has not been returned by this method before (fresh). You can think of this as being
+     * a newly created key, although the notion of "create" is not really valid for a
+     * {@link com.google.bitcoin.wallet.DeterministicKeyChain}. When the parameter is
+     * {@link com.google.bitcoin.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for being put
+     * into a receive coins wizard type UI. You should use this when the user is definitely going to hand this key out
+     * to someone who wishes to send money.
+     */
+    public DeterministicKey freshKey(KeyChain.KeyPurpose purpose) {
+        DeterministicKeyChain chain = getActiveKeyChain();
+        DeterministicKey key = chain.getKey(purpose);   // Always returns the next key along the key chain.
+        currentKeys.put(purpose, key);
+        return key;
+    }
+
+    /** Returns the key chain that's used for generation of fresh/current keys. This is always the newest HD chain. */
+    public DeterministicKeyChain getActiveKeyChain() {
+        if (chains.isEmpty())
+            createAndActivateNewHDChain();
+        return chains.get(chains.size() - 1);
+    }
+
+    /**
+     * Sets the lookahead buffer size for ALL deterministic key chains, see
+     * {@link com.google.bitcoin.wallet.DeterministicKeyChain#setLookaheadSize(int)}
+     * for more information.
+     */
+    public void setLookaheadSize(int lookaheadSize) {
+        this.lookaheadSize = lookaheadSize;
+        for (DeterministicKeyChain chain : chains) {
+            chain.setLookaheadSize(lookaheadSize);
+        }
+    }
+
+    /**
+     * Gets the current lookahead size being used for ALL deterministic key chains. See
+     * {@link com.google.bitcoin.wallet.DeterministicKeyChain#setLookaheadSize(int)}
+     * for more information.
+     */
+    public int getLookaheadSize() {
+        return lookaheadSize;
+    }
+
+    /** Imports the given keys into the basic chain, creating it if necessary. */
+    public int importKeys(List<ECKey> keys) {
+        return basic.importKeys(keys);
+    }
+
+    /** Imports the given keys into the basic chain, creating it if necessary. */
+    public int importKeys(ECKey... keys) {
+        return importKeys(ImmutableList.copyOf(keys));
+    }
+
+    public boolean checkPassword(CharSequence password) {
+        checkState(keyCrypter != null, "Not encrypted");
+        return checkAESKey(keyCrypter.deriveKey(password));
+    }
+
+    public boolean checkAESKey(KeyParameter aesKey) {
+        checkState(keyCrypter != null, "Not encrypted");
+        if (basic.numKeys() > 0)
+            return basic.checkAESKey(aesKey) && getActiveKeyChain().checkAESKey(aesKey);
+        return getActiveKeyChain().checkAESKey(aesKey);
+    }
+
+    /** Imports the given unencrypted keys into the basic chain, encrypting them along the way with the given key. */
+    public int importKeysAndEncrypt(final List<ECKey> keys, KeyParameter aesKey) {
+        // TODO: Firstly check if the aes key can decrypt any of the existing keys successfully.
+        checkState(keyCrypter != null, "Not encrypted");
+        LinkedList<ECKey> encryptedKeys = Lists.newLinkedList();
+        for (ECKey key : keys) {
+            if (key.isEncrypted())
+                throw new IllegalArgumentException("Cannot provide already encrypted keys");
+            encryptedKeys.add(key.encrypt(keyCrypter, aesKey));
+        }
+        return importKeys(encryptedKeys);
+    }
+
+    @Nullable
+    public ECKey findKeyFromPubHash(byte[] pubkeyHash) {
+        ECKey result;
+        if ((result = basic.findKeyFromPubHash(pubkeyHash)) != null)
+            return result;
+        for (DeterministicKeyChain chain : chains) {
+            if ((result = chain.findKeyFromPubHash(pubkeyHash)) != null)
+                return result;
+        }
+        return null;
+    }
+
+    public boolean hasKey(ECKey key) {
+        if (basic.hasKey(key))
+            return true;
+        for (DeterministicKeyChain chain : chains)
+            if (chain.hasKey(key))
+                return true;
+        return false;
+    }
+
+    @Nullable
+    public ECKey findKeyFromPubKey(byte[] pubkey) {
+        ECKey result;
+        if ((result = basic.findKeyFromPubKey(pubkey)) != null)
+            return result;
+        for (DeterministicKeyChain chain : chains) {
+            if ((result = chain.findKeyFromPubKey(pubkey)) != null)
+                return result;
+        }
+        return null;
+    }
+
+    /** Returns the number of keys managed by this group, including the lookahead buffers. */
+    public int numKeys() {
+        int result = basic.numKeys();
+        for (DeterministicKeyChain chain : chains)
+            result += chain.numKeys();
+        return result;
+    }
+
+    /**
+     * Removes a key that was imported into the basic key chain. You cannot remove deterministic keys.
+     * @throws java.lang.IllegalArgumentException if the key is deterministic.
+     */
+    public boolean removeImportedKey(ECKey key) {
+        checkNotNull(key);
+        checkArgument(!(key instanceof DeterministicKey));
+        return basic.removeKey(key);
+    }
+
+    /**
+     * Encrypt the keys in the group using the KeyCrypter and the AES key. A good default KeyCrypter to use is
+     * {@link com.google.bitcoin.crypto.KeyCrypterScrypt}.
+     *
+     * @throws com.google.bitcoin.crypto.KeyCrypterException Thrown if the wallet encryption fails for some reason, leaving the group unchanged.
+     */
+    public void encrypt(KeyCrypter keyCrypter, KeyParameter aesKey) {
+        checkNotNull(keyCrypter);
+        checkNotNull(aesKey);
+        // This code must be exception safe.
+        BasicKeyChain newBasic = basic.toEncrypted(keyCrypter, aesKey);
+        List<DeterministicKeyChain> newChains = new ArrayList<DeterministicKeyChain>(chains.size());
+        // If the user is trying to encrypt us before ever asking for a key, we might not have lazy created an HD chain
+        // yet. So do it now.
+        if (chains.isEmpty())
+            createAndActivateNewHDChain();
+        for (DeterministicKeyChain chain : chains)
+            newChains.add(chain.toEncrypted(keyCrypter, aesKey));
+
+        this.keyCrypter = keyCrypter;
+        basic = newBasic;
+        chains.clear();
+        chains.addAll(newChains);
+    }
+
+    /**
+     * Decrypt the keys in the group using the previously given key crypter and the AES key. A good default
+     * KeyCrypter to use is {@link com.google.bitcoin.crypto.KeyCrypterScrypt}.
+     *
+     * @throws com.google.bitcoin.crypto.KeyCrypterException Thrown if the wallet decryption fails for some reason, leaving the group unchanged.
+     */
+    public void decrypt(KeyParameter aesKey) {
+        // This code must be exception safe.
+        checkNotNull(aesKey);
+        BasicKeyChain newBasic = basic.toDecrypted(aesKey);
+        List<DeterministicKeyChain> newChains = new ArrayList<DeterministicKeyChain>(chains.size());
+        for (DeterministicKeyChain chain : chains)
+            newChains.add(chain.toDecrypted(aesKey));
+
+        this.keyCrypter = null;
+        basic = newBasic;
+        chains.clear();
+        chains.addAll(newChains);
+    }
+
+    /** Returns true if the group is encrypted. */
+    public boolean isEncrypted() {
+        return keyCrypter != null;
+    }
+
+    /** Returns the key crypter or null if the group is not encrypted. */
+    @Nullable public KeyCrypter getKeyCrypter() { return keyCrypter; }
+
+    /**
+     * Returns a list of the non-deterministic keys that have been imported into the wallet, or the empty list if none.
+     */
+    public List<ECKey> getImportedKeys() {
+        return basic.getKeys();
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public long getEarliestKeyCreationTime() {
+        long time = basic.getEarliestKeyCreationTime();   // Long.MAX_VALUE if empty.
+        for (DeterministicKeyChain chain : chains)
+            time = Math.min(time, chain.getEarliestKeyCreationTime());
+        return time;
+    }
+
+    /** {@inheritDoc} */
+    public int getBloomFilterElementCount() {
+        int result = basic.numBloomFilterEntries();
+        for (DeterministicKeyChain chain : chains)
+            result += chain.numBloomFilterEntries();
+        return result;
+    }
+
+    /** {@inheritDoc} */
+    public BloomFilter getBloomFilter(int size, double falsePositiveRate, long nTweak) {
+        BloomFilter filter = new BloomFilter(size, falsePositiveRate, nTweak);
+        if (basic.numKeys() > 0)
+            filter.merge(basic.getFilter(size, falsePositiveRate, nTweak));
+        for (DeterministicKeyChain chain : chains)
+            filter.merge(chain.getFilter(size, falsePositiveRate, nTweak));
+        return filter;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public boolean isRequiringUpdateAllBloomFilter() {
+        throw new UnsupportedOperationException();   // Unused.
+    }
+
+    /** Adds a listener for events that are run when keys are added, on the user thread. */
+    public void addEventListener(KeyChainEventListener listener) {
+        addEventListener(listener, Threading.USER_THREAD);
+    }
+
+    /** Adds a listener for events that are run when keys are added, on the given executor. */
+    public void addEventListener(KeyChainEventListener listener, Executor executor) {
+        checkNotNull(listener);
+        checkNotNull(executor);
+        basic.addEventListener(listener, executor);
+        for (DeterministicKeyChain chain : chains)
+            chain.addEventListener(listener, executor);
+    }
+
+    /** Removes a listener for events that are run when keys are added. */
+    public boolean removeEventListener(KeyChainEventListener listener) {
+        checkNotNull(listener);
+        for (DeterministicKeyChain chain : chains)
+            chain.removeEventListener(listener);
+        return basic.removeEventListener(listener);
+    }
+
+    /** Returns a list of key protobufs obtained by merging the chains. */
+    public List<Protos.Key> serializeToProtobuf() {
+        List<Protos.Key> result;
+        if (basic != null)
+            result = basic.serializeToProtobuf();
+        else
+            result = Lists.newArrayList();
+        for (DeterministicKeyChain chain : chains) {
+            List<Protos.Key> protos = chain.serializeToProtobuf();
+            result.addAll(protos);
+        }
+        return result;
+    }
+
+    public static KeyChainGroup fromProtobufUnencrypted(List<Protos.Key> keys) throws UnreadableWalletException {
+        BasicKeyChain basicKeyChain = BasicKeyChain.fromProtobufUnencrypted(keys);
+        List<DeterministicKeyChain> chains = DeterministicKeyChain.fromProtobuf(keys, null);
+        if (chains.isEmpty()) {
+            // TODO: Old bag-of-keys style wallet only! Auto-upgrade time!
+        }
+        return new KeyChainGroup(basicKeyChain, chains, null);
+    }
+
+    public static KeyChainGroup fromProtobufEncrypted(List<Protos.Key> keys, KeyCrypter crypter) throws UnreadableWalletException {
+        checkNotNull(crypter);
+        BasicKeyChain basicKeyChain = BasicKeyChain.fromProtobufEncrypted(keys, crypter);
+        List<DeterministicKeyChain> chains = DeterministicKeyChain.fromProtobuf(keys, crypter);
+        if (chains.isEmpty()) {
+            // TODO: Old bag-of-keys style wallet only! Auto-upgrade time!
+        }
+        return new KeyChainGroup(basicKeyChain, chains, crypter);
+    }
+
+    public String toString(@Nullable NetworkParameters params, boolean includePrivateKeys) {
+        final StringBuilder builder = new StringBuilder();
+        if (basic != null) {
+            for (ECKey key : basic.getKeys())
+                formatKeyWithAddress(params, includePrivateKeys, key, builder);
+        }
+        for (DeterministicKeyChain chain : chains) {
+            DeterministicSeed seed = chain.getSeed();
+            if (seed != null) {
+                if (seed.isEncrypted()) {
+                    builder.append(String.format("Seed is encrypted%n"));
+                } else if (includePrivateKeys) {
+                    final List<String> words = seed.toMnemonicCode();
+                    builder.append(
+                            String.format("Seed as words: %s%nSeed as hex:   %s%n", Joiner.on(' ').join(words),
+                                    seed.toHexString())
+                    );
+                }
+                builder.append(String.format("Seed birthday: %d  [%s]%n", seed.getCreationTimeSeconds(), new Date(seed.getCreationTimeSeconds() * 1000)));
+            }
+            final DeterministicKey watchingKey = chain.getWatchingKey();
+            // Don't show if it's been imported from a watching wallet already, because it'd result in a weird/
+            // unintuitive result where the watching key in a watching wallet is not the one it was created with
+            // due to the parent fingerprint being missing/not stored. In future we could store the parent fingerprint
+            // optionally as well to fix this, but it seems unimportant for now.
+            if (watchingKey.getParent() != null) {
+                builder.append(String.format("Key to watch:  %s%n%n", watchingKey.serializePubB58()));
+            }
+            for (ECKey key : chain.getKeys())
+                formatKeyWithAddress(params, includePrivateKeys, key, builder);
+        }
+        return builder.toString();
+    }
+
+    private void formatKeyWithAddress(@Nullable NetworkParameters params, boolean includePrivateKeys,
+                                      ECKey key, StringBuilder builder) {
+        if (params != null) {
+            final Address address = key.toAddress(params);
+            builder.append("  addr:");
+            builder.append(address.toString());
+        }
+        builder.append("  hash160:");
+        builder.append(Utils.bytesToHexString(key.getPubKeyHash()));
+        builder.append(" ");
+        builder.append(includePrivateKeys ? key.toStringWithPrivate() : key.toString());
+        builder.append("\n");
+    }
+}
diff --git a/core/src/main/java/org/bitcoinj/wallet/Protos.java b/core/src/main/java/org/bitcoinj/wallet/Protos.java
index d39728d..bb5121d 100644
--- a/core/src/main/java/org/bitcoinj/wallet/Protos.java
+++ b/core/src/main/java/org/bitcoinj/wallet/Protos.java
@@ -1,5 +1,5 @@
 // Generated by the protocol buffer compiler.  DO NOT EDIT!
-// source: bitcoin.proto
+// source: wallet.proto
 
 package org.bitcoinj.wallet;
 
@@ -593,7 +593,7 @@ public final class Protos {
     // @@protoc_insertion_point(class_scope:wallet.PeerAddress)
   }
 
-  public interface EncryptedPrivateKeyOrBuilder
+  public interface EncryptedDataOrBuilder
       extends com.google.protobuf.MessageOrBuilder {
 
     // required bytes initialisation_vector = 1;
@@ -633,29 +633,24 @@ public final class Protos {
     com.google.protobuf.ByteString getEncryptedPrivateKey();
   }
   /**
-   * Protobuf type {@code wallet.EncryptedPrivateKey}
-   *
-   * <pre>
-   **
-   * The data to store a private key encrypted with Scrypt and AES
-   * </pre>
+   * Protobuf type {@code wallet.EncryptedData}
    */
-  public static final class EncryptedPrivateKey extends
+  public static final class EncryptedData extends
       com.google.protobuf.GeneratedMessage
-      implements EncryptedPrivateKeyOrBuilder {
-    // Use EncryptedPrivateKey.newBuilder() to construct.
-    private EncryptedPrivateKey(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
+      implements EncryptedDataOrBuilder {
+    // Use EncryptedData.newBuilder() to construct.
+    private EncryptedData(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
       super(builder);
       this.unknownFields = builder.getUnknownFields();
     }
-    private EncryptedPrivateKey(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }
+    private EncryptedData(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }
 
-    private static final EncryptedPrivateKey defaultInstance;
-    public static EncryptedPrivateKey getDefaultInstance() {
+    private static final EncryptedData defaultInstance;
+    public static EncryptedData getDefaultInstance() {
       return defaultInstance;
     }
 
-    public EncryptedPrivateKey getDefaultInstanceForType() {
+    public EncryptedData getDefaultInstanceForType() {
       return defaultInstance;
     }
 
@@ -665,7 +660,7 @@ public final class Protos {
         getUnknownFields() {
       return this.unknownFields;
     }
-    private EncryptedPrivateKey(
+    private EncryptedData(
         com.google.protobuf.CodedInputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws com.google.protobuf.InvalidProtocolBufferException {
@@ -712,28 +707,28 @@ public final class Protos {
     }
     public static final com.google.protobuf.Descriptors.Descriptor
         getDescriptor() {
-      return org.bitcoinj.wallet.Protos.internal_static_wallet_EncryptedPrivateKey_descriptor;
+      return org.bitcoinj.wallet.Protos.internal_static_wallet_EncryptedData_descriptor;
     }
 
     protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
         internalGetFieldAccessorTable() {
-      return org.bitcoinj.wallet.Protos.internal_static_wallet_EncryptedPrivateKey_fieldAccessorTable
+      return org.bitcoinj.wallet.Protos.internal_static_wallet_EncryptedData_fieldAccessorTable
           .ensureFieldAccessorsInitialized(
-              org.bitcoinj.wallet.Protos.EncryptedPrivateKey.class, org.bitcoinj.wallet.Protos.EncryptedPrivateKey.Builder.class);
+              org.bitcoinj.wallet.Protos.EncryptedData.class, org.bitcoinj.wallet.Protos.EncryptedData.Builder.class);
     }
 
-    public static com.google.protobuf.Parser<EncryptedPrivateKey> PARSER =
-        new com.google.protobuf.AbstractParser<EncryptedPrivateKey>() {
-      public EncryptedPrivateKey parsePartialFrom(
+    public static com.google.protobuf.Parser<EncryptedData> PARSER =
+        new com.google.protobuf.AbstractParser<EncryptedData>() {
+      public EncryptedData parsePartialFrom(
           com.google.protobuf.CodedInputStream input,
           com.google.protobuf.ExtensionRegistryLite extensionRegistry)
           throws com.google.protobuf.InvalidProtocolBufferException {
-        return new EncryptedPrivateKey(input, extensionRegistry);
+        return new EncryptedData(input, extensionRegistry);
       }
     };
 
     @java.lang.Override
-    public com.google.protobuf.Parser<EncryptedPrivateKey> getParserForType() {
+    public com.google.protobuf.Parser<EncryptedData> getParserForType() {
       return PARSER;
     }
 
@@ -845,53 +840,53 @@ public final class Protos {
       return super.writeReplace();
     }
 
-    public static org.bitcoinj.wallet.Protos.EncryptedPrivateKey parseFrom(
+    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(
         com.google.protobuf.ByteString data)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data);
     }
-    public static org.bitcoinj.wallet.Protos.EncryptedPrivateKey parseFrom(
+    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(
         com.google.protobuf.ByteString data,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data, extensionRegistry);
     }
-    public static org.bitcoinj.wallet.Protos.EncryptedPrivateKey parseFrom(byte[] data)
+    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(byte[] data)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data);
     }
-    public static org.bitcoinj.wallet.Protos.EncryptedPrivateKey parseFrom(
+    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(
         byte[] data,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws com.google.protobuf.InvalidProtocolBufferException {
       return PARSER.parseFrom(data, extensionRegistry);
     }
-    public static org.bitcoinj.wallet.Protos.EncryptedPrivateKey parseFrom(java.io.InputStream input)
+    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(java.io.InputStream input)
         throws java.io.IOException {
       return PARSER.parseFrom(input);
     }
-    public static org.bitcoinj.wallet.Protos.EncryptedPrivateKey parseFrom(
+    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(
         java.io.InputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws java.io.IOException {
       return PARSER.parseFrom(input, extensionRegistry);
     }
-    public static org.bitcoinj.wallet.Protos.EncryptedPrivateKey parseDelimitedFrom(java.io.InputStream input)
+    public static org.bitcoinj.wallet.Protos.EncryptedData parseDelimitedFrom(java.io.InputStream input)
         throws java.io.IOException {
       return PARSER.parseDelimitedFrom(input);
     }
-    public static org.bitcoinj.wallet.Protos.EncryptedPrivateKey parseDelimitedFrom(
+    public static org.bitcoinj.wallet.Protos.EncryptedData parseDelimitedFrom(
         java.io.InputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws java.io.IOException {
       return PARSER.parseDelimitedFrom(input, extensionRegistry);
     }
-    public static org.bitcoinj.wallet.Protos.EncryptedPrivateKey parseFrom(
+    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(
         com.google.protobuf.CodedInputStream input)
         throws java.io.IOException {
       return PARSER.parseFrom(input);
     }
-    public static org.bitcoinj.wallet.Protos.EncryptedPrivateKey parseFrom(
+    public static org.bitcoinj.wallet.Protos.EncryptedData parseFrom(
         com.google.protobuf.CodedInputStream input,
         com.google.protobuf.ExtensionRegistryLite extensionRegistry)
         throws java.io.IOException {
@@ -900,7 +895,7 @@ public final class Protos {
 
     public static Builder newBuilder() { return Builder.create(); }
     public Builder newBuilderForType() { return newBuilder(); }
-    public static Builder newBuilder(org.bitcoinj.wallet.Protos.EncryptedPrivateKey prototype) {
+    public static Builder newBuilder(org.bitcoinj.wallet.Protos.EncryptedData prototype) {
       return newBuilder().mergeFrom(prototype);
     }
     public Builder toBuilder() { return newBuilder(this); }
@@ -912,29 +907,24 @@ public final class Protos {
       return builder;
     }
     /**
-     * Protobuf type {@code wallet.EncryptedPrivateKey}
-     *
-     * <pre>
-     **
-     * The data to store a private key encrypted with Scrypt and AES
-     * </pre>
+     * Protobuf type {@code wallet.EncryptedData}
      */
     public static final class Builder extends
         com.google.protobuf.GeneratedMessage.Builder<Builder>
-       implements org.bitcoinj.wallet.Protos.EncryptedPrivateKeyOrBuilder {
+       implements org.bitcoinj.wallet.Protos.EncryptedDataOrBuilder {
       public static final com.google.protobuf.Descriptors.Descriptor
           getDescriptor() {
-        return org.bitcoinj.wallet.Protos.internal_static_wallet_EncryptedPrivateKey_descriptor;
+        return org.bitcoinj.wallet.Protos.internal_static_wallet_EncryptedData_descriptor;
       }
 
       protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
           internalGetFieldAccessorTable() {
-        return org.bitcoinj.wallet.Protos.internal_static_wallet_EncryptedPrivateKey_fieldAccessorTable
+        return org.bitcoinj.wallet.Protos.internal_static_wallet_EncryptedData_fieldAccessorTable
             .ensureFieldAccessorsInitialized(
-                org.bitcoinj.wallet.Protos.EncryptedPrivateKey.class, org.bitcoinj.wallet.Protos.EncryptedPrivateKey.Builder.class);
+                org.bitcoinj.wallet.Protos.EncryptedData.class, org.bitcoinj.wallet.Protos.EncryptedData.Builder.class);
       }
 
-      // Construct using org.bitcoinj.wallet.Protos.EncryptedPrivateKey.newBuilder()
+      // Construct using org.bitcoinj.wallet.Protos.EncryptedData.newBuilder()
       private Builder() {
         maybeForceBuilderInitialization();
       }
@@ -967,23 +957,23 @@ public final class Protos {
 
       public com.google.protobuf.Descriptors.Descriptor
           getDescriptorForType() {
-        return org.bitcoinj.wallet.Protos.internal_static_wallet_EncryptedPrivateKey_descriptor;
+        return org.bitcoinj.wallet.Protos.internal_static_wallet_EncryptedData_descriptor;
       }
 
-      public org.bitcoinj.wallet.Protos.EncryptedPrivateKey getDefaultInstanceForType() {
-        return org.bitcoinj.wallet.Protos.EncryptedPrivateKey.getDefaultInstance();
+      public org.bitcoinj.wallet.Protos.EncryptedData getDefaultInstanceForType() {
+        return org.bitcoinj.wallet.Protos.EncryptedData.getDefaultInstance();
       }
 
-      public org.bitcoinj.wallet.Protos.EncryptedPrivateKey build() {
-        org.bitcoinj.wallet.Protos.EncryptedPrivateKey result = buildPartial();
+      public org.bitcoinj.wallet.Protos.EncryptedData build() {
+        org.bitcoinj.wallet.Protos.EncryptedData result = buildPartial();
         if (!result.isInitialized()) {
           throw newUninitializedMessageException(result);
         }
         return result;
       }
 
-      public org.bitcoinj.wallet.Protos.EncryptedPrivateKey buildPartial() {
-        org.bitcoinj.wallet.Protos.EncryptedPrivateKey result = new org.bitcoinj.wallet.Protos.EncryptedPrivateKey(this);
+      public org.bitcoinj.wallet.Protos.EncryptedData buildPartial() {
+        org.bitcoinj.wallet.Protos.EncryptedData result = new org.bitcoinj.wallet.Protos.EncryptedData(this);
         int from_bitField0_ = bitField0_;
         int to_bitField0_ = 0;
         if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
@@ -1000,16 +990,16 @@ public final class Protos {
       }
 
       public Builder mergeFrom(com.google.protobuf.Message other) {
-        if (other instanceof org.bitcoinj.wallet.Protos.EncryptedPrivateKey) {
-          return mergeFrom((org.bitcoinj.wallet.Protos.EncryptedPrivateKey)other);
+        if (other instanceof org.bitcoinj.wallet.Protos.EncryptedData) {
+          return mergeFrom((org.bitcoinj.wallet.Protos.EncryptedData)other);
         } else {
           super.mergeFrom(other);
           return this;
         }
       }
 
-      public Builder mergeFrom(org.bitcoinj.wallet.Protos.EncryptedPrivateKey other) {
-        if (other == org.bitcoinj.wallet.Protos.EncryptedPrivateKey.getDefaultInstance()) return this;
+      public Builder mergeFrom(org.bitcoinj.wallet.Protos.EncryptedData other) {
+        if (other == org.bitcoinj.wallet.Protos.EncryptedData.getDefaultInstance()) return this;
         if (other.hasInitialisationVector()) {
           setInitialisationVector(other.getInitialisationVector());
         }
@@ -1036,11 +1026,11 @@ public final class Protos {
           com.google.protobuf.CodedInputStream input,
           com.google.protobuf.ExtensionRegistryLite extensionRegistry)
           throws java.io.IOException {
-        org.bitcoinj.wallet.Protos.EncryptedPrivateKey parsedMessage = null;
+        org.bitcoinj.wallet.Protos.EncryptedData parsedMessage = null;
         try {
           parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
         } catch (com.google.protobuf.InvalidProtocolBufferException e) {
-          parsedMessage = (org.bitcoinj.wallet.Protos.EncryptedPrivateKey) e.getUnfinishedMessage();
+          parsedMessage = (org.bitcoinj.wallet.Protos.EncryptedData) e.getUnfinishedMessage();
           throw e;
         } finally {
           if (parsedMessage != null) {
@@ -1049,121 +1039,1034 @@ public final class Protos {
         }
         return this;
       }
-      private int bitField0_;
-
-      // required bytes initialisation_vector = 1;
-      private com.google.protobuf.ByteString initialisationVector_ = com.google.protobuf.ByteString.EMPTY;
+      private int bitField0_;
+
+      // required bytes initialisation_vector = 1;
+      private com.google.protobuf.ByteString initialisationVector_ = com.google.protobuf.ByteString.EMPTY;
+      /**
+       * <code>required bytes initialisation_vector = 1;</code>
+       *
+       * <pre>
+       * The initialisation vector for the AES encryption (16 bytes)
+       * </pre>
+       */
+      public boolean hasInitialisationVector() {
+        return ((bitField0_ & 0x00000001) == 0x00000001);
+      }
+      /**
+       * <code>required bytes initialisation_vector = 1;</code>
+       *
+       * <pre>
+       * The initialisation vector for the AES encryption (16 bytes)
+       * </pre>
+       */
+      public com.google.protobuf.ByteString getInitialisationVector() {
+        return initialisationVector_;
+      }
+      /**
+       * <code>required bytes initialisation_vector = 1;</code>
+       *
+       * <pre>
+       * The initialisation vector for the AES encryption (16 bytes)
+       * </pre>
+       */
+      public Builder setInitialisationVector(com.google.protobuf.ByteString value) {
+        if (value == null) {
+    throw new NullPointerException();
+  }
+  bitField0_ |= 0x00000001;
+        initialisationVector_ = value;
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>required bytes initialisation_vector = 1;</code>
+       *
+       * <pre>
+       * The initialisation vector for the AES encryption (16 bytes)
+       * </pre>
+       */
+      public Builder clearInitialisationVector() {
+        bitField0_ = (bitField0_ & ~0x00000001);
+        initialisationVector_ = getDefaultInstance().getInitialisationVector();
+        onChanged();
+        return this;
+      }
+
+      // required bytes encrypted_private_key = 2;
+      private com.google.protobuf.ByteString encryptedPrivateKey_ = com.google.protobuf.ByteString.EMPTY;
+      /**
+       * <code>required bytes encrypted_private_key = 2;</code>
+       *
+       * <pre>
+       * The encrypted private key
+       * </pre>
+       */
+      public boolean hasEncryptedPrivateKey() {
+        return ((bitField0_ & 0x00000002) == 0x00000002);
+      }
+      /**
+       * <code>required bytes encrypted_private_key = 2;</code>
+       *
+       * <pre>
+       * The encrypted private key
+       * </pre>
+       */
+      public com.google.protobuf.ByteString getEncryptedPrivateKey() {
+        return encryptedPrivateKey_;
+      }
+      /**
+       * <code>required bytes encrypted_private_key = 2;</code>
+       *
+       * <pre>
+       * The encrypted private key
+       * </pre>
+       */
+      public Builder setEncryptedPrivateKey(com.google.protobuf.ByteString value) {
+        if (value == null) {
+    throw new NullPointerException();
+  }
+  bitField0_ |= 0x00000002;
+        encryptedPrivateKey_ = value;
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>required bytes encrypted_private_key = 2;</code>
+       *
+       * <pre>
+       * The encrypted private key
+       * </pre>
+       */
+      public Builder clearEncryptedPrivateKey() {
+        bitField0_ = (bitField0_ & ~0x00000002);
+        encryptedPrivateKey_ = getDefaultInstance().getEncryptedPrivateKey();
+        onChanged();
+        return this;
+      }
+
+      // @@protoc_insertion_point(builder_scope:wallet.EncryptedData)
+    }
+
+    static {
+      defaultInstance = new EncryptedData(true);
+      defaultInstance.initFields();
+    }
+
+    // @@protoc_insertion_point(class_scope:wallet.EncryptedData)
+  }
+
+  public interface DeterministicKeyOrBuilder
+      extends com.google.protobuf.MessageOrBuilder {
+
+    // required bytes chain_code = 1;
+    /**
+     * <code>required bytes chain_code = 1;</code>
+     *
+     * <pre>
+     * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
+     * should just treat it as a regular ORIGINAL type key.
+     * </pre>
+     */
+    boolean hasChainCode();
+    /**
+     * <code>required bytes chain_code = 1;</code>
+     *
+     * <pre>
+     * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
+     * should just treat it as a regular ORIGINAL type key.
+     * </pre>
+     */
+    com.google.protobuf.ByteString getChainCode();
+
+    // repeated uint32 path = 2;
+    /**
+     * <code>repeated uint32 path = 2;</code>
+     *
+     * <pre>
+     * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
+     * and high bit unset for public derivation.
+     * </pre>
+     */
+    java.util.List<java.lang.Integer> getPathList();
+    /**
+     * <code>repeated uint32 path = 2;</code>
+     *
+     * <pre>
+     * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
+     * and high bit unset for public derivation.
+     * </pre>
+     */
+    int getPathCount();
+    /**
+     * <code>repeated uint32 path = 2;</code>
+     *
+     * <pre>
+     * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
+     * and high bit unset for public derivation.
+     * </pre>
+     */
+    int getPath(int index);
+
+    // optional uint32 issued_subkeys = 3;
+    /**
+     * <code>optional uint32 issued_subkeys = 3;</code>
+     *
+     * <pre>
+     * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
+     * For the parents of keys being handed out, this is always less than the true number of children: the difference is
+     * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
+     * this wallet - for instance when restoring from backup or if the seed was shared between devices.
+     *
+     * If this field is missing it means we're not issuing subkeys of this key to users.
+     * </pre>
+     */
+    boolean hasIssuedSubkeys();
+    /**
+     * <code>optional uint32 issued_subkeys = 3;</code>
+     *
+     * <pre>
+     * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
+     * For the parents of keys being handed out, this is always less than the true number of children: the difference is
+     * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
+     * this wallet - for instance when restoring from backup or if the seed was shared between devices.
+     *
+     * If this field is missing it means we're not issuing subkeys of this key to users.
+     * </pre>
+     */
+    int getIssuedSubkeys();
+
+    // optional uint32 lookahead_size = 4;
+    /**
+     * <code>optional uint32 lookahead_size = 4;</code>
+     */
+    boolean hasLookaheadSize();
+    /**
+     * <code>optional uint32 lookahead_size = 4;</code>
+     */
+    int getLookaheadSize();
+  }
+  /**
+   * Protobuf type {@code wallet.DeterministicKey}
+   *
+   * <pre>
+   **
+   * Data attached to a Key message that defines the data needed by the BIP32 deterministic key hierarchy algorithm.
+   * </pre>
+   */
+  public static final class DeterministicKey extends
+      com.google.protobuf.GeneratedMessage
+      implements DeterministicKeyOrBuilder {
+    // Use DeterministicKey.newBuilder() to construct.
+    private DeterministicKey(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
+      super(builder);
+      this.unknownFields = builder.getUnknownFields();
+    }
+    private DeterministicKey(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }
+
+    private static final DeterministicKey defaultInstance;
+    public static DeterministicKey getDefaultInstance() {
+      return defaultInstance;
+    }
+
+    public DeterministicKey getDefaultInstanceForType() {
+      return defaultInstance;
+    }
+
+    private final com.google.protobuf.UnknownFieldSet unknownFields;
+    @java.lang.Override
+    public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+      return this.unknownFields;
+    }
+    private DeterministicKey(
+        com.google.protobuf.CodedInputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      initFields();
+      int mutable_bitField0_ = 0;
+      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
+          com.google.protobuf.UnknownFieldSet.newBuilder();
+      try {
+        boolean done = false;
+        while (!done) {
+          int tag = input.readTag();
+          switch (tag) {
+            case 0:
+              done = true;
+              break;
+            default: {
+              if (!parseUnknownField(input, unknownFields,
+                                     extensionRegistry, tag)) {
+                done = true;
+              }
+              break;
+            }
+            case 10: {
+              bitField0_ |= 0x00000001;
+              chainCode_ = input.readBytes();
+              break;
+            }
+            case 16: {
+              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
+                path_ = new java.util.ArrayList<java.lang.Integer>();
+                mutable_bitField0_ |= 0x00000002;
+              }
+              path_.add(input.readUInt32());
+              break;
+            }
+            case 18: {
+              int length = input.readRawVarint32();
+              int limit = input.pushLimit(length);
+              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002) && input.getBytesUntilLimit() > 0) {
+                path_ = new java.util.ArrayList<java.lang.Integer>();
+                mutable_bitField0_ |= 0x00000002;
+              }
+              while (input.getBytesUntilLimit() > 0) {
+                path_.add(input.readUInt32());
+              }
+              input.popLimit(limit);
+              break;
+            }
+            case 24: {
+              bitField0_ |= 0x00000002;
+              issuedSubkeys_ = input.readUInt32();
+              break;
+            }
+            case 32: {
+              bitField0_ |= 0x00000004;
+              lookaheadSize_ = input.readUInt32();
+              break;
+            }
+          }
+        }
+      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+        throw e.setUnfinishedMessage(this);
+      } catch (java.io.IOException e) {
+        throw new com.google.protobuf.InvalidProtocolBufferException(
+            e.getMessage()).setUnfinishedMessage(this);
+      } finally {
+        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
+          path_ = java.util.Collections.unmodifiableList(path_);
+        }
+        this.unknownFields = unknownFields.build();
+        makeExtensionsImmutable();
+      }
+    }
+    public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+      return org.bitcoinj.wallet.Protos.internal_static_wallet_DeterministicKey_descriptor;
+    }
+
+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+      return org.bitcoinj.wallet.Protos.internal_static_wallet_DeterministicKey_fieldAccessorTable
+          .ensureFieldAccessorsInitialized(
+              org.bitcoinj.wallet.Protos.DeterministicKey.class, org.bitcoinj.wallet.Protos.DeterministicKey.Builder.class);
+    }
+
+    public static com.google.protobuf.Parser<DeterministicKey> PARSER =
+        new com.google.protobuf.AbstractParser<DeterministicKey>() {
+      public DeterministicKey parsePartialFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return new DeterministicKey(input, extensionRegistry);
+      }
+    };
+
+    @java.lang.Override
+    public com.google.protobuf.Parser<DeterministicKey> getParserForType() {
+      return PARSER;
+    }
+
+    private int bitField0_;
+    // required bytes chain_code = 1;
+    public static final int CHAIN_CODE_FIELD_NUMBER = 1;
+    private com.google.protobuf.ByteString chainCode_;
+    /**
+     * <code>required bytes chain_code = 1;</code>
+     *
+     * <pre>
+     * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
+     * should just treat it as a regular ORIGINAL type key.
+     * </pre>
+     */
+    public boolean hasChainCode() {
+      return ((bitField0_ & 0x00000001) == 0x00000001);
+    }
+    /**
+     * <code>required bytes chain_code = 1;</code>
+     *
+     * <pre>
+     * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
+     * should just treat it as a regular ORIGINAL type key.
+     * </pre>
+     */
+    public com.google.protobuf.ByteString getChainCode() {
+      return chainCode_;
+    }
+
+    // repeated uint32 path = 2;
+    public static final int PATH_FIELD_NUMBER = 2;
+    private java.util.List<java.lang.Integer> path_;
+    /**
+     * <code>repeated uint32 path = 2;</code>
+     *
+     * <pre>
+     * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
+     * and high bit unset for public derivation.
+     * </pre>
+     */
+    public java.util.List<java.lang.Integer>
+        getPathList() {
+      return path_;
+    }
+    /**
+     * <code>repeated uint32 path = 2;</code>
+     *
+     * <pre>
+     * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
+     * and high bit unset for public derivation.
+     * </pre>
+     */
+    public int getPathCount() {
+      return path_.size();
+    }
+    /**
+     * <code>repeated uint32 path = 2;</code>
+     *
+     * <pre>
+     * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
+     * and high bit unset for public derivation.
+     * </pre>
+     */
+    public int getPath(int index) {
+      return path_.get(index);
+    }
+
+    // optional uint32 issued_subkeys = 3;
+    public static final int ISSUED_SUBKEYS_FIELD_NUMBER = 3;
+    private int issuedSubkeys_;
+    /**
+     * <code>optional uint32 issued_subkeys = 3;</code>
+     *
+     * <pre>
+     * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
+     * For the parents of keys being handed out, this is always less than the true number of children: the difference is
+     * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
+     * this wallet - for instance when restoring from backup or if the seed was shared between devices.
+     *
+     * If this field is missing it means we're not issuing subkeys of this key to users.
+     * </pre>
+     */
+    public boolean hasIssuedSubkeys() {
+      return ((bitField0_ & 0x00000002) == 0x00000002);
+    }
+    /**
+     * <code>optional uint32 issued_subkeys = 3;</code>
+     *
+     * <pre>
+     * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
+     * For the parents of keys being handed out, this is always less than the true number of children: the difference is
+     * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
+     * this wallet - for instance when restoring from backup or if the seed was shared between devices.
+     *
+     * If this field is missing it means we're not issuing subkeys of this key to users.
+     * </pre>
+     */
+    public int getIssuedSubkeys() {
+      return issuedSubkeys_;
+    }
+
+    // optional uint32 lookahead_size = 4;
+    public static final int LOOKAHEAD_SIZE_FIELD_NUMBER = 4;
+    private int lookaheadSize_;
+    /**
+     * <code>optional uint32 lookahead_size = 4;</code>
+     */
+    public boolean hasLookaheadSize() {
+      return ((bitField0_ & 0x00000004) == 0x00000004);
+    }
+    /**
+     * <code>optional uint32 lookahead_size = 4;</code>
+     */
+    public int getLookaheadSize() {
+      return lookaheadSize_;
+    }
+
+    private void initFields() {
+      chainCode_ = com.google.protobuf.ByteString.EMPTY;
+      path_ = java.util.Collections.emptyList();
+      issuedSubkeys_ = 0;
+      lookaheadSize_ = 0;
+    }
+    private byte memoizedIsInitialized = -1;
+    public final boolean isInitialized() {
+      byte isInitialized = memoizedIsInitialized;
+      if (isInitialized != -1) return isInitialized == 1;
+
+      if (!hasChainCode()) {
+        memoizedIsInitialized = 0;
+        return false;
+      }
+      memoizedIsInitialized = 1;
+      return true;
+    }
+
+    public void writeTo(com.google.protobuf.CodedOutputStream output)
+                        throws java.io.IOException {
+      getSerializedSize();
+      if (((bitField0_ & 0x00000001) == 0x00000001)) {
+        output.writeBytes(1, chainCode_);
+      }
+      for (int i = 0; i < path_.size(); i++) {
+        output.writeUInt32(2, path_.get(i));
+      }
+      if (((bitField0_ & 0x00000002) == 0x00000002)) {
+        output.writeUInt32(3, issuedSubkeys_);
+      }
+      if (((bitField0_ & 0x00000004) == 0x00000004)) {
+        output.writeUInt32(4, lookaheadSize_);
+      }
+      getUnknownFields().writeTo(output);
+    }
+
+    private int memoizedSerializedSize = -1;
+    public int getSerializedSize() {
+      int size = memoizedSerializedSize;
+      if (size != -1) return size;
+
+      size = 0;
+      if (((bitField0_ & 0x00000001) == 0x00000001)) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeBytesSize(1, chainCode_);
+      }
+      {
+        int dataSize = 0;
+        for (int i = 0; i < path_.size(); i++) {
+          dataSize += com.google.protobuf.CodedOutputStream
+            .computeUInt32SizeNoTag(path_.get(i));
+        }
+        size += dataSize;
+        size += 1 * getPathList().size();
+      }
+      if (((bitField0_ & 0x00000002) == 0x00000002)) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeUInt32Size(3, issuedSubkeys_);
+      }
+      if (((bitField0_ & 0x00000004) == 0x00000004)) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeUInt32Size(4, lookaheadSize_);
+      }
+      size += getUnknownFields().getSerializedSize();
+      memoizedSerializedSize = size;
+      return size;
+    }
+
+    private static final long serialVersionUID = 0L;
+    @java.lang.Override
+    protected java.lang.Object writeReplace()
+        throws java.io.ObjectStreamException {
+      return super.writeReplace();
+    }
+
+    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(
+        com.google.protobuf.ByteString data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data);
+    }
+    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(
+        com.google.protobuf.ByteString data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data, extensionRegistry);
+    }
+    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(byte[] data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data);
+    }
+    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(
+        byte[] data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data, extensionRegistry);
+    }
+    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input);
+    }
+    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input, extensionRegistry);
+    }
+    public static org.bitcoinj.wallet.Protos.DeterministicKey parseDelimitedFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return PARSER.parseDelimitedFrom(input);
+    }
+    public static org.bitcoinj.wallet.Protos.DeterministicKey parseDelimitedFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseDelimitedFrom(input, extensionRegistry);
+    }
+    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(
+        com.google.protobuf.CodedInputStream input)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input);
+    }
+    public static org.bitcoinj.wallet.Protos.DeterministicKey parseFrom(
+        com.google.protobuf.CodedInputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input, extensionRegistry);
+    }
+
+    public static Builder newBuilder() { return Builder.create(); }
+    public Builder newBuilderForType() { return newBuilder(); }
+    public static Builder newBuilder(org.bitcoinj.wallet.Protos.DeterministicKey prototype) {
+      return newBuilder().mergeFrom(prototype);
+    }
+    public Builder toBuilder() { return newBuilder(this); }
+
+    @java.lang.Override
+    protected Builder newBuilderForType(
+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+      Builder builder = new Builder(parent);
+      return builder;
+    }
+    /**
+     * Protobuf type {@code wallet.DeterministicKey}
+     *
+     * <pre>
+     **
+     * Data attached to a Key message that defines the data needed by the BIP32 deterministic key hierarchy algorithm.
+     * </pre>
+     */
+    public static final class Builder extends
+        com.google.protobuf.GeneratedMessage.Builder<Builder>
+       implements org.bitcoinj.wallet.Protos.DeterministicKeyOrBuilder {
+      public static final com.google.protobuf.Descriptors.Descriptor
+          getDescriptor() {
+        return org.bitcoinj.wallet.Protos.internal_static_wallet_DeterministicKey_descriptor;
+      }
+
+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+          internalGetFieldAccessorTable() {
+        return org.bitcoinj.wallet.Protos.internal_static_wallet_DeterministicKey_fieldAccessorTable
+            .ensureFieldAccessorsInitialized(
+                org.bitcoinj.wallet.Protos.DeterministicKey.class, org.bitcoinj.wallet.Protos.DeterministicKey.Builder.class);
+      }
+
+      // Construct using org.bitcoinj.wallet.Protos.DeterministicKey.newBuilder()
+      private Builder() {
+        maybeForceBuilderInitialization();
+      }
+
+      private Builder(
+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+        super(parent);
+        maybeForceBuilderInitialization();
+      }
+      private void maybeForceBuilderInitialization() {
+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
+        }
+      }
+      private static Builder create() {
+        return new Builder();
+      }
+
+      public Builder clear() {
+        super.clear();
+        chainCode_ = com.google.protobuf.ByteString.EMPTY;
+        bitField0_ = (bitField0_ & ~0x00000001);
+        path_ = java.util.Collections.emptyList();
+        bitField0_ = (bitField0_ & ~0x00000002);
+        issuedSubkeys_ = 0;
+        bitField0_ = (bitField0_ & ~0x00000004);
+        lookaheadSize_ = 0;
+        bitField0_ = (bitField0_ & ~0x00000008);
+        return this;
+      }
+
+      public Builder clone() {
+        return create().mergeFrom(buildPartial());
+      }
+
+      public com.google.protobuf.Descriptors.Descriptor
+          getDescriptorForType() {
+        return org.bitcoinj.wallet.Protos.internal_static_wallet_DeterministicKey_descriptor;
+      }
+
+      public org.bitcoinj.wallet.Protos.DeterministicKey getDefaultInstanceForType() {
+        return org.bitcoinj.wallet.Protos.DeterministicKey.getDefaultInstance();
+      }
+
+      public org.bitcoinj.wallet.Protos.DeterministicKey build() {
+        org.bitcoinj.wallet.Protos.DeterministicKey result = buildPartial();
+        if (!result.isInitialized()) {
+          throw newUninitializedMessageException(result);
+        }
+        return result;
+      }
+
+      public org.bitcoinj.wallet.Protos.DeterministicKey buildPartial() {
+        org.bitcoinj.wallet.Protos.DeterministicKey result = new org.bitcoinj.wallet.Protos.DeterministicKey(this);
+        int from_bitField0_ = bitField0_;
+        int to_bitField0_ = 0;
+        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
+          to_bitField0_ |= 0x00000001;
+        }
+        result.chainCode_ = chainCode_;
+        if (((bitField0_ & 0x00000002) == 0x00000002)) {
+          path_ = java.util.Collections.unmodifiableList(path_);
+          bitField0_ = (bitField0_ & ~0x00000002);
+        }
+        result.path_ = path_;
+        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
+          to_bitField0_ |= 0x00000002;
+        }
+        result.issuedSubkeys_ = issuedSubkeys_;
+        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
+          to_bitField0_ |= 0x00000004;
+        }
+        result.lookaheadSize_ = lookaheadSize_;
+        result.bitField0_ = to_bitField0_;
+        onBuilt();
+        return result;
+      }
+
+      public Builder mergeFrom(com.google.protobuf.Message other) {
+        if (other instanceof org.bitcoinj.wallet.Protos.DeterministicKey) {
+          return mergeFrom((org.bitcoinj.wallet.Protos.DeterministicKey)other);
+        } else {
+          super.mergeFrom(other);
+          return this;
+        }
+      }
+
+      public Builder mergeFrom(org.bitcoinj.wallet.Protos.DeterministicKey other) {
+        if (other == org.bitcoinj.wallet.Protos.DeterministicKey.getDefaultInstance()) return this;
+        if (other.hasChainCode()) {
+          setChainCode(other.getChainCode());
+        }
+        if (!other.path_.isEmpty()) {
+          if (path_.isEmpty()) {
+            path_ = other.path_;
+            bitField0_ = (bitField0_ & ~0x00000002);
+          } else {
+            ensurePathIsMutable();
+            path_.addAll(other.path_);
+          }
+          onChanged();
+        }
+        if (other.hasIssuedSubkeys()) {
+          setIssuedSubkeys(other.getIssuedSubkeys());
+        }
+        if (other.hasLookaheadSize()) {
+          setLookaheadSize(other.getLookaheadSize());
+        }
+        this.mergeUnknownFields(other.getUnknownFields());
+        return this;
+      }
+
+      public final boolean isInitialized() {
+        if (!hasChainCode()) {
+          
+          return false;
+        }
+        return true;
+      }
+
+      public Builder mergeFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws java.io.IOException {
+        org.bitcoinj.wallet.Protos.DeterministicKey parsedMessage = null;
+        try {
+          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+          parsedMessage = (org.bitcoinj.wallet.Protos.DeterministicKey) e.getUnfinishedMessage();
+          throw e;
+        } finally {
+          if (parsedMessage != null) {
+            mergeFrom(parsedMessage);
+          }
+        }
+        return this;
+      }
+      private int bitField0_;
+
+      // required bytes chain_code = 1;
+      private com.google.protobuf.ByteString chainCode_ = com.google.protobuf.ByteString.EMPTY;
+      /**
+       * <code>required bytes chain_code = 1;</code>
+       *
+       * <pre>
+       * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
+       * should just treat it as a regular ORIGINAL type key.
+       * </pre>
+       */
+      public boolean hasChainCode() {
+        return ((bitField0_ & 0x00000001) == 0x00000001);
+      }
+      /**
+       * <code>required bytes chain_code = 1;</code>
+       *
+       * <pre>
+       * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
+       * should just treat it as a regular ORIGINAL type key.
+       * </pre>
+       */
+      public com.google.protobuf.ByteString getChainCode() {
+        return chainCode_;
+      }
+      /**
+       * <code>required bytes chain_code = 1;</code>
+       *
+       * <pre>
+       * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
+       * should just treat it as a regular ORIGINAL type key.
+       * </pre>
+       */
+      public Builder setChainCode(com.google.protobuf.ByteString value) {
+        if (value == null) {
+    throw new NullPointerException();
+  }
+  bitField0_ |= 0x00000001;
+        chainCode_ = value;
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>required bytes chain_code = 1;</code>
+       *
+       * <pre>
+       * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
+       * should just treat it as a regular ORIGINAL type key.
+       * </pre>
+       */
+      public Builder clearChainCode() {
+        bitField0_ = (bitField0_ & ~0x00000001);
+        chainCode_ = getDefaultInstance().getChainCode();
+        onChanged();
+        return this;
+      }
+
+      // repeated uint32 path = 2;
+      private java.util.List<java.lang.Integer> path_ = java.util.Collections.emptyList();
+      private void ensurePathIsMutable() {
+        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
+          path_ = new java.util.ArrayList<java.lang.Integer>(path_);
+          bitField0_ |= 0x00000002;
+         }
+      }
+      /**
+       * <code>repeated uint32 path = 2;</code>
+       *
+       * <pre>
+       * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
+       * and high bit unset for public derivation.
+       * </pre>
+       */
+      public java.util.List<java.lang.Integer>
+          getPathList() {
+        return java.util.Collections.unmodifiableList(path_);
+      }
       /**
-       * <code>required bytes initialisation_vector = 1;</code>
+       * <code>repeated uint32 path = 2;</code>
        *
        * <pre>
-       * The initialisation vector for the AES encryption (16 bytes)
+       * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
+       * and high bit unset for public derivation.
        * </pre>
        */
-      public boolean hasInitialisationVector() {
-        return ((bitField0_ & 0x00000001) == 0x00000001);
+      public int getPathCount() {
+        return path_.size();
       }
       /**
-       * <code>required bytes initialisation_vector = 1;</code>
+       * <code>repeated uint32 path = 2;</code>
        *
        * <pre>
-       * The initialisation vector for the AES encryption (16 bytes)
+       * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
+       * and high bit unset for public derivation.
        * </pre>
        */
-      public com.google.protobuf.ByteString getInitialisationVector() {
-        return initialisationVector_;
+      public int getPath(int index) {
+        return path_.get(index);
       }
       /**
-       * <code>required bytes initialisation_vector = 1;</code>
+       * <code>repeated uint32 path = 2;</code>
        *
        * <pre>
-       * The initialisation vector for the AES encryption (16 bytes)
+       * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
+       * and high bit unset for public derivation.
        * </pre>
        */
-      public Builder setInitialisationVector(com.google.protobuf.ByteString value) {
-        if (value == null) {
-    throw new NullPointerException();
-  }
-  bitField0_ |= 0x00000001;
-        initialisationVector_ = value;
+      public Builder setPath(
+          int index, int value) {
+        ensurePathIsMutable();
+        path_.set(index, value);
         onChanged();
         return this;
       }
       /**
-       * <code>required bytes initialisation_vector = 1;</code>
+       * <code>repeated uint32 path = 2;</code>
        *
        * <pre>
-       * The initialisation vector for the AES encryption (16 bytes)
+       * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
+       * and high bit unset for public derivation.
        * </pre>
        */
-      public Builder clearInitialisationVector() {
-        bitField0_ = (bitField0_ & ~0x00000001);
-        initialisationVector_ = getDefaultInstance().getInitialisationVector();
+      public Builder addPath(int value) {
+        ensurePathIsMutable();
+        path_.add(value);
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>repeated uint32 path = 2;</code>
+       *
+       * <pre>
+       * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
+       * and high bit unset for public derivation.
+       * </pre>
+       */
+      public Builder addAllPath(
+          java.lang.Iterable<? extends java.lang.Integer> values) {
+        ensurePathIsMutable();
+        super.addAll(values, path_);
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>repeated uint32 path = 2;</code>
+       *
+       * <pre>
+       * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
+       * and high bit unset for public derivation.
+       * </pre>
+       */
+      public Builder clearPath() {
+        path_ = java.util.Collections.emptyList();
+        bitField0_ = (bitField0_ & ~0x00000002);
         onChanged();
         return this;
       }
 
-      // required bytes encrypted_private_key = 2;
-      private com.google.protobuf.ByteString encryptedPrivateKey_ = com.google.protobuf.ByteString.EMPTY;
+      // optional uint32 issued_subkeys = 3;
+      private int issuedSubkeys_ ;
       /**
-       * <code>required bytes encrypted_private_key = 2;</code>
+       * <code>optional uint32 issued_subkeys = 3;</code>
        *
        * <pre>
-       * The encrypted private key
+       * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
+       * For the parents of keys being handed out, this is always less than the true number of children: the difference is
+       * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
+       * this wallet - for instance when restoring from backup or if the seed was shared between devices.
+       *
+       * If this field is missing it means we're not issuing subkeys of this key to users.
        * </pre>
        */
-      public boolean hasEncryptedPrivateKey() {
-        return ((bitField0_ & 0x00000002) == 0x00000002);
+      public boolean hasIssuedSubkeys() {
+        return ((bitField0_ & 0x00000004) == 0x00000004);
       }
       /**
-       * <code>required bytes encrypted_private_key = 2;</code>
+       * <code>optional uint32 issued_subkeys = 3;</code>
        *
        * <pre>
-       * The encrypted private key
+       * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
+       * For the parents of keys being handed out, this is always less than the true number of children: the difference is
+       * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
+       * this wallet - for instance when restoring from backup or if the seed was shared between devices.
+       *
+       * If this field is missing it means we're not issuing subkeys of this key to users.
        * </pre>
        */
-      public com.google.protobuf.ByteString getEncryptedPrivateKey() {
-        return encryptedPrivateKey_;
+      public int getIssuedSubkeys() {
+        return issuedSubkeys_;
       }
       /**
-       * <code>required bytes encrypted_private_key = 2;</code>
+       * <code>optional uint32 issued_subkeys = 3;</code>
        *
        * <pre>
-       * The encrypted private key
+       * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
+       * For the parents of keys being handed out, this is always less than the true number of children: the difference is
+       * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
+       * this wallet - for instance when restoring from backup or if the seed was shared between devices.
+       *
+       * If this field is missing it means we're not issuing subkeys of this key to users.
        * </pre>
        */
-      public Builder setEncryptedPrivateKey(com.google.protobuf.ByteString value) {
-        if (value == null) {
-    throw new NullPointerException();
-  }
-  bitField0_ |= 0x00000002;
-        encryptedPrivateKey_ = value;
+      public Builder setIssuedSubkeys(int value) {
+        bitField0_ |= 0x00000004;
+        issuedSubkeys_ = value;
         onChanged();
         return this;
       }
       /**
-       * <code>required bytes encrypted_private_key = 2;</code>
+       * <code>optional uint32 issued_subkeys = 3;</code>
        *
        * <pre>
-       * The encrypted private key
+       * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
+       * For the parents of keys being handed out, this is always less than the true number of children: the difference is
+       * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
+       * this wallet - for instance when restoring from backup or if the seed was shared between devices.
+       *
+       * If this field is missing it means we're not issuing subkeys of this key to users.
        * </pre>
        */
-      public Builder clearEncryptedPrivateKey() {
-        bitField0_ = (bitField0_ & ~0x00000002);
-        encryptedPrivateKey_ = getDefaultInstance().getEncryptedPrivateKey();
+      public Builder clearIssuedSubkeys() {
+        bitField0_ = (bitField0_ & ~0x00000004);
+        issuedSubkeys_ = 0;
+        onChanged();
+        return this;
+      }
+
+      // optional uint32 lookahead_size = 4;
+      private int lookaheadSize_ ;
+      /**
+       * <code>optional uint32 lookahead_size = 4;</code>
+       */
+      public boolean hasLookaheadSize() {
+        return ((bitField0_ & 0x00000008) == 0x00000008);
+      }
+      /**
+       * <code>optional uint32 lookahead_size = 4;</code>
+       */
+      public int getLookaheadSize() {
+        return lookaheadSize_;
+      }
+      /**
+       * <code>optional uint32 lookahead_size = 4;</code>
+       */
+      public Builder setLookaheadSize(int value) {
+        bitField0_ |= 0x00000008;
+        lookaheadSize_ = value;
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>optional uint32 lookahead_size = 4;</code>
+       */
+      public Builder clearLookaheadSize() {
+        bitField0_ = (bitField0_ & ~0x00000008);
+        lookaheadSize_ = 0;
         onChanged();
         return this;
       }
 
-      // @@protoc_insertion_point(builder_scope:wallet.EncryptedPrivateKey)
+      // @@protoc_insertion_point(builder_scope:wallet.DeterministicKey)
     }
 
     static {
-      defaultInstance = new EncryptedPrivateKey(true);
+      defaultInstance = new DeterministicKey(true);
       defaultInstance.initFields();
     }
 
-    // @@protoc_insertion_point(class_scope:wallet.EncryptedPrivateKey)
+    // @@protoc_insertion_point(class_scope:wallet.DeterministicKey)
   }
 
   public interface KeyOrBuilder
@@ -1179,55 +2082,51 @@ public final class Protos {
      */
     org.bitcoinj.wallet.Protos.Key.Type getType();
 
-    // optional bytes private_key = 2;
+    // optional bytes secret_bytes = 2;
     /**
-     * <code>optional bytes private_key = 2;</code>
+     * <code>optional bytes secret_bytes = 2;</code>
      *
      * <pre>
-     * The private EC key bytes without any ASN.1 wrapping.
+     * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
+     * If the secret is encrypted, or this is a "watching entry" then this is missing.
      * </pre>
      */
-    boolean hasPrivateKey();
+    boolean hasSecretBytes();
     /**
-     * <code>optional bytes private_key = 2;</code>
+     * <code>optional bytes secret_bytes = 2;</code>
      *
      * <pre>
-     * The private EC key bytes without any ASN.1 wrapping.
+     * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
+     * If the secret is encrypted, or this is a "watching entry" then this is missing.
      * </pre>
      */
-    com.google.protobuf.ByteString getPrivateKey();
+    com.google.protobuf.ByteString getSecretBytes();
 
-    // optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;
+    // optional .wallet.EncryptedData encrypted_data = 6;
     /**
-     * <code>optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;</code>
+     * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
      *
      * <pre>
-     * The message containing the encrypted private EC key information.
-     * When an EncryptedPrivateKey is present then the (unencrypted) private_key will be a zero length byte array or contain all zeroes.
-     * This is for security of the private key information.
+     * If the secret data is encrypted, then secret_bytes is missing and this field is set.
      * </pre>
      */
-    boolean hasEncryptedPrivateKey();
+    boolean hasEncryptedData();
     /**
-     * <code>optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;</code>
+     * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
      *
      * <pre>
-     * The message containing the encrypted private EC key information.
-     * When an EncryptedPrivateKey is present then the (unencrypted) private_key will be a zero length byte array or contain all zeroes.
-     * This is for security of the private key information.
+     * If the secret data is encrypted, then secret_bytes is missing and this field is set.
      * </pre>
      */
-    org.bitcoinj.wallet.Protos.EncryptedPrivateKey getEncryptedPrivateKey();
+    org.bitcoinj.wallet.Protos.EncryptedData getEncryptedData();
     /**
-     * <code>optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;</code>
+     * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
      *
      * <pre>
-     * The message containing the encrypted private EC key information.
-     * When an EncryptedPrivateKey is present then the (unencrypted) private_key will be a zero length byte array or contain all zeroes.
-     * This is for security of the private key information.
+     * If the secret data is encrypted, then secret_bytes is missing and this field is set.
      * </pre>
      */
-    org.bitcoinj.wallet.Protos.EncryptedPrivateKeyOrBuilder getEncryptedPrivateKeyOrBuilder();
+    org.bitcoinj.wallet.Protos.EncryptedDataOrBuilder getEncryptedDataOrBuilder();
 
     // optional bytes public_key = 3;
     /**
@@ -1235,7 +2134,7 @@ public final class Protos {
      *
      * <pre>
      * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
-     * do lots of slow EC math on startup.
+     * do lots of slow EC math on startup. For DETERMINISTIC_ROOT_SEED entries this is missing.
      * </pre>
      */
     boolean hasPublicKey();
@@ -1244,7 +2143,7 @@ public final class Protos {
      *
      * <pre>
      * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
-     * do lots of slow EC math on startup.
+     * do lots of slow EC math on startup. For DETERMINISTIC_ROOT_SEED entries this is missing.
      * </pre>
      */
     com.google.protobuf.ByteString getPublicKey();
@@ -1281,7 +2180,8 @@ public final class Protos {
      * <code>optional int64 creation_timestamp = 5;</code>
      *
      * <pre>
-     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point.
+     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. Only reason it's
+     * optional is that some very old wallets don't have this data.
      * </pre>
      */
     boolean hasCreationTimestamp();
@@ -1289,10 +2189,25 @@ public final class Protos {
      * <code>optional int64 creation_timestamp = 5;</code>
      *
      * <pre>
-     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point.
+     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. Only reason it's
+     * optional is that some very old wallets don't have this data.
      * </pre>
      */
     long getCreationTimestamp();
+
+    // optional .wallet.DeterministicKey deterministic_key = 7;
+    /**
+     * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
+     */
+    boolean hasDeterministicKey();
+    /**
+     * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
+     */
+    org.bitcoinj.wallet.Protos.DeterministicKey getDeterministicKey();
+    /**
+     * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
+     */
+    org.bitcoinj.wallet.Protos.DeterministicKeyOrBuilder getDeterministicKeyOrBuilder();
   }
   /**
    * Protobuf type {@code wallet.Key}
@@ -1369,7 +2284,7 @@ public final class Protos {
             }
             case 18: {
               bitField0_ |= 0x00000002;
-              privateKey_ = input.readBytes();
+              secretBytes_ = input.readBytes();
               break;
             }
             case 26: {
@@ -1388,18 +2303,31 @@ public final class Protos {
               break;
             }
             case 50: {
-              org.bitcoinj.wallet.Protos.EncryptedPrivateKey.Builder subBuilder = null;
+              org.bitcoinj.wallet.Protos.EncryptedData.Builder subBuilder = null;
               if (((bitField0_ & 0x00000004) == 0x00000004)) {
-                subBuilder = encryptedPrivateKey_.toBuilder();
+                subBuilder = encryptedData_.toBuilder();
               }
-              encryptedPrivateKey_ = input.readMessage(org.bitcoinj.wallet.Protos.EncryptedPrivateKey.PARSER, extensionRegistry);
+              encryptedData_ = input.readMessage(org.bitcoinj.wallet.Protos.EncryptedData.PARSER, extensionRegistry);
               if (subBuilder != null) {
-                subBuilder.mergeFrom(encryptedPrivateKey_);
-                encryptedPrivateKey_ = subBuilder.buildPartial();
+                subBuilder.mergeFrom(encryptedData_);
+                encryptedData_ = subBuilder.buildPartial();
               }
               bitField0_ |= 0x00000004;
               break;
             }
+            case 58: {
+              org.bitcoinj.wallet.Protos.DeterministicKey.Builder subBuilder = null;
+              if (((bitField0_ & 0x00000040) == 0x00000040)) {
+                subBuilder = deterministicKey_.toBuilder();
+              }
+              deterministicKey_ = input.readMessage(org.bitcoinj.wallet.Protos.DeterministicKey.PARSER, extensionRegistry);
+              if (subBuilder != null) {
+                subBuilder.mergeFrom(deterministicKey_);
+                deterministicKey_ = subBuilder.buildPartial();
+              }
+              bitField0_ |= 0x00000040;
+              break;
+            }
           }
         }
       } catch (com.google.protobuf.InvalidProtocolBufferException e) {
@@ -1448,7 +2376,7 @@ public final class Protos {
        * <code>ORIGINAL = 1;</code>
        *
        * <pre>
-       * Unencrypted - Original bitcoin secp256k1 curve
+       ** Unencrypted - Original bitcoin secp256k1 curve 
        * </pre>
        */
       ORIGINAL(0, 1),
@@ -1456,17 +2384,40 @@ public final class Protos {
        * <code>ENCRYPTED_SCRYPT_AES = 2;</code>
        *
        * <pre>
-       * Encrypted with Scrypt and AES - - Original bitcoin secp256k1 curve
+       ** Encrypted with Scrypt and AES - Original bitcoin secp256k1 curve 
        * </pre>
        */
       ENCRYPTED_SCRYPT_AES(1, 2),
+      /**
+       * <code>DETERMINISTIC_ROOT_SEED = 3;</code>
+       *
+       * <pre>
+       **
+       * Not really a key, but rather contains the seed for a deterministic key hierarchy in the private_key field.
+       * The label and public_key fields are missing. Creation timestamp will exist.
+       * </pre>
+       */
+      DETERMINISTIC_ROOT_SEED(2, 3),
+      /**
+       * <code>DETERMINISTIC_KEY = 4;</code>
+       *
+       * <pre>
+       **
+       * A key that was derived deterministically. Note that the root seed that created it may NOT be present in the
+       * wallet, for the case of watching wallets. A deterministic key may or may not have the private key bytes present.
+       * However the public key bytes and the deterministic_key field are guaranteed to exist. In a wallet where there
+       * is a path from this key up to a key that has (possibly encrypted) private bytes, it's expected that the private
+       * key can be rederived on the fly.
+       * </pre>
+       */
+      DETERMINISTIC_KEY(3, 4),
       ;
 
       /**
        * <code>ORIGINAL = 1;</code>
        *
        * <pre>
-       * Unencrypted - Original bitcoin secp256k1 curve
+       ** Unencrypted - Original bitcoin secp256k1 curve 
        * </pre>
        */
       public static final int ORIGINAL_VALUE = 1;
@@ -1474,10 +2425,33 @@ public final class Protos {
        * <code>ENCRYPTED_SCRYPT_AES = 2;</code>
        *
        * <pre>
-       * Encrypted with Scrypt and AES - - Original bitcoin secp256k1 curve
+       ** Encrypted with Scrypt and AES - Original bitcoin secp256k1 curve 
        * </pre>
        */
       public static final int ENCRYPTED_SCRYPT_AES_VALUE = 2;
+      /**
+       * <code>DETERMINISTIC_ROOT_SEED = 3;</code>
+       *
+       * <pre>
+       **
+       * Not really a key, but rather contains the seed for a deterministic key hierarchy in the private_key field.
+       * The label and public_key fields are missing. Creation timestamp will exist.
+       * </pre>
+       */
+      public static final int DETERMINISTIC_ROOT_SEED_VALUE = 3;
+      /**
+       * <code>DETERMINISTIC_KEY = 4;</code>
+       *
+       * <pre>
+       **
+       * A key that was derived deterministically. Note that the root seed that created it may NOT be present in the
+       * wallet, for the case of watching wallets. A deterministic key may or may not have the private key bytes present.
+       * However the public key bytes and the deterministic_key field are guaranteed to exist. In a wallet where there
+       * is a path from this key up to a key that has (possibly encrypted) private bytes, it's expected that the private
+       * key can be rederived on the fly.
+       * </pre>
+       */
+      public static final int DETERMINISTIC_KEY_VALUE = 4;
 
 
       public final int getNumber() { return value; }
@@ -1486,6 +2460,8 @@ public final class Protos {
         switch (value) {
           case 1: return ORIGINAL;
           case 2: return ENCRYPTED_SCRYPT_AES;
+          case 3: return DETERMINISTIC_ROOT_SEED;
+          case 4: return DETERMINISTIC_KEY;
           default: return null;
         }
       }
@@ -1554,68 +2530,64 @@ public final class Protos {
       return type_;
     }
 
-    // optional bytes private_key = 2;
-    public static final int PRIVATE_KEY_FIELD_NUMBER = 2;
-    private com.google.protobuf.ByteString privateKey_;
+    // optional bytes secret_bytes = 2;
+    public static final int SECRET_BYTES_FIELD_NUMBER = 2;
+    private com.google.protobuf.ByteString secretBytes_;
     /**
-     * <code>optional bytes private_key = 2;</code>
+     * <code>optional bytes secret_bytes = 2;</code>
      *
      * <pre>
-     * The private EC key bytes without any ASN.1 wrapping.
+     * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
+     * If the secret is encrypted, or this is a "watching entry" then this is missing.
      * </pre>
      */
-    public boolean hasPrivateKey() {
+    public boolean hasSecretBytes() {
       return ((bitField0_ & 0x00000002) == 0x00000002);
     }
     /**
-     * <code>optional bytes private_key = 2;</code>
+     * <code>optional bytes secret_bytes = 2;</code>
      *
      * <pre>
-     * The private EC key bytes without any ASN.1 wrapping.
+     * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
+     * If the secret is encrypted, or this is a "watching entry" then this is missing.
      * </pre>
      */
-    public com.google.protobuf.ByteString getPrivateKey() {
-      return privateKey_;
+    public com.google.protobuf.ByteString getSecretBytes() {
+      return secretBytes_;
     }
 
-    // optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;
-    public static final int ENCRYPTED_PRIVATE_KEY_FIELD_NUMBER = 6;
-    private org.bitcoinj.wallet.Protos.EncryptedPrivateKey encryptedPrivateKey_;
+    // optional .wallet.EncryptedData encrypted_data = 6;
+    public static final int ENCRYPTED_DATA_FIELD_NUMBER = 6;
+    private org.bitcoinj.wallet.Protos.EncryptedData encryptedData_;
     /**
-     * <code>optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;</code>
+     * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
      *
      * <pre>
-     * The message containing the encrypted private EC key information.
-     * When an EncryptedPrivateKey is present then the (unencrypted) private_key will be a zero length byte array or contain all zeroes.
-     * This is for security of the private key information.
+     * If the secret data is encrypted, then secret_bytes is missing and this field is set.
      * </pre>
      */
-    public boolean hasEncryptedPrivateKey() {
+    public boolean hasEncryptedData() {
       return ((bitField0_ & 0x00000004) == 0x00000004);
     }
     /**
-     * <code>optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;</code>
+     * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
      *
      * <pre>
-     * The message containing the encrypted private EC key information.
-     * When an EncryptedPrivateKey is present then the (unencrypted) private_key will be a zero length byte array or contain all zeroes.
-     * This is for security of the private key information.
+     * If the secret data is encrypted, then secret_bytes is missing and this field is set.
      * </pre>
      */
-    public org.bitcoinj.wallet.Protos.EncryptedPrivateKey getEncryptedPrivateKey() {
-      return encryptedPrivateKey_;
+    public org.bitcoinj.wallet.Protos.EncryptedData getEncryptedData() {
+      return encryptedData_;
     }
     /**
-     * <code>optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;</code>
+     * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
      *
      * <pre>
-     * The message containing the encrypted private EC key information.
-     * When an EncryptedPrivateKey is present then the (unencrypted) private_key will be a zero length byte array or contain all zeroes.
-     * This is for security of the private key information.
+     * If the secret data is encrypted, then secret_bytes is missing and this field is set.
      * </pre>
      */
-    public org.bitcoinj.wallet.Protos.EncryptedPrivateKeyOrBuilder getEncryptedPrivateKeyOrBuilder() {
-      return encryptedPrivateKey_;
+    public org.bitcoinj.wallet.Protos.EncryptedDataOrBuilder getEncryptedDataOrBuilder() {
+      return encryptedData_;
     }
 
     // optional bytes public_key = 3;
@@ -1626,7 +2598,7 @@ public final class Protos {
      *
      * <pre>
      * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
-     * do lots of slow EC math on startup.
+     * do lots of slow EC math on startup. For DETERMINISTIC_ROOT_SEED entries this is missing.
      * </pre>
      */
     public boolean hasPublicKey() {
@@ -1637,7 +2609,7 @@ public final class Protos {
      *
      * <pre>
      * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
-     * do lots of slow EC math on startup.
+     * do lots of slow EC math on startup. For DETERMINISTIC_ROOT_SEED entries this is missing.
      * </pre>
      */
     public com.google.protobuf.ByteString getPublicKey() {
@@ -1706,7 +2678,8 @@ public final class Protos {
      * <code>optional int64 creation_timestamp = 5;</code>
      *
      * <pre>
-     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point.
+     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. Only reason it's
+     * optional is that some very old wallets don't have this data.
      * </pre>
      */
     public boolean hasCreationTimestamp() {
@@ -1716,20 +2689,44 @@ public final class Protos {
      * <code>optional int64 creation_timestamp = 5;</code>
      *
      * <pre>
-     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point.
+     * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. Only reason it's
+     * optional is that some very old wallets don't have this data.
      * </pre>
      */
     public long getCreationTimestamp() {
       return creationTimestamp_;
     }
 
+    // optional .wallet.DeterministicKey deterministic_key = 7;
+    public static final int DETERMINISTIC_KEY_FIELD_NUMBER = 7;
+    private org.bitcoinj.wallet.Protos.DeterministicKey deterministicKey_;
+    /**
+     * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
+     */
+    public boolean hasDeterministicKey() {
+      return ((bitField0_ & 0x00000040) == 0x00000040);
+    }
+    /**
+     * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
+     */
+    public org.bitcoinj.wallet.Protos.DeterministicKey getDeterministicKey() {
+      return deterministicKey_;
+    }
+    /**
+     * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
+     */
+    public org.bitcoinj.wallet.Protos.DeterministicKeyOrBuilder getDeterministicKeyOrBuilder() {
+      return deterministicKey_;
+    }
+
     private void initFields() {
       type_ = org.bitcoinj.wallet.Protos.Key.Type.ORIGINAL;
-      privateKey_ = com.google.protobuf.ByteString.EMPTY;
-      encryptedPrivateKey_ = org.bitcoinj.wallet.Protos.EncryptedPrivateKey.getDefaultInstance();
+      secretBytes_ = com.google.protobuf.ByteString.EMPTY;
+      encryptedData_ = org.bitcoinj.wallet.Protos.EncryptedData.getDefaultInstance();
       publicKey_ = com.google.protobuf.ByteString.EMPTY;
       label_ = "";
       creationTimestamp_ = 0L;
+      deterministicKey_ = org.bitcoinj.wallet.Protos.DeterministicKey.getDefaultInstance();
     }
     private byte memoizedIsInitialized = -1;
     public final boolean isInitialized() {
@@ -1740,8 +2737,14 @@ public final class Protos {
         memoizedIsInitialized = 0;
         return false;
       }
-      if (hasEncryptedPrivateKey()) {
-        if (!getEncryptedPrivateKey().isInitialized()) {
+      if (hasEncryptedData()) {
+        if (!getEncryptedData().isInitialized()) {
+          memoizedIsInitialized = 0;
+          return false;
+        }
+      }
+      if (hasDeterministicKey()) {
+        if (!getDeterministicKey().isInitialized()) {
           memoizedIsInitialized = 0;
           return false;
         }
@@ -1757,7 +2760,7 @@ public final class Protos {
         output.writeEnum(1, type_.getNumber());
       }
       if (((bitField0_ & 0x00000002) == 0x00000002)) {
-        output.writeBytes(2, privateKey_);
+        output.writeBytes(2, secretBytes_);
       }
       if (((bitField0_ & 0x00000008) == 0x00000008)) {
         output.writeBytes(3, publicKey_);
@@ -1769,7 +2772,10 @@ public final class Protos {
         output.writeInt64(5, creationTimestamp_);
       }
       if (((bitField0_ & 0x00000004) == 0x00000004)) {
-        output.writeMessage(6, encryptedPrivateKey_);
+        output.writeMessage(6, encryptedData_);
+      }
+      if (((bitField0_ & 0x00000040) == 0x00000040)) {
+        output.writeMessage(7, deterministicKey_);
       }
       getUnknownFields().writeTo(output);
     }
@@ -1786,7 +2792,7 @@ public final class Protos {
       }
       if (((bitField0_ & 0x00000002) == 0x00000002)) {
         size += com.google.protobuf.CodedOutputStream
-          .computeBytesSize(2, privateKey_);
+          .computeBytesSize(2, secretBytes_);
       }
       if (((bitField0_ & 0x00000008) == 0x00000008)) {
         size += com.google.protobuf.CodedOutputStream
@@ -1802,7 +2808,11 @@ public final class Protos {
       }
       if (((bitField0_ & 0x00000004) == 0x00000004)) {
         size += com.google.protobuf.CodedOutputStream
-          .computeMessageSize(6, encryptedPrivateKey_);
+          .computeMessageSize(6, encryptedData_);
+      }
+      if (((bitField0_ & 0x00000040) == 0x00000040)) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeMessageSize(7, deterministicKey_);
       }
       size += getUnknownFields().getSerializedSize();
       memoizedSerializedSize = size;
@@ -1923,7 +2933,8 @@ public final class Protos {
       }
       private void maybeForceBuilderInitialization() {
         if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
-          getEncryptedPrivateKeyFieldBuilder();
+          getEncryptedDataFieldBuilder();
+          getDeterministicKeyFieldBuilder();
         }
       }
       private static Builder create() {
@@ -1934,12 +2945,12 @@ public final class Protos {
         super.clear();
         type_ = org.bitcoinj.wallet.Protos.Key.Type.ORIGINAL;
         bitField0_ = (bitField0_ & ~0x00000001);
-        privateKey_ = com.google.protobuf.ByteString.EMPTY;
+        secretBytes_ = com.google.protobuf.ByteString.EMPTY;
         bitField0_ = (bitField0_ & ~0x00000002);
-        if (encryptedPrivateKeyBuilder_ == null) {
-          encryptedPrivateKey_ = org.bitcoinj.wallet.Protos.EncryptedPrivateKey.getDefaultInstance();
+        if (encryptedDataBuilder_ == null) {
+          encryptedData_ = org.bitcoinj.wallet.Protos.EncryptedData.getDefaultInstance();
         } else {
-          encryptedPrivateKeyBuilder_.clear();
+          encryptedDataBuilder_.clear();
         }
         bitField0_ = (bitField0_ & ~0x00000004);
         publicKey_ = com.google.protobuf.ByteString.EMPTY;
@@ -1948,6 +2959,12 @@ public final class Protos {
         bitField0_ = (bitField0_ & ~0x00000010);
         creationTimestamp_ = 0L;
         bitField0_ = (bitField0_ & ~0x00000020);
+        if (deterministicKeyBuilder_ == null) {
+          deterministicKey_ = org.bitcoinj.wallet.Protos.DeterministicKey.getDefaultInstance();
+        } else {
+          deterministicKeyBuilder_.clear();
+        }
+        bitField0_ = (bitField0_ & ~0x00000040);
         return this;
       }
 
@@ -1983,14 +3000,14 @@ public final class Protos {
         if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
           to_bitField0_ |= 0x00000002;
         }
-        result.privateKey_ = privateKey_;
+        result.secretBytes_ = secretBytes_;
         if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
           to_bitField0_ |= 0x00000004;
         }
-        if (encryptedPrivateKeyBuilder_ == null) {
-          result.encryptedPrivateKey_ = encryptedPrivateKey_;
+        if (encryptedDataBuilder_ == null) {
+          result.encryptedData_ = encryptedData_;
         } else {
-          result.encryptedPrivateKey_ = encryptedPrivateKeyBuilder_.build();
+          result.encryptedData_ = encryptedDataBuilder_.build();
         }
         if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
           to_bitField0_ |= 0x00000008;
@@ -2004,6 +3021,14 @@ public final class Protos {
           to_bitField0_ |= 0x00000020;
         }
         result.creationTimestamp_ = creationTimestamp_;
+        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
+          to_bitField0_ |= 0x00000040;
+        }
+        if (deterministicKeyBuilder_ == null) {
+          result.deterministicKey_ = deterministicKey_;
+        } else {
+          result.deterministicKey_ = deterministicKeyBuilder_.build();
+        }
         result.bitField0_ = to_bitField0_;
         onBuilt();
         return result;
@@ -2023,11 +3048,11 @@ public final class Protos {
         if (other.hasType()) {
           setType(other.getType());
         }
-        if (other.hasPrivateKey()) {
-          setPrivateKey(other.getPrivateKey());
+        if (other.hasSecretBytes()) {
+          setSecretBytes(other.getSecretBytes());
         }
-        if (other.hasEncryptedPrivateKey()) {
-          mergeEncryptedPrivateKey(other.getEncryptedPrivateKey());
+        if (other.hasEncryptedData()) {
+          mergeEncryptedData(other.getEncryptedData());
         }
         if (other.hasPublicKey()) {
           setPublicKey(other.getPublicKey());
@@ -2040,6 +3065,9 @@ public final class Protos {
         if (other.hasCreationTimestamp()) {
           setCreationTimestamp(other.getCreationTimestamp());
         }
+        if (other.hasDeterministicKey()) {
+          mergeDeterministicKey(other.getDeterministicKey());
+        }
         this.mergeUnknownFields(other.getUnknownFields());
         return this;
       }
@@ -2049,8 +3077,14 @@ public final class Protos {
           
           return false;
         }
-        if (hasEncryptedPrivateKey()) {
-          if (!getEncryptedPrivateKey().isInitialized()) {
+        if (hasEncryptedData()) {
+          if (!getEncryptedData().isInitialized()) {
+            
+            return false;
+          }
+        }
+        if (hasDeterministicKey()) {
+          if (!getDeterministicKey().isInitialized()) {
             
             return false;
           }
@@ -2113,227 +3147,213 @@ public final class Protos {
         return this;
       }
 
-      // optional bytes private_key = 2;
-      private com.google.protobuf.ByteString privateKey_ = com.google.protobuf.ByteString.EMPTY;
+      // optional bytes secret_bytes = 2;
+      private com.google.protobuf.ByteString secretBytes_ = com.google.protobuf.ByteString.EMPTY;
       /**
-       * <code>optional bytes private_key = 2;</code>
+       * <code>optional bytes secret_bytes = 2;</code>
        *
        * <pre>
-       * The private EC key bytes without any ASN.1 wrapping.
+       * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
+       * If the secret is encrypted, or this is a "watching entry" then this is missing.
        * </pre>
        */
-      public boolean hasPrivateKey() {
+      public boolean hasSecretBytes() {
         return ((bitField0_ & 0x00000002) == 0x00000002);
       }
       /**
-       * <code>optional bytes private_key = 2;</code>
+       * <code>optional bytes secret_bytes = 2;</code>
        *
        * <pre>
-       * The private EC key bytes without any ASN.1 wrapping.
+       * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
+       * If the secret is encrypted, or this is a "watching entry" then this is missing.
        * </pre>
        */
-      public com.google.protobuf.ByteString getPrivateKey() {
-        return privateKey_;
+      public com.google.protobuf.ByteString getSecretBytes() {
+        return secretBytes_;
       }
       /**
-       * <code>optional bytes private_key = 2;</code>
+       * <code>optional bytes secret_bytes = 2;</code>
        *
        * <pre>
-       * The private EC key bytes without any ASN.1 wrapping.
+       * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
+       * If the secret is encrypted, or this is a "watching entry" then this is missing.
        * </pre>
        */
-      public Builder setPrivateKey(com.google.protobuf.ByteString value) {
+      public Builder setSecretBytes(com.google.protobuf.ByteString value) {
         if (value == null) {
     throw new NullPointerException();
   }
   bitField0_ |= 0x00000002;
-        privateKey_ = value;
+        secretBytes_ = value;
         onChanged();
         return this;
       }
       /**
-       * <code>optional bytes private_key = 2;</code>
+       * <code>optional bytes secret_bytes = 2;</code>
        *
        * <pre>
-       * The private EC key bytes without any ASN.1 wrapping.
+       * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
+       * If the secret is encrypted, or this is a "watching entry" then this is missing.
        * </pre>
        */
-      public Builder clearPrivateKey() {
+      public Builder clearSecretBytes() {
         bitField0_ = (bitField0_ & ~0x00000002);
-        privateKey_ = getDefaultInstance().getPrivateKey();
+        secretBytes_ = getDefaultInstance().getSecretBytes();
         onChanged();
         return this;
       }
 
-      // optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;
-      private org.bitcoinj.wallet.Protos.EncryptedPrivateKey encryptedPrivateKey_ = org.bitcoinj.wallet.Protos.EncryptedPrivateKey.getDefaultInstance();
+      // optional .wallet.EncryptedData encrypted_data = 6;
+      private org.bitcoinj.wallet.Protos.EncryptedData encryptedData_ = org.bitcoinj.wallet.Protos.EncryptedData.getDefaultInstance();
       private com.google.protobuf.SingleFieldBuilder<
-          org.bitcoinj.wallet.Protos.EncryptedPrivateKey, org.bitcoinj.wallet.Protos.EncryptedPrivateKey.Builder, org.bitcoinj.wallet.Protos.EncryptedPrivateKeyOrBuilder> encryptedPrivateKeyBuilder_;
+          org.bitcoinj.wallet.Protos.EncryptedData, org.bitcoinj.wallet.Protos.EncryptedData.Builder, org.bitcoinj.wallet.Protos.EncryptedDataOrBuilder> encryptedDataBuilder_;
       /**
-       * <code>optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;</code>
+       * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
        *
        * <pre>
-       * The message containing the encrypted private EC key information.
-       * When an EncryptedPrivateKey is present then the (unencrypted) private_key will be a zero length byte array or contain all zeroes.
-       * This is for security of the private key information.
+       * If the secret data is encrypted, then secret_bytes is missing and this field is set.
        * </pre>
        */
-      public boolean hasEncryptedPrivateKey() {
+      public boolean hasEncryptedData() {
         return ((bitField0_ & 0x00000004) == 0x00000004);
       }
       /**
-       * <code>optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;</code>
+       * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
        *
        * <pre>
-       * The message containing the encrypted private EC key information.
-       * When an EncryptedPrivateKey is present then the (unencrypted) private_key will be a zero length byte array or contain all zeroes.
-       * This is for security of the private key information.
+       * If the secret data is encrypted, then secret_bytes is missing and this field is set.
        * </pre>
        */
-      public org.bitcoinj.wallet.Protos.EncryptedPrivateKey getEncryptedPrivateKey() {
-        if (encryptedPrivateKeyBuilder_ == null) {
-          return encryptedPrivateKey_;
+      public org.bitcoinj.wallet.Protos.EncryptedData getEncryptedData() {
+        if (encryptedDataBuilder_ == null) {
+          return encryptedData_;
         } else {
-          return encryptedPrivateKeyBuilder_.getMessage();
+          return encryptedDataBuilder_.getMessage();
         }
       }
       /**
-       * <code>optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;</code>
+       * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
        *
        * <pre>
-       * The message containing the encrypted private EC key information.
-       * When an EncryptedPrivateKey is present then the (unencrypted) private_key will be a zero length byte array or contain all zeroes.
-       * This is for security of the private key information.
+       * If the secret data is encrypted, then secret_bytes is missing and this field is set.
        * </pre>
        */
-      public Builder setEncryptedPrivateKey(org.bitcoinj.wallet.Protos.EncryptedPrivateKey value) {
-        if (encryptedPrivateKeyBuilder_ == null) {
+      public Builder setEncryptedData(org.bitcoinj.wallet.Protos.EncryptedData value) {
+        if (encryptedDataBuilder_ == null) {
           if (value == null) {
             throw new NullPointerException();
           }
-          encryptedPrivateKey_ = value;
+          encryptedData_ = value;
           onChanged();
         } else {
-          encryptedPrivateKeyBuilder_.setMessage(value);
+          encryptedDataBuilder_.setMessage(value);
         }
         bitField0_ |= 0x00000004;
         return this;
       }
       /**
-       * <code>optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;</code>
+       * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
        *
        * <pre>
-       * The message containing the encrypted private EC key information.
-       * When an EncryptedPrivateKey is present then the (unencrypted) private_key will be a zero length byte array or contain all zeroes.
-       * This is for security of the private key information.
+       * If the secret data is encrypted, then secret_bytes is missing and this field is set.
        * </pre>
        */
-      public Builder setEncryptedPrivateKey(
-          org.bitcoinj.wallet.Protos.EncryptedPrivateKey.Builder builderForValue) {
-        if (encryptedPrivateKeyBuilder_ == null) {
-          encryptedPrivateKey_ = builderForValue.build();
+      public Builder setEncryptedData(
+          org.bitcoinj.wallet.Protos.EncryptedData.Builder builderForValue) {
+        if (encryptedDataBuilder_ == null) {
+          encryptedData_ = builderForValue.build();
           onChanged();
         } else {
-          encryptedPrivateKeyBuilder_.setMessage(builderForValue.build());
+          encryptedDataBuilder_.setMessage(builderForValue.build());
         }
         bitField0_ |= 0x00000004;
         return this;
       }
       /**
-       * <code>optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;</code>
+       * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
        *
        * <pre>
-       * The message containing the encrypted private EC key information.
-       * When an EncryptedPrivateKey is present then the (unencrypted) private_key will be a zero length byte array or contain all zeroes.
-       * This is for security of the private key information.
+       * If the secret data is encrypted, then secret_bytes is missing and this field is set.
        * </pre>
        */
-      public Builder mergeEncryptedPrivateKey(org.bitcoinj.wallet.Protos.EncryptedPrivateKey value) {
-        if (encryptedPrivateKeyBuilder_ == null) {
+      public Builder mergeEncryptedData(org.bitcoinj.wallet.Protos.EncryptedData value) {
+        if (encryptedDataBuilder_ == null) {
           if (((bitField0_ & 0x00000004) == 0x00000004) &&
-              encryptedPrivateKey_ != org.bitcoinj.wallet.Protos.EncryptedPrivateKey.getDefaultInstance()) {
-            encryptedPrivateKey_ =
-              org.bitcoinj.wallet.Protos.EncryptedPrivateKey.newBuilder(encryptedPrivateKey_).mergeFrom(value).buildPartial();
+              encryptedData_ != org.bitcoinj.wallet.Protos.EncryptedData.getDefaultInstance()) {
+            encryptedData_ =
+              org.bitcoinj.wallet.Protos.EncryptedData.newBuilder(encryptedData_).mergeFrom(value).buildPartial();
           } else {
-            encryptedPrivateKey_ = value;
+            encryptedData_ = value;
           }
           onChanged();
         } else {
-          encryptedPrivateKeyBuilder_.mergeFrom(value);
+          encryptedDataBuilder_.mergeFrom(value);
         }
         bitField0_ |= 0x00000004;
         return this;
       }
       /**
-       * <code>optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;</code>
+       * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
        *
        * <pre>
-       * The message containing the encrypted private EC key information.
-       * When an EncryptedPrivateKey is present then the (unencrypted) private_key will be a zero length byte array or contain all zeroes.
-       * This is for security of the private key information.
+       * If the secret data is encrypted, then secret_bytes is missing and this field is set.
        * </pre>
        */
-      public Builder clearEncryptedPrivateKey() {
-        if (encryptedPrivateKeyBuilder_ == null) {
-          encryptedPrivateKey_ = org.bitcoinj.wallet.Protos.EncryptedPrivateKey.getDefaultInstance();
+      public Builder clearEncryptedData() {
+        if (encryptedDataBuilder_ == null) {
+          encryptedData_ = org.bitcoinj.wallet.Protos.EncryptedData.getDefaultInstance();
           onChanged();
         } else {
-          encryptedPrivateKeyBuilder_.clear();
+          encryptedDataBuilder_.clear();
         }
         bitField0_ = (bitField0_ & ~0x00000004);
         return this;
       }
       /**
-       * <code>optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;</code>
+       * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
        *
        * <pre>
-       * The message containing the encrypted private EC key information.
-       * When an EncryptedPrivateKey is present then the (unencrypted) private_key will be a zero length byte array or contain all zeroes.
-       * This is for security of the private key information.
+       * If the secret data is encrypted, then secret_bytes is missing and this field is set.
        * </pre>
        */
-      public org.bitcoinj.wallet.Protos.EncryptedPrivateKey.Builder getEncryptedPrivateKeyBuilder() {
+      public org.bitcoinj.wallet.Protos.EncryptedData.Builder getEncryptedDataBuilder() {
         bitField0_ |= 0x00000004;
         onChanged();
-        return getEncryptedPrivateKeyFieldBuilder().getBuilder();
+        return getEncryptedDataFieldBuilder().getBuilder();
       }
       /**
-       * <code>optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;</code>
+       * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
        *
        * <pre>
-       * The message containing the encrypted private EC key information.
-       * When an EncryptedPrivateKey is present then the (unencrypted) private_key will be a zero length byte array or contain all zeroes.
-       * This is for security of the private key information.
+       * If the secret data is encrypted, then secret_bytes is missing and this field is set.
        * </pre>
        */
-      public org.bitcoinj.wallet.Protos.EncryptedPrivateKeyOrBuilder getEncryptedPrivateKeyOrBuilder() {
-        if (encryptedPrivateKeyBuilder_ != null) {
-          return encryptedPrivateKeyBuilder_.getMessageOrBuilder();
+      public org.bitcoinj.wallet.Protos.EncryptedDataOrBuilder getEncryptedDataOrBuilder() {
+        if (encryptedDataBuilder_ != null) {
+          return encryptedDataBuilder_.getMessageOrBuilder();
         } else {
-          return encryptedPrivateKey_;
+          return encryptedData_;
         }
       }
       /**
-       * <code>optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;</code>
+       * <code>optional .wallet.EncryptedData encrypted_data = 6;</code>
        *
        * <pre>
-       * The message containing the encrypted private EC key information.
-       * When an EncryptedPrivateKey is present then the (unencrypted) private_key will be a zero length byte array or contain all zeroes.
-       * This is for security of the private key information.
+       * If the secret data is encrypted, then secret_bytes is missing and this field is set.
        * </pre>
        */
       private com.google.protobuf.SingleFieldBuilder<
-          org.bitcoinj.wallet.Protos.EncryptedPrivateKey, org.bitcoinj.wallet.Protos.EncryptedPrivateKey.Builder, org.bitcoinj.wallet.Protos.EncryptedPrivateKeyOrBuilder> 
-          getEncryptedPrivateKeyFieldBuilder() {
-        if (encryptedPrivateKeyBuilder_ == null) {
-          encryptedPrivateKeyBuilder_ = new com.google.protobuf.SingleFieldBuilder<
-              org.bitcoinj.wallet.Protos.EncryptedPrivateKey, org.bitcoinj.wallet.Protos.EncryptedPrivateKey.Builder, org.bitcoinj.wallet.Protos.EncryptedPrivateKeyOrBuilder>(
-                  encryptedPrivateKey_,
+          org.bitcoinj.wallet.Protos.EncryptedData, org.bitcoinj.wallet.Protos.EncryptedData.Builder, org.bitcoinj.wallet.Protos.EncryptedDataOrBuilder> 
+          getEncryptedDataFieldBuilder() {
+        if (encryptedDataBuilder_ == null) {
+          encryptedDataBuilder_ = new com.google.protobuf.SingleFieldBuilder<
+              org.bitcoinj.wallet.Protos.EncryptedData, org.bitcoinj.wallet.Protos.EncryptedData.Builder, org.bitcoinj.wallet.Protos.EncryptedDataOrBuilder>(
+                  encryptedData_,
                   getParentForChildren(),
                   isClean());
-          encryptedPrivateKey_ = null;
+          encryptedData_ = null;
         }
-        return encryptedPrivateKeyBuilder_;
+        return encryptedDataBuilder_;
       }
 
       // optional bytes public_key = 3;
@@ -2343,7 +3363,7 @@ public final class Protos {
        *
        * <pre>
        * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
-       * do lots of slow EC math on startup.
+       * do lots of slow EC math on startup. For DETERMINISTIC_ROOT_SEED entries this is missing.
        * </pre>
        */
       public boolean hasPublicKey() {
@@ -2354,7 +3374,7 @@ public final class Protos {
        *
        * <pre>
        * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
-       * do lots of slow EC math on startup.
+       * do lots of slow EC math on startup. For DETERMINISTIC_ROOT_SEED entries this is missing.
        * </pre>
        */
       public com.google.protobuf.ByteString getPublicKey() {
@@ -2365,7 +3385,7 @@ public final class Protos {
        *
        * <pre>
        * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
-       * do lots of slow EC math on startup.
+       * do lots of slow EC math on startup. For DETERMINISTIC_ROOT_SEED entries this is missing.
        * </pre>
        */
       public Builder setPublicKey(com.google.protobuf.ByteString value) {
@@ -2382,7 +3402,7 @@ public final class Protos {
        *
        * <pre>
        * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
-       * do lots of slow EC math on startup.
+       * do lots of slow EC math on startup. For DETERMINISTIC_ROOT_SEED entries this is missing.
        * </pre>
        */
       public Builder clearPublicKey() {
@@ -2496,7 +3516,8 @@ public final class Protos {
        * <code>optional int64 creation_timestamp = 5;</code>
        *
        * <pre>
-       * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point.
+       * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. Only reason it's
+       * optional is that some very old wallets don't have this data.
        * </pre>
        */
       public boolean hasCreationTimestamp() {
@@ -2506,7 +3527,8 @@ public final class Protos {
        * <code>optional int64 creation_timestamp = 5;</code>
        *
        * <pre>
-       * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point.
+       * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. Only reason it's
+       * optional is that some very old wallets don't have this data.
        * </pre>
        */
       public long getCreationTimestamp() {
@@ -2516,7 +3538,8 @@ public final class Protos {
        * <code>optional int64 creation_timestamp = 5;</code>
        *
        * <pre>
-       * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point.
+       * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. Only reason it's
+       * optional is that some very old wallets don't have this data.
        * </pre>
        */
       public Builder setCreationTimestamp(long value) {
@@ -2529,7 +3552,8 @@ public final class Protos {
        * <code>optional int64 creation_timestamp = 5;</code>
        *
        * <pre>
-       * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point.
+       * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. Only reason it's
+       * optional is that some very old wallets don't have this data.
        * </pre>
        */
       public Builder clearCreationTimestamp() {
@@ -2539,6 +3563,123 @@ public final class Protos {
         return this;
       }
 
+      // optional .wallet.DeterministicKey deterministic_key = 7;
+      private org.bitcoinj.wallet.Protos.DeterministicKey deterministicKey_ = org.bitcoinj.wallet.Protos.DeterministicKey.getDefaultInstance();
+      private com.google.protobuf.SingleFieldBuilder<
+          org.bitcoinj.wallet.Protos.DeterministicKey, org.bitcoinj.wallet.Protos.DeterministicKey.Builder, org.bitcoinj.wallet.Protos.DeterministicKeyOrBuilder> deterministicKeyBuilder_;
+      /**
+       * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
+       */
+      public boolean hasDeterministicKey() {
+        return ((bitField0_ & 0x00000040) == 0x00000040);
+      }
+      /**
+       * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
+       */
+      public org.bitcoinj.wallet.Protos.DeterministicKey getDeterministicKey() {
+        if (deterministicKeyBuilder_ == null) {
+          return deterministicKey_;
+        } else {
+          return deterministicKeyBuilder_.getMessage();
+        }
+      }
+      /**
+       * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
+       */
+      public Builder setDeterministicKey(org.bitcoinj.wallet.Protos.DeterministicKey value) {
+        if (deterministicKeyBuilder_ == null) {
+          if (value == null) {
+            throw new NullPointerException();
+          }
+          deterministicKey_ = value;
+          onChanged();
+        } else {
+          deterministicKeyBuilder_.setMessage(value);
+        }
+        bitField0_ |= 0x00000040;
+        return this;
+      }
+      /**
+       * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
+       */
+      public Builder setDeterministicKey(
+          org.bitcoinj.wallet.Protos.DeterministicKey.Builder builderForValue) {
+        if (deterministicKeyBuilder_ == null) {
+          deterministicKey_ = builderForValue.build();
+          onChanged();
+        } else {
+          deterministicKeyBuilder_.setMessage(builderForValue.build());
+        }
+        bitField0_ |= 0x00000040;
+        return this;
+      }
+      /**
+       * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
+       */
+      public Builder mergeDeterministicKey(org.bitcoinj.wallet.Protos.DeterministicKey value) {
+        if (deterministicKeyBuilder_ == null) {
+          if (((bitField0_ & 0x00000040) == 0x00000040) &&
+              deterministicKey_ != org.bitcoinj.wallet.Protos.DeterministicKey.getDefaultInstance()) {
+            deterministicKey_ =
+              org.bitcoinj.wallet.Protos.DeterministicKey.newBuilder(deterministicKey_).mergeFrom(value).buildPartial();
+          } else {
+            deterministicKey_ = value;
+          }
+          onChanged();
+        } else {
+          deterministicKeyBuilder_.mergeFrom(value);
+        }
+        bitField0_ |= 0x00000040;
+        return this;
+      }
+      /**
+       * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
+       */
+      public Builder clearDeterministicKey() {
+        if (deterministicKeyBuilder_ == null) {
+          deterministicKey_ = org.bitcoinj.wallet.Protos.DeterministicKey.getDefaultInstance();
+          onChanged();
+        } else {
+          deterministicKeyBuilder_.clear();
+        }
+        bitField0_ = (bitField0_ & ~0x00000040);
+        return this;
+      }
+      /**
+       * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
+       */
+      public org.bitcoinj.wallet.Protos.DeterministicKey.Builder getDeterministicKeyBuilder() {
+        bitField0_ |= 0x00000040;
+        onChanged();
+        return getDeterministicKeyFieldBuilder().getBuilder();
+      }
+      /**
+       * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
+       */
+      public org.bitcoinj.wallet.Protos.DeterministicKeyOrBuilder getDeterministicKeyOrBuilder() {
+        if (deterministicKeyBuilder_ != null) {
+          return deterministicKeyBuilder_.getMessageOrBuilder();
+        } else {
+          return deterministicKey_;
+        }
+      }
+      /**
+       * <code>optional .wallet.DeterministicKey deterministic_key = 7;</code>
+       */
+      private com.google.protobuf.SingleFieldBuilder<
+          org.bitcoinj.wallet.Protos.DeterministicKey, org.bitcoinj.wallet.Protos.DeterministicKey.Builder, org.bitcoinj.wallet.Protos.DeterministicKeyOrBuilder> 
+          getDeterministicKeyFieldBuilder() {
+        if (deterministicKeyBuilder_ == null) {
+          deterministicKeyBuilder_ = new com.google.protobuf.SingleFieldBuilder<
+              org.bitcoinj.wallet.Protos.DeterministicKey, org.bitcoinj.wallet.Protos.DeterministicKey.Builder, org.bitcoinj.wallet.Protos.DeterministicKeyOrBuilder>(
+                  deterministicKey_,
+                  getParentForChildren(),
+                  isClean());
+          deterministicKey_ = null;
+        }
+        return deterministicKeyBuilder_;
+      }
+
       // @@protoc_insertion_point(builder_scope:wallet.Key)
     }
 
@@ -13736,10 +14877,15 @@ public final class Protos {
     com.google.protobuf.GeneratedMessage.FieldAccessorTable
       internal_static_wallet_PeerAddress_fieldAccessorTable;
   private static com.google.protobuf.Descriptors.Descriptor
-    internal_static_wallet_EncryptedPrivateKey_descriptor;
+    internal_static_wallet_EncryptedData_descriptor;
+  private static
+    com.google.protobuf.GeneratedMessage.FieldAccessorTable
+      internal_static_wallet_EncryptedData_fieldAccessorTable;
+  private static com.google.protobuf.Descriptors.Descriptor
+    internal_static_wallet_DeterministicKey_descriptor;
   private static
     com.google.protobuf.GeneratedMessage.FieldAccessorTable
-      internal_static_wallet_EncryptedPrivateKey_fieldAccessorTable;
+      internal_static_wallet_DeterministicKey_fieldAccessorTable;
   private static com.google.protobuf.Descriptors.Descriptor
     internal_static_wallet_Key_descriptor;
   private static
@@ -13794,66 +14940,71 @@ public final class Protos {
       descriptor;
   static {
     java.lang.String[] descriptorData = {
-      "\n\rbitcoin.proto\022\006wallet\"A\n\013PeerAddress\022\022" +
-      "\n\nip_address\030\001 \002(\014\022\014\n\004port\030\002 \002(\r\022\020\n\010serv" +
-      "ices\030\003 \002(\004\"S\n\023EncryptedPrivateKey\022\035\n\025ini" +
-      "tialisation_vector\030\001 \002(\014\022\035\n\025encrypted_pr" +
-      "ivate_key\030\002 \002(\014\"\345\001\n\003Key\022\036\n\004type\030\001 \002(\0162\020." +
-      "wallet.Key.Type\022\023\n\013private_key\030\002 \001(\014\022:\n\025" +
-      "encrypted_private_key\030\006 \001(\0132\033.wallet.Enc" +
-      "ryptedPrivateKey\022\022\n\npublic_key\030\003 \001(\014\022\r\n\005" +
-      "label\030\004 \001(\t\022\032\n\022creation_timestamp\030\005 \001(\003\"" +
-      ".\n\004Type\022\014\n\010ORIGINAL\020\001\022\030\n\024ENCRYPTED_SCRYP",
-      "T_AES\020\002\"5\n\006Script\022\017\n\007program\030\001 \002(\014\022\032\n\022cr" +
-      "eation_timestamp\030\002 \002(\003\"\203\001\n\020TransactionIn" +
-      "put\022\"\n\032transaction_out_point_hash\030\001 \002(\014\022" +
-      "#\n\033transaction_out_point_index\030\002 \002(\r\022\024\n\014" +
-      "script_bytes\030\003 \002(\014\022\020\n\010sequence\030\004 \001(\r\"\177\n\021" +
-      "TransactionOutput\022\r\n\005value\030\001 \002(\003\022\024\n\014scri" +
-      "pt_bytes\030\002 \002(\014\022!\n\031spent_by_transaction_h" +
-      "ash\030\003 \001(\014\022\"\n\032spent_by_transaction_index\030" +
-      "\004 \001(\005\"\234\003\n\025TransactionConfidence\0220\n\004type\030" +
-      "\001 \001(\0162\".wallet.TransactionConfidence.Typ",
-      "e\022\032\n\022appeared_at_height\030\002 \001(\005\022\036\n\026overrid" +
-      "ing_transaction\030\003 \001(\014\022\r\n\005depth\030\004 \001(\005\022\021\n\t" +
-      "work_done\030\005 \001(\003\022)\n\014broadcast_by\030\006 \003(\0132\023." +
-      "wallet.PeerAddress\0224\n\006source\030\007 \001(\0162$.wal" +
-      "let.TransactionConfidence.Source\"O\n\004Type" +
-      "\022\013\n\007UNKNOWN\020\000\022\014\n\010BUILDING\020\001\022\013\n\007PENDING\020\002" +
-      "\022\025\n\021NOT_IN_BEST_CHAIN\020\003\022\010\n\004DEAD\020\004\"A\n\006Sou" +
-      "rce\022\022\n\016SOURCE_UNKNOWN\020\000\022\022\n\016SOURCE_NETWOR" +
-      "K\020\001\022\017\n\013SOURCE_SELF\020\002\"\236\004\n\013Transaction\022\017\n\007" +
-      "version\030\001 \002(\005\022\014\n\004hash\030\002 \002(\014\022&\n\004pool\030\003 \001(",
-      "\0162\030.wallet.Transaction.Pool\022\021\n\tlock_time" +
-      "\030\004 \001(\r\022\022\n\nupdated_at\030\005 \001(\003\0223\n\021transactio" +
-      "n_input\030\006 \003(\0132\030.wallet.TransactionInput\022" +
-      "5\n\022transaction_output\030\007 \003(\0132\031.wallet.Tra" +
-      "nsactionOutput\022\022\n\nblock_hash\030\010 \003(\014\022 \n\030bl" +
-      "ock_relativity_offsets\030\013 \003(\005\0221\n\nconfiden" +
-      "ce\030\t \001(\0132\035.wallet.TransactionConfidence\022" +
-      "5\n\007purpose\030\n \001(\0162\033.wallet.Transaction.Pu" +
-      "rpose:\007UNKNOWN\"Y\n\004Pool\022\013\n\007UNSPENT\020\004\022\t\n\005S" +
-      "PENT\020\005\022\014\n\010INACTIVE\020\002\022\010\n\004DEAD\020\n\022\013\n\007PENDIN",
-      "G\020\020\022\024\n\020PENDING_INACTIVE\020\022\":\n\007Purpose\022\013\n\007" +
-      "UNKNOWN\020\000\022\020\n\014USER_PAYMENT\020\001\022\020\n\014KEY_ROTAT" +
-      "ION\020\002\"N\n\020ScryptParameters\022\014\n\004salt\030\001 \002(\014\022" +
-      "\020\n\001n\030\002 \001(\003:\00516384\022\014\n\001r\030\003 \001(\005:\0018\022\014\n\001p\030\004 \001" +
-      "(\005:\0011\"8\n\tExtension\022\n\n\002id\030\001 \002(\t\022\014\n\004data\030\002" +
-      " \002(\014\022\021\n\tmandatory\030\003 \002(\010\"\223\004\n\006Wallet\022\032\n\022ne" +
-      "twork_identifier\030\001 \002(\t\022\034\n\024last_seen_bloc" +
-      "k_hash\030\002 \001(\014\022\036\n\026last_seen_block_height\030\014" +
-      " \001(\r\022!\n\031last_seen_block_time_secs\030\016 \001(\003\022" +
-      "\030\n\003key\030\003 \003(\0132\013.wallet.Key\022(\n\013transaction",
-      "\030\004 \003(\0132\023.wallet.Transaction\022&\n\016watched_s" +
-      "cript\030\017 \003(\0132\016.wallet.Script\022C\n\017encryptio" +
-      "n_type\030\005 \001(\0162\035.wallet.Wallet.EncryptionT" +
-      "ype:\013UNENCRYPTED\0227\n\025encryption_parameter" +
-      "s\030\006 \001(\0132\030.wallet.ScryptParameters\022\017\n\007ver" +
-      "sion\030\007 \001(\005\022$\n\textension\030\n \003(\0132\021.wallet.E" +
-      "xtension\022\023\n\013description\030\013 \001(\t\022\031\n\021key_rot" +
-      "ation_time\030\r \001(\004\";\n\016EncryptionType\022\017\n\013UN" +
-      "ENCRYPTED\020\001\022\030\n\024ENCRYPTED_SCRYPT_AES\020\002B\035\n" +
-      "\023org.bitcoinj.walletB\006Protos"
+      "\n\014wallet.proto\022\006wallet\"A\n\013PeerAddress\022\022\n" +
+      "\nip_address\030\001 \002(\014\022\014\n\004port\030\002 \002(\r\022\020\n\010servi" +
+      "ces\030\003 \002(\004\"M\n\rEncryptedData\022\035\n\025initialisa" +
+      "tion_vector\030\001 \002(\014\022\035\n\025encrypted_private_k" +
+      "ey\030\002 \002(\014\"d\n\020DeterministicKey\022\022\n\nchain_co" +
+      "de\030\001 \002(\014\022\014\n\004path\030\002 \003(\r\022\026\n\016issued_subkeys" +
+      "\030\003 \001(\r\022\026\n\016lookahead_size\030\004 \001(\r\"\302\002\n\003Key\022\036" +
+      "\n\004type\030\001 \002(\0162\020.wallet.Key.Type\022\024\n\014secret" +
+      "_bytes\030\002 \001(\014\022-\n\016encrypted_data\030\006 \001(\0132\025.w" +
+      "allet.EncryptedData\022\022\n\npublic_key\030\003 \001(\014\022",
+      "\r\n\005label\030\004 \001(\t\022\032\n\022creation_timestamp\030\005 \001" +
+      "(\003\0223\n\021deterministic_key\030\007 \001(\0132\030.wallet.D" +
+      "eterministicKey\"b\n\004Type\022\014\n\010ORIGINAL\020\001\022\030\n" +
+      "\024ENCRYPTED_SCRYPT_AES\020\002\022\033\n\027DETERMINISTIC" +
+      "_ROOT_SEED\020\003\022\025\n\021DETERMINISTIC_KEY\020\004\"5\n\006S" +
+      "cript\022\017\n\007program\030\001 \002(\014\022\032\n\022creation_times" +
+      "tamp\030\002 \002(\003\"\203\001\n\020TransactionInput\022\"\n\032trans" +
+      "action_out_point_hash\030\001 \002(\014\022#\n\033transacti" +
+      "on_out_point_index\030\002 \002(\r\022\024\n\014script_bytes" +
+      "\030\003 \002(\014\022\020\n\010sequence\030\004 \001(\r\"\177\n\021TransactionO",
+      "utput\022\r\n\005value\030\001 \002(\003\022\024\n\014script_bytes\030\002 \002" +
+      "(\014\022!\n\031spent_by_transaction_hash\030\003 \001(\014\022\"\n" +
+      "\032spent_by_transaction_index\030\004 \001(\005\"\234\003\n\025Tr" +
+      "ansactionConfidence\0220\n\004type\030\001 \001(\0162\".wall" +
+      "et.TransactionConfidence.Type\022\032\n\022appeare" +
+      "d_at_height\030\002 \001(\005\022\036\n\026overriding_transact" +
+      "ion\030\003 \001(\014\022\r\n\005depth\030\004 \001(\005\022\021\n\twork_done\030\005 " +
+      "\001(\003\022)\n\014broadcast_by\030\006 \003(\0132\023.wallet.PeerA" +
+      "ddress\0224\n\006source\030\007 \001(\0162$.wallet.Transact" +
+      "ionConfidence.Source\"O\n\004Type\022\013\n\007UNKNOWN\020",
+      "\000\022\014\n\010BUILDING\020\001\022\013\n\007PENDING\020\002\022\025\n\021NOT_IN_B" +
+      "EST_CHAIN\020\003\022\010\n\004DEAD\020\004\"A\n\006Source\022\022\n\016SOURC" +
+      "E_UNKNOWN\020\000\022\022\n\016SOURCE_NETWORK\020\001\022\017\n\013SOURC" +
+      "E_SELF\020\002\"\236\004\n\013Transaction\022\017\n\007version\030\001 \002(" +
+      "\005\022\014\n\004hash\030\002 \002(\014\022&\n\004pool\030\003 \001(\0162\030.wallet.T" +
+      "ransaction.Pool\022\021\n\tlock_time\030\004 \001(\r\022\022\n\nup" +
+      "dated_at\030\005 \001(\003\0223\n\021transaction_input\030\006 \003(" +
+      "\0132\030.wallet.TransactionInput\0225\n\022transacti" +
+      "on_output\030\007 \003(\0132\031.wallet.TransactionOutp" +
+      "ut\022\022\n\nblock_hash\030\010 \003(\014\022 \n\030block_relativi",
+      "ty_offsets\030\013 \003(\005\0221\n\nconfidence\030\t \001(\0132\035.w" +
+      "allet.TransactionConfidence\0225\n\007purpose\030\n" +
+      " \001(\0162\033.wallet.Transaction.Purpose:\007UNKNO" +
+      "WN\"Y\n\004Pool\022\013\n\007UNSPENT\020\004\022\t\n\005SPENT\020\005\022\014\n\010IN" +
+      "ACTIVE\020\002\022\010\n\004DEAD\020\n\022\013\n\007PENDING\020\020\022\024\n\020PENDI" +
+      "NG_INACTIVE\020\022\":\n\007Purpose\022\013\n\007UNKNOWN\020\000\022\020\n" +
+      "\014USER_PAYMENT\020\001\022\020\n\014KEY_ROTATION\020\002\"N\n\020Scr" +
+      "yptParameters\022\014\n\004salt\030\001 \002(\014\022\020\n\001n\030\002 \001(\003:\005" +
+      "16384\022\014\n\001r\030\003 \001(\005:\0018\022\014\n\001p\030\004 \001(\005:\0011\"8\n\tExt" +
+      "ension\022\n\n\002id\030\001 \002(\t\022\014\n\004data\030\002 \002(\014\022\021\n\tmand",
+      "atory\030\003 \002(\010\"\223\004\n\006Wallet\022\032\n\022network_identi" +
+      "fier\030\001 \002(\t\022\034\n\024last_seen_block_hash\030\002 \001(\014" +
+      "\022\036\n\026last_seen_block_height\030\014 \001(\r\022!\n\031last" +
+      "_seen_block_time_secs\030\016 \001(\003\022\030\n\003key\030\003 \003(\013" +
+      "2\013.wallet.Key\022(\n\013transaction\030\004 \003(\0132\023.wal" +
+      "let.Transaction\022&\n\016watched_script\030\017 \003(\0132" +
+      "\016.wallet.Script\022C\n\017encryption_type\030\005 \001(\016" +
+      "2\035.wallet.Wallet.EncryptionType:\013UNENCRY" +
+      "PTED\0227\n\025encryption_parameters\030\006 \001(\0132\030.wa" +
+      "llet.ScryptParameters\022\017\n\007version\030\007 \001(\005\022$",
+      "\n\textension\030\n \003(\0132\021.wallet.Extension\022\023\n\013" +
+      "description\030\013 \001(\t\022\031\n\021key_rotation_time\030\r" +
+      " \001(\004\";\n\016EncryptionType\022\017\n\013UNENCRYPTED\020\001\022" +
+      "\030\n\024ENCRYPTED_SCRYPT_AES\020\002B\035\n\023org.bitcoin" +
+      "j.walletB\006Protos"
     };
     com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
       new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
@@ -13866,62 +15017,68 @@ public final class Protos {
             com.google.protobuf.GeneratedMessage.FieldAccessorTable(
               internal_static_wallet_PeerAddress_descriptor,
               new java.lang.String[] { "IpAddress", "Port", "Services", });
-          internal_static_wallet_EncryptedPrivateKey_descriptor =
+          internal_static_wallet_EncryptedData_descriptor =
             getDescriptor().getMessageTypes().get(1);
-          internal_static_wallet_EncryptedPrivateKey_fieldAccessorTable = new
+          internal_static_wallet_EncryptedData_fieldAccessorTable = new
             com.google.protobuf.GeneratedMessage.FieldAccessorTable(
-              internal_static_wallet_EncryptedPrivateKey_descriptor,
+              internal_static_wallet_EncryptedData_descriptor,
               new java.lang.String[] { "InitialisationVector", "EncryptedPrivateKey", });
-          internal_static_wallet_Key_descriptor =
+          internal_static_wallet_DeterministicKey_descriptor =
             getDescriptor().getMessageTypes().get(2);
+          internal_static_wallet_DeterministicKey_fieldAccessorTable = new
+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
+              internal_static_wallet_DeterministicKey_descriptor,
+              new java.lang.String[] { "ChainCode", "Path", "IssuedSubkeys", "LookaheadSize", });
+          internal_static_wallet_Key_descriptor =
+            getDescriptor().getMessageTypes().get(3);
           internal_static_wallet_Key_fieldAccessorTable = new
             com.google.protobuf.GeneratedMessage.FieldAccessorTable(
               internal_static_wallet_Key_descriptor,
-              new java.lang.String[] { "Type", "PrivateKey", "EncryptedPrivateKey", "PublicKey", "Label", "CreationTimestamp", });
+              new java.lang.String[] { "Type", "SecretBytes", "EncryptedData", "PublicKey", "Label", "CreationTimestamp", "DeterministicKey", });
           internal_static_wallet_Script_descriptor =
-            getDescriptor().getMessageTypes().get(3);
+            getDescriptor().getMessageTypes().get(4);
           internal_static_wallet_Script_fieldAccessorTable = new
             com.google.protobuf.GeneratedMessage.FieldAccessorTable(
               internal_static_wallet_Script_descriptor,
               new java.lang.String[] { "Program", "CreationTimestamp", });
           internal_static_wallet_TransactionInput_descriptor =
-            getDescriptor().getMessageTypes().get(4);
+            getDescriptor().getMessageTypes().get(5);
           internal_static_wallet_TransactionInput_fieldAccessorTable = new
             com.google.protobuf.GeneratedMessage.FieldAccessorTable(
               internal_static_wallet_TransactionInput_descriptor,
               new java.lang.String[] { "TransactionOutPointHash", "TransactionOutPointIndex", "ScriptBytes", "Sequence", });
           internal_static_wallet_TransactionOutput_descriptor =
-            getDescriptor().getMessageTypes().get(5);
+            getDescriptor().getMessageTypes().get(6);
           internal_static_wallet_TransactionOutput_fieldAccessorTable = new
             com.google.protobuf.GeneratedMessage.FieldAccessorTable(
               internal_static_wallet_TransactionOutput_descriptor,
               new java.lang.String[] { "Value", "ScriptBytes", "SpentByTransactionHash", "SpentByTransactionIndex", });
           internal_static_wallet_TransactionConfidence_descriptor =
-            getDescriptor().getMessageTypes().get(6);
+            getDescriptor().getMessageTypes().get(7);
           internal_static_wallet_TransactionConfidence_fieldAccessorTable = new
             com.google.protobuf.GeneratedMessage.FieldAccessorTable(
               internal_static_wallet_TransactionConfidence_descriptor,
               new java.lang.String[] { "Type", "AppearedAtHeight", "OverridingTransaction", "Depth", "WorkDone", "BroadcastBy", "Source", });
           internal_static_wallet_Transaction_descriptor =
-            getDescriptor().getMessageTypes().get(7);
+            getDescriptor().getMessageTypes().get(8);
           internal_static_wallet_Transaction_fieldAccessorTable = new
             com.google.protobuf.GeneratedMessage.FieldAccessorTable(
               internal_static_wallet_Transaction_descriptor,
               new java.lang.String[] { "Version", "Hash", "Pool", "LockTime", "UpdatedAt", "TransactionInput", "TransactionOutput", "BlockHash", "BlockRelativityOffsets", "Confidence", "Purpose", });
           internal_static_wallet_ScryptParameters_descriptor =
-            getDescriptor().getMessageTypes().get(8);
+            getDescriptor().getMessageTypes().get(9);
           internal_static_wallet_ScryptParameters_fieldAccessorTable = new
             com.google.protobuf.GeneratedMessage.FieldAccessorTable(
               internal_static_wallet_ScryptParameters_descriptor,
               new java.lang.String[] { "Salt", "N", "R", "P", });
           internal_static_wallet_Extension_descriptor =
-            getDescriptor().getMessageTypes().get(9);
+            getDescriptor().getMessageTypes().get(10);
           internal_static_wallet_Extension_fieldAccessorTable = new
             com.google.protobuf.GeneratedMessage.FieldAccessorTable(
               internal_static_wallet_Extension_descriptor,
               new java.lang.String[] { "Id", "Data", "Mandatory", });
           internal_static_wallet_Wallet_descriptor =
-            getDescriptor().getMessageTypes().get(10);
+            getDescriptor().getMessageTypes().get(11);
           internal_static_wallet_Wallet_fieldAccessorTable = new
             com.google.protobuf.GeneratedMessage.FieldAccessorTable(
               internal_static_wallet_Wallet_descriptor,
